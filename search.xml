<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git常用命令</title>
    <url>/2019/08/19/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>git clone <a href="https://github.com/libgit2/libgit2" target="_blank" rel="noopener">https://github.com/libgit2/libgit2</a> mylibgit # 克隆仓库并重新命名目录</p>
<h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>git init</p>
<a id="more"></a>

<h4 id="跟踪文件和修改"><a href="#跟踪文件和修改" class="headerlink" title="跟踪文件和修改"></a>跟踪文件和修改</h4><p>git add .  # 添加当前目录中文件<br>git add 文件名 # 添加指定文件<br>git add *.txt # 使用通配符</p>
<h4 id="查看修改文件"><a href="#查看修改文件" class="headerlink" title="查看修改文件"></a>查看修改文件</h4><p>查看详情的信息<br>git status<br>查看简短信息<br>git status –short 或 git status -s</p>
<h4 id="查看文件的修改内容"><a href="#查看文件的修改内容" class="headerlink" title="查看文件的修改内容"></a>查看文件的修改内容</h4><p>git diff fileName</p>
<h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>git commit -m “提交注释”</p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><ol>
<li>git push &lt;1-远程主机名&gt; &lt;2-本地分支名&gt; : &lt;3-远程分支名&gt;<br>最全的命令</li>
<li>git push &lt;1-远程主机名&gt; &lt;2-本地分支名&gt;<br>省略(3-远程分支名),根据2-本地分支的追踪关系判断出(3-远程分支名).</li>
<li>git push &lt;1-远程主机名&gt;<br>省略 2和3选项, &lt;2-本地分支名&gt;：就是当前分支；&lt;3-远程分支名&gt;:和本地分支有追踪关系的远程分支</li>
<li>git push<br>省略 1、2、3选项，&lt;1-远程主机名&gt;: 只有一个(1-远程主机名), &lt;2-本地分支名&gt;：就是当前分支；&lt;3-远程分支名&gt;: 和本地分支有追踪关系的远程分支</li>
<li>git push –all origin<br>推送所有本地分支到origin主机</li>
<li>git push origin :master<br>删除master分支，等同于 git push origin –delete master</li>
<li>git push -u origin master 或 git push –set-upstream origin master<br>设置当前分支的追踪关系</li>
</ol>
<h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>git branch 分支名    # 创建分支<br>git branch -a       # 查看所有分支(本地和远程分支)<br>git branch -r       # 查看远程分支<br>git checkout 分支名  # 切换本地分支<br>git checkout -b newBranch origin/newBranch # checkout远程分支到本地<br>git branch -d 分支名 # 删除本地分支<br>git push origin –delete 分支名 # 删除远程分支<br>git branch -m <oldbranch> <newbranch> # 重命名本地分支  </p>
<p>参数：<br>-d 或 –delete：删除<br>-D 或 –delete –force的快捷键<br>-f 或 –force：强制<br>-m 或 –move：移动或重命名<br>-M 或 –move –force的快捷键<br>-r 或 –remote：远程分支<br>-a 或 –all：所有分支  </p>
<h4 id="拉取数据"><a href="#拉取数据" class="headerlink" title="拉取数据"></a>拉取数据</h4><p>git fetch &lt;远程主机名&gt; &lt;分支名&gt; # 拉取指定分支的数据<br>git fetch &lt;远程主机名&gt;         # 拉取所有分支的数据<br>fetch从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。</p>
<h4 id="merge分支"><a href="#merge分支" class="headerlink" title="merge分支"></a>merge分支</h4><p>git checkout master # 切换到master分支<br>git merge dev       # 合并dev分支到当前分支  </p>
<h4 id="拉取并合并-pull"><a href="#拉取并合并-pull" class="headerlink" title="拉取并合并 pull"></a>拉取并合并 pull</h4><p>git pull &lt;远程主机&gt; &lt;远程分支&gt; : &lt;本地分支&gt;<br>git pull &lt;远程主机&gt; &lt;分支名(远程和本地同名)&gt;<br>git pull origin master # 等同于：git fetch master + git merge FETCH_HEAD</p>
<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>git log<br>git log –name-status # 每次修改的文件列表, 显示状态<br>git log –name-only # 每次修改的文件列表<br>git log –stat # 每次修改的文件列表, 及文件修改的统计<br>git whatchanged # 每次修改的文件列表<br>git whatchanged –stat # 每次修改的文件列表, 及文件修改的统计<br>git show # 显示最后一次的文件改变的具体内容<br>git show -5 # 显示最后 5 次的文件改变的具体内容<br>git show commitid # 显示某个 commitid 改变的具体内容<br>$ git log -p FETCH_HEAD # 查看当前分支在服务器上的最新状态  </p>
<h4 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h4><p>git reflog  </p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>git rm 文件名 # 彻底删除文件<br>git rm –cached 文件名 #只消除跟踪，不删除文件  </p>
<h4 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h4><p>git reset –hard HEAD^ ##回退上一个版本<br>git reset –hard HEAD~5 ##回退上5个版本，通过reflog查看  </p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>git checkout – file/git reset HEAD</p>
<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>git tag</p>
<h4 id="git参考"><a href="#git参考" class="headerlink" title="git参考"></a>git参考</h4><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p>
]]></content>
      <categories>
        <category>framework-tools</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2019/07/31/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>博客框架hexo 常用到的一些命令</p>
<a id="more"></a>

<h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><p>主页： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><h4 id="hexo-version"><a href="#hexo-version" class="headerlink" title="hexo version"></a>hexo version</h4><p>显示 Hexo 版本</p>
<h4 id="hexo-new-layout-lt-title-gt"><a href="#hexo-new-layout-lt-title-gt" class="headerlink" title="hexo new [layout] &lt;title&gt;"></a>hexo new [layout] &lt;title&gt;</h4><p>hexo new “我的第一篇文章”<br>hexo new post “我的第一篇文章”<br>hexo new draft “我的草稿”<br>hexo new page “tags”<br>hexo new page “tags”   </p>
<h4 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a>hexo generate</h4><p>生成静态文件,简化命令 hexo g<br>  -d, –deploy    文件生成后立即部署网站<br>  -w, –watch    监视文件变动  </p>
<h4 id="hexo-publish-layout-lt-filename-gt"><a href="#hexo-publish-layout-lt-filename-gt" class="headerlink" title="hexo publish [layout] &lt;filename&gt;"></a>hexo publish [layout] &lt;filename&gt;</h4><p>发布草稿</p>
<h4 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a>hexo server</h4><p>启动hexo服务</p>
<h4 id="hexo-deploy"><a href="#hexo-deploy" class="headerlink" title="hexo deploy"></a>hexo deploy</h4><p>部署站点到git服务器上，命令简写： hexo d<br>-g, –generate    部署之前预先生成静态文件</p>
<h4 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h4><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<h4 id="hexo-–debug"><a href="#hexo-–debug" class="headerlink" title="hexo –debug"></a>hexo –debug</h4><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>
<h4 id="hexo-–draft"><a href="#hexo-–draft" class="headerlink" title="hexo –draft"></a>hexo –draft</h4><p>显示’source/_drafts’ 文件夹中的草稿文章。</p>
<h4 id="hexo-server-–drafts"><a href="#hexo-server-–drafts" class="headerlink" title="hexo server –drafts"></a>hexo server –drafts</h4><p>希望强行预览草稿，或者更改配置文件：<br>render_drafts: true</p>
<h4 id="hexo-publish-layout-lt-filename-gt-1"><a href="#hexo-publish-layout-lt-filename-gt-1" class="headerlink" title="hexo publish [layout] &lt;filename&gt;"></a>hexo publish [layout] &lt;filename&gt;</h4><p> 发布草稿，filename中不含’.md’</p>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>$hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br>重新生成静态文件并启动服务</p>
<h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><p>在scaffolds目录下新建模板photo.md,编辑photo.md，然后就可以根据模板新建文章了，生成的文件存放在 source/_posts中。<br>hexo new photo “My Gallery”</p>
<h4 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h4><p>$ hexo new page categories<br>修改配置文件：<br>$hexo_home/source/categories/index.md<br>添加：<br>type: “categories”</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>$ hexo new page tags<br>修改配置文件：<br>$hexo_home/source/tags/index.md<br>添加一行：<br>type: “tags”</p>
<h4 id="列出站点信息"><a href="#列出站点信息" class="headerlink" title="列出站点信息"></a>列出站点信息</h4><p>type取值： page, post, route, tag, category<br>$ hexo list &lt;Type&gt;</p>
<h4 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h4><p>npm install hexo-deployer-git –save<br>npm install hexo-generator-index –save<br>npm install hexo-generator-archive –save<br>npm install hexo-generator-tag –save<br>npm install hexo-generator-sitemap –save<br>npm install hexo-baidu-url-submit –save<br>npm install hexo-generator-searchdb –save<br>npm install hexo-word-counter –save<br>npm install hexo-auto-excerpt –save<br>npm install hexo-generator-index-pin-top –-save</p>
<h4 id="安装置顶插件"><a href="#安装置顶插件" class="headerlink" title="安装置顶插件"></a>安装置顶插件</h4><ol>
<li>卸载 hexo-generator-index<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm uninstall hexo-generator-index --save</span><br></pre></td></tr></table></figure></li>
<li>安装hexo-generator-index-pin-top<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li>
<li>文章中添加 top:true<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: hexo置顶</span><br><span class="line">date: 2020-05-08 12:00:25</span><br><span class="line">categories: java</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>手册</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上搭建hexo</title>
    <url>/2019/07/24/mac%E4%B8%8A%E6%90%AD%E5%BB%BAhexo/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>&ensp;&ensp;在mac osx系统上安装配置博客框架hexo，并配置发布到github page上。</p>
<a id="more"></a>

<h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><p>主页： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>
<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>$git –version<br>$brew install git<br>$git –version</p>
<h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$node</span> -v</span><br><span class="line"><span class="variable">$brew</span> install node</span><br><span class="line"><span class="variable">$node</span> -v</span><br><span class="line"><span class="variable">$npm</span> --version</span><br><span class="line"><span class="comment"># 如果npm命令不识别，需要加入环境配置中</span></span><br><span class="line"><span class="comment"># 如果使用bash</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>:<span class="variable">$(brew --prefix node)</span>/libexec/bin"</span> &gt;&gt; .bash_profile</span><br><span class="line"><span class="comment"># 如果使用zsh</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"export PATH=<span class="variable">$(brew --prefix node)</span>/libexec/bin"</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure>
<h4 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nvm</span> --version</span><br><span class="line"><span class="variable">$brew</span> install nvm</span><br><span class="line"><span class="comment"># 加入环境配置文件中</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"source <span class="variable">$(brew --prefix nvm)</span>/nvm.sh"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="comment"># 如果用的是zsh，使用下面命令</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"source <span class="variable">$(brew --prefix nvm)</span>/nvm.sh"</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="comment"># 检查是否识别</span></span><br><span class="line"><span class="variable">$nvm</span> --version</span><br></pre></td></tr></table></figure>

<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>官网地址：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>github：<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<h4 id="安装hexo-cli模块"><a href="#安装hexo-cli模块" class="headerlink" title="安装hexo-cli模块"></a>安装hexo-cli模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>查看hexo版本信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> version</span><br></pre></td></tr></table></figure>

<p>升级hexo版本</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ npm i hexo-cli -g</span><br></pre></td></tr></table></figure>

<h4 id="下载hexo文件到blog目录"><a href="#下载hexo文件到blog目录" class="headerlink" title="下载hexo文件到blog目录"></a>下载hexo文件到blog目录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> ~/blog</span><br><span class="line"><span class="variable">$cd</span> ~/blog</span><br><span class="line"><span class="variable">$hexo</span> init</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> init ~/blog</span><br><span class="line"><span class="variable">$cd</span> ~/blog</span><br></pre></td></tr></table></figure>
<p>实际执行的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hexojs/hexo-starter.git</span><br></pre></td></tr></table></figure>
<h4 id="安装hexo的依赖包"><a href="#安装hexo的依赖包" class="headerlink" title="安装hexo的依赖包"></a>安装hexo的依赖包</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> install</span><br></pre></td></tr></table></figure>

<h4 id="生成hexo自带的实例文章"><a href="#生成hexo自带的实例文章" class="headerlink" title="生成hexo自带的实例文章"></a>生成hexo自带的实例文章</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> generate</span><br></pre></td></tr></table></figure>
<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> server</span><br></pre></td></tr></table></figure>
<p>查看启动后效果 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>命令格式：<br>hexo new [layout] title<br>layout默认是post，_config.yml中有配置<br>$hexo new “我的第一篇文章”<br>$hexo new draft “我的草稿”<br>发布草稿<br>$hexo publish “我的草稿”  </p>
<h3 id="生成静态站点文件"><a href="#生成静态站点文件" class="headerlink" title="生成静态站点文件"></a>生成静态站点文件</h3><p>$hexo generate<br>或者<br>$hexo g  </p>
<h3 id="配置部署deploy"><a href="#配置部署deploy" class="headerlink" title="配置部署deploy"></a>配置部署deploy</h3><ol>
<li><p>安装部署插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置<br>修改配置文件 _config.yml 如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/yourName/yourName.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">更新文章</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支规划<br>master做为发布分支，产生的站点静态文件发布到master分支；新建一个分支做写作分支，例如writer分支。</p>
</li>
<li><p>文章部署<br>先生产静态文件再部署<br>$hexo d -g<br>或<br>$hexo g -d  </p>
</li>
<li><p>访问站点查看效果<br>访问你的站点 <a href="https://yourName.github.io" target="_blank" rel="noopener">https://yourName.github.io</a></p>
</li>
<li><p>添加ssh key<br>如果部署github失败，添加ssh key试试<br>参考：<br><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a> <br><br><a href="https://help.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account" target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account</a></p>
</li>
</ol>
<h3 id="创建标签和分类"><a href="#创建标签和分类" class="headerlink" title="创建标签和分类"></a>创建标签和分类</h3><ol>
<li><p>创建标签<br>hexo new page tags</p>
</li>
<li><p>修改配置<br>修改配置文件：<br>$hexo_home/source/tags/index.md<br>添加一行：<br>type: “tags”  </p>
</li>
<li><p>创建分类<br>hexo new page categories  </p>
</li>
<li><p>修改配置文件：<br>$hexo_home/source/categories/index.md<br>添加一行：<br>type: “categories”  </p>
</li>
<li><p>新建文章配置标签和分类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章名称</span><br><span class="line">date: 2019-08-01 12:12:57</span><br><span class="line">categories:</span><br><span class="line">- 我的分类</span><br><span class="line">tags:</span><br><span class="line">- 生活</span><br><span class="line">- 娱乐</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="更换主题-next"><a href="#更换主题-next" class="headerlink" title="更换主题 next"></a>更换主题 next</h3><ol>
<li><p>下载主题<br>以next主题为例，next主题的官网地址：<a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">http://theme-next.iissnan.com</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></li>
<li><p>修改配置 _config.yml  </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme</span>: <span class="string">next</span></span><br><span class="line"><span class="attr">language</span>: <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone</span>: <span class="string">Asia/Shanghai</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生产静态文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> clean</span><br><span class="line"><span class="variable">$hexo</span> g</span><br><span class="line"><span class="variable">$hexo</span> server</span><br></pre></td></tr></table></figure>
<p>查看效果：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
</li>
</ol>
<h3 id="升级hexo"><a href="#升级hexo" class="headerlink" title="升级hexo"></a>升级hexo</h3><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p>hexo,史上最全搭建个人博客<br><a href="https://segmentfault.com/a/1190000021942348" target="_blank" rel="noopener">https://segmentfault.com/a/1190000021942348</a><br>Hexo版本升级指南<br><a href="https://www.jianshu.com/p/802182c01b59" target="_blank" rel="noopener">https://www.jianshu.com/p/802182c01b59</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2019/07/31/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>markdown常用的语法</p>
<a id="more"></a>

<h3 id="gt-标题"><a href="#gt-标题" class="headerlink" title="&gt; 标题"></a>&gt; 标题</h3><p>第一种方法：#</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure>
<p>一般#作为文章大标题，只有一个，### 作为段落标题。  </p>
<p>第二种方式：上下文标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;</span><br><span class="line">二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="gt-段落"><a href="#gt-段落" class="headerlink" title="&gt; 段落"></a>&gt; 段落</h3><p> 换行方式：<br>    1. 行尾加两个空格<br>    2. 段落后加一个空行，表示新起一行<br>    3. 行尾使用&lt;br&gt; 换行  </p>
<h3 id="gt-区块引用"><a href="#gt-区块引用" class="headerlink" title="&gt; 区块引用"></a>&gt; 区块引用</h3><p>  段落开头使用 &gt; 并紧跟一个空格<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块  </span><br><span class="line">&gt; 区块2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区块<br>区块2</p>
</blockquote>
<p>  区块嵌套<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块</span><br><span class="line">&gt; &gt;区块嵌套</span><br><span class="line">&gt; &gt; &gt;区块嵌套</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区块</p>
<blockquote>
<p>区块嵌套</p>
<blockquote>
<p>区块嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<p>  区块和列表结合使用<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 列表1</span><br><span class="line">&gt; 2. 列表2</span><br><span class="line">&gt; 3. 列表3</span><br><span class="line">&gt; * 无序列表1</span><br><span class="line">&gt; * 无序列表2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 列表中使用区块</span><br><span class="line">    &gt; 区块1  </span><br><span class="line">    &gt; 区块2  </span><br><span class="line">* 列表中使用区块2</span><br><span class="line">    &gt; 区块3  </span><br><span class="line">    &gt; 区块4</span><br></pre></td></tr></table></figure>
<ul>
<li>列表中使用区块<blockquote>
<p>区块1<br>区块2  </p>
</blockquote>
</li>
<li>列表中使用区块2<blockquote>
<p>区块3<br>区块4</p>
</blockquote>
</li>
</ul>
<h3 id="gt-代码区块"><a href="#gt-代码区块" class="headerlink" title="&gt; 代码区块"></a>&gt; 代码区块</h3><ol>
<li>单行代码使用 `` 包围<br>`RiskVo vo = riskService.getRiskInfo();`<br><code>RiskVo vo = riskService.getRiskInfo();</code></li>
</ol>
<ol start="2">
<li><p>多行代码块使用```包围，可以指定语言  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96; javascript</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">  alert(&#39;code block&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#96;&#96;&#96;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'code block'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="gt-强调"><a href="#gt-强调" class="headerlink" title="&gt; 强调"></a>&gt; 强调</h3><ol>
<li><p>使用 * 或 _ 表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*  </span><br><span class="line">**粗体文本**  </span><br><span class="line">***粗斜体文本***  </span><br><span class="line">_斜体文本_  </span><br><span class="line">__粗体文本__  </span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>
<p><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong></p>
</li>
<li><p>删除线用波浪线表示  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~删除我~~</span><br></pre></td></tr></table></figure>
<p><del>删除我</del></p>
</li>
<li><p>下划线 &lt;u&gt;  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;下划线&lt;\u&gt;</span><br></pre></td></tr></table></figure>
<p><u>下划线</p>
</li>
</ol>
<h3 id="gt-列表"><a href="#gt-列表" class="headerlink" title="&gt; 列表"></a>&gt; 列表</h3><ol>
<li><p>无序列表(*,+,- 表示)  </p>
<ul>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ul>
</li>
<li><p>有序列表(数字 + . + 空格)</p>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<p>嵌套时使用4个空格或一个制表符</p>
</li>
</ol>
<h3 id="gt-分割线"><a href="#gt-分割线" class="headerlink" title="&gt; 分割线"></a>&gt; 分割线</h3><p>  一行用三个以上的星号、减号、底线来建立一个分隔线<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure></p>
<h3 id="gt-链接"><a href="#gt-链接" class="headerlink" title="&gt; 链接"></a>&gt; 链接</h3><ol>
<li><p>行内式链接<br>格式：[链接名称](链接地址 “标题”)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索 \[百度\](https:&#x2F;&#x2F;www.baidu.com &quot;这是百度&quot;)</span><br><span class="line">自动生成链接 &lt;https:&#x2F;&#x2F;www.toutiao.com&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>搜索 <a href="http://www.baidu.com" target="_blank" rel="noopener" title="这是百度">百度</a><br>自动生成链接 <a href="https://www.toutiao.com/" target="_blank" rel="noopener">https://www.toutiao.com/</a></p>
</li>
<li><p>参考式链接<br>格式：<br>[链接名称][链接标记]<br>[链接标记]: 链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索 [百度][1]  </span><br><span class="line">搜索 [头条][toutiao]  </span><br><span class="line">搜索 [google][]  </span><br><span class="line"></span><br><span class="line">[1]: https:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">[toutiao]: https:&#x2F;&#x2F;www.toutiao.com</span><br><span class="line">[google]: https:&#x2F;&#x2F;www.google.com</span><br></pre></td></tr></table></figure>

<p>搜索 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a><br>搜索 <a href="https://www.toutiao.com" target="_blank" rel="noopener">头条</a><br>搜索 <a href="https://www.google.com" target="_blank" rel="noopener">google</a>  </p>
</li>
</ol>
<h3 id="gt-图片"><a href="#gt-图片" class="headerlink" title="&gt; 图片"></a>&gt; 图片</h3><p>格式与链接相似，也含有行内式和参考式</p>
<ol>
<li><p>行内式链接<br>格式：![图片名称](图片地址 “标题”)  </p>
<p>图片： ![百度](path/logo.png “百度logo”)  </p>
</li>
<li><p>参考式链接<br>格式：<br>[图片名称][链接标记]<br>[链接标记]: 图片地址</p>
<p>图片： [百度][1]<br>图片： [头条][toutiao]<br>图片： [google][]  </p>
<p> [1]: path/logo.png<br> [toutiao]: path/logo.png<br> [google]: path/logo.png  </p>
</li>
</ol>
<h3 id="gt-表格"><a href="#gt-表格" class="headerlink" title="&gt; 表格"></a>&gt; 表格</h3><pre><code>语法格式：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 表头 | 表头| 表头|</span><br><span class="line">| ---: | :--- | :---:|</span><br><span class="line">|右对齐|左对齐| 居中对齐 |</span><br><span class="line">|右对齐|左对齐| 居中对齐 |</span><br></pre></td></tr></table></figure></code></pre><h3 id="gt-反斜杠"><a href="#gt-反斜杠" class="headerlink" title="&gt; 反斜杠"></a>&gt; 反斜杠</h3><p>在一些符号前加反斜杠进行转义，这些符号在markdown中有语法含义，可以加反斜杠的符号如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure>


<h3 id="gt-流程图"><a href="#gt-流程图" class="headerlink" title="&gt; 流程图"></a>&gt; 流程图</h3><p>TODO</p>
<h3 id="gt-常用html元素"><a href="#gt-常用html元素" class="headerlink" title="&gt; 常用html元素"></a>&gt; 常用html元素</h3><ol>
<li><p>字体属性font<br><code>&lt;font color=red face=“黑体” size=3&gt;红色&lt;/font&gt;</code><br><font color=red face=“黑体” size=3>红色</font></p>
</li>
<li><p>文字排版<br><code>&lt;center&gt;这一行需要居中&lt;/center&gt;</code></p>
<center>这一行需要居中</center>

<p><code>&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</code></p>
<p align="right">右对齐</p>
`<p align="left">左对齐</p>`
<p align="left">左对齐</p>
</li>
<li><p>首行缩进<br>HTML提供了5种空格实体:   </p>
<ul>
<li><p><code>&amp;nbsp;</code> 非断行空格,常规的宽度，常用</p>
</li>
<li><p><code>&amp;ensp;</code> 半角空格(En Space)  </p>
</li>
<li><p><code>&amp;emsp;</code> 全角空格(Em Space)  </p>
<p>参考 : <a href="https://www.jianshu.com/p/160e5cb0209c" target="_blank" rel="noopener">https://www.jianshu.com/p/160e5cb0209c</a></p>
</li>
</ul>
</li>
<li><p>span 元素<br><code>&lt;span style=&quot;font-size:15px;background:red;&quot;&gt;**Bigger**&lt;/span&gt;</code></p>
<p><span style="font-size:15px;background:red;"><strong>Bigger</strong></span></p>
</li>
<li><p>details 折叠语法标签</p>
<details>
<summary>点击时的区域标题：点击查看详细内容</summary>
<p> - 测试 测试测试</p>
<pre><code>title，value，callBack可以缺省</code></pre>
</details>
</li>
<li><p>kbd 按键标识<br><code>&lt;kbd&gt;ctr&lt;/kbd&gt; &lt;kbd&gt;+&lt;/kbd&gt; &lt;kbd&gt;D&lt;/kbd&gt;</code><br><kbd>ctr</kbd> <kbd>+</kbd> <kbd>D</kbd>  </p>
</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>手册</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql中的锁详解</title>
    <url>/2020/01/03/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h4><p>了解mysql中的各种锁</p>
<a id="more"></a>
<h4 id="事务ACID四大特性"><a href="#事务ACID四大特性" class="headerlink" title="事务ACID四大特性"></a>事务ACID四大特性</h4><ul>
<li>Atomicity 原子性：要么成功，要么失败，不允许部分成功或失败。</li>
<li>Consistency 一致性：事务操作之后数据库状态和业务规则一致。AB转账，A减少并且B增加。</li>
<li>Isolation 隔离性：多个事务并发执行，相互之间不干扰，和独立执行事务一样。</li>
<li>Durability 持久性：事务提交后被持久化到数据库.</li>
</ul>
<h4 id="并发访问面临的问题"><a href="#并发访问面临的问题" class="headerlink" title="并发访问面临的问题"></a>并发访问面临的问题</h4><table>
<thead>
<tr>
<th align="left">英文名</th>
<th align="left">中文名</th>
<th align="left">问题描述</th>
<th align="left">缺点</th>
<th align="left">mysql解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Dirty Read</td>
<td align="left">脏读</td>
<td align="left">事务A未提交的数据被其他事务B读取，如果事务A回滚，事务B的数据就是错误。</td>
<td align="left">会读到未提交的数据(脏数据)</td>
<td align="left">没加锁时会脏读产生，加锁就可以解决脏读</td>
</tr>
<tr>
<td align="left">No-Repeatable read</td>
<td align="left">不可重复读</td>
<td align="left">一次事务中两次相同数据的内容不一致，同一数据的内容有变化了，导致不能重复读取同一数据，原因是在两次查询时间段内其他事务更新(update和delete)了数据。</td>
<td align="left">一次事务不能重复读取同一数据</td>
<td align="left">检索数据时用到索引，使用索引上的行锁控制行的更新和删除，</td>
</tr>
<tr>
<td align="left">Phantom Read</td>
<td align="left">幻读</td>
<td align="left">一次事务中两次读取一定范围的数据时有新数据(‘幻影’行)产生，原因是在两次查询时间段内其他事务新增(insert)了数据。【另解释：幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。】</td>
<td align="left">一次事务两次读取数据的数量不同了，</td>
<td align="left">Next-Key锁(行锁和GAP间隙锁两者的合并) ,行锁锁定一定范围的行，间隙锁锁定范围两边的数据，这样就保证不会插入数据</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
<th align="left">存在问题</th>
<th align="left">解决的问题</th>
<th align="left">mysql解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEFAULT</td>
<td align="left">默认值，spring使用数据库设置的隔离级别</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">READ_UNCOMMITTED</td>
<td align="left">读未提交内容</td>
<td align="left">脏读，不可重复读，幻读</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">READ_COMMITTED</td>
<td align="left">读取提交内容</td>
<td align="left">不可重复读，幻读</td>
<td align="left">脏读</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">REPEATABLE_READ</td>
<td align="left">可重复读，mysql默认值</td>
<td align="left">幻读</td>
<td align="left">脏读，不可重复读</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SERIALIZABLE</td>
<td align="left">可串行化</td>
<td align="left"></td>
<td align="left">脏读，不可重复读，幻读</td>
<td align="left">使用悲观锁理论，读加共享锁，写加排他锁，读写互斥</td>
</tr>
</tbody></table>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol>
<li>按使用方式分类:<ul>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
</li>
</ol>
<ol start="2">
<li>按封锁级别分类:<ul>
<li>共享锁(S锁)</li>
<li>排他锁(X锁)</li>
<li>意向锁</li>
<li>间隙锁</li>
</ul>
</li>
</ol>
<ol start="3">
<li>按封锁类型分类：<ul>
<li>排他锁(又称写锁，X锁)：阻止其他事务对数据对象A的读和写</li>
<li>共享锁(S锁)<br>封锁数据对象可以是表和行</li>
</ul>
</li>
</ol>
<ol start="3">
<li>按封锁的数据粒度分类：<ul>
<li>表级锁定</li>
<li>行级锁定</li>
<li>页级锁定</li>
</ul>
</li>
</ol>
<ol start="4">
<li>innodb 内部意向锁：<ul>
<li>意向排他锁</li>
<li>意向共享锁<br>在表锁和行锁多粒度锁共存时，行加锁时需先获取表的意向锁，通过意向锁实现多粒度锁机制，意向锁是表级锁。</li>
</ul>
</li>
</ol>
<h4 id="锁的详解"><a href="#锁的详解" class="headerlink" title="锁的详解"></a>锁的详解</h4><h5 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h5><p>排他锁又称独占锁、写锁、X锁，目的是阻塞其他事务对数据进行读和写操作。事务T对数据对象A加上X锁，此时只有事务T可以对数据对象A进行读取和修改，其他事务无法对对象A加锁，直到事务T释放了X锁。排他锁就是</p>
<h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><p>共享锁又称读锁、S锁，目的是阻塞其他事务对数据进行写操作。事务T对数据对象A加上S锁，其他事务加上S锁可以读取数据对象A，如果其他事务想修改数据对象，加X锁会失败。</p>
<h5 id="表级锁（table-level）"><a href="#表级锁（table-level）" class="headerlink" title="表级锁（table level）"></a>表级锁（table level）</h5><p>数据对象锁定粒度是整个表，由于粒度大，逻辑简单，所以表锁开销小、加锁快、不会出现死锁。缺点：粒度大导致锁冲突概率高，并发性能很差。</p>
<ul>
<li>优点：逻辑简单，开销小，加锁快，不会出现死锁</li>
<li>缺点：锁冲突概率高，并发性能低</li>
</ul>
<p><strong>什么时候使用表锁?</strong></p>
<blockquote>
<ol>
<li>事务需要更新大部分或全部数据，表比较大，如果默认使用行锁，会导致长时间锁等待和频繁锁冲突，事务效率低，这种情况下使用表锁会提高事务的执行速度。  </li>
<li>事务涉及多表，逻辑比较复杂，可能会引起死锁，造成大量事务回滚，这种情况可以考虑一次性锁定相关表，从而避免死锁，减少事务回滚带来的开销。</li>
</ol>
</blockquote>
<h5 id="行级锁（row-level）"><a href="#行级锁（row-level）" class="headerlink" title="行级锁（row level）"></a>行级锁（row level）</h5><p>数据对象锁定粒度为数据行，由于粒度很小，每次获取和释放锁需要处理的逻辑比较多，系统开销比较大，但锁冲突的概率大大降低，并发性能比较好。  </p>
<ul>
<li>优点：锁粒度小，锁冲突概率低，并发性能好</li>
<li>缺点：锁逻辑复杂，系统开销大，容易发生死锁</li>
</ul>
<h5 id="页级锁-page-level"><a href="#页级锁-page-level" class="headerlink" title="页级锁 (page level)"></a>页级锁 (page level)</h5><p>页级锁是mysql特有的一种锁，页级锁粒度介于表级锁和行级锁之间，所以获取锁的资源开销和并发性能也介于两者之间，页级锁也会出现死锁情况。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了实现表锁和行锁共存，实现多粒度锁机制，innoDB使用了两个内部的意向锁（Intention Locks）,这两个都是表锁。<br>意向锁的主要作用是提升存储引擎性能，innoDB中的行级S锁和行级X锁，每当事务到来时，存储引擎需要遍历所有行的锁持有情况，性能较低，因此引入意向锁，检查行锁前先检查意向锁是否存在，如果存在则阻塞线程。</p>
<h5 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a>意向排他锁</h5><p>事务在给一个数据行加排他锁之前必须先获得该表的意向排他锁。</p>
<h5 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h5><p>事务在给一个数据行加共享锁之前必须先获得该表的意向共享锁。</p>
<h4 id="间隙锁-next-key锁"><a href="#间隙锁-next-key锁" class="headerlink" title="间隙锁(next-key锁)"></a>间隙锁(next-key锁)</h4><p>&nbsp;&nbsp;当我们用范围条件检索数据，并请求共享锁或排他锁时，InnoDB会给符合条件数据记录的索引加上行锁，对键值在条件范围内但并不存在的记录，称为间隙，InnoDB会给间隙加锁，称为间隙锁。  </p>
<h6 id="1-间隙锁产生的条件"><a href="#1-间隙锁产生的条件" class="headerlink" title="1. 间隙锁产生的条件"></a>1. 间隙锁产生的条件</h6><p>InnoDB间隙锁产生需要满足三个条件：</p>
<ol>
<li>隔离级别是RR（可重复读）</li>
<li>当前读</li>
<li>检索过程用的了索引</li>
</ol>
<h6 id="2-间隙锁的作用"><a href="#2-间隙锁的作用" class="headerlink" title="2. 间隙锁的作用"></a>2. 间隙锁的作用</h6><p>官方文档：间隙锁的目的是让其他事务无法在间隙中新增数据。  </p>
<p>InnoDB在RR模式中间隙锁的两个作用：</p>
<ol>
<li>保障数据的恢复和复制<blockquote>
<p>数据库数据的恢复是通过binlog实现的，binlog中记录了执行成功的DML语句，在数据恢复时需要保证数据之间的事物顺序，间隙锁避免了在一批数据中插入其他事务。</p>
</blockquote>
</li>
<li>防止幻读<blockquote>
<ol>
<li>防止在间隙中执行insert语句</li>
<li>防止将已有的数据update到间隙中</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="InnoDB表锁模式兼容性列表"><a href="#InnoDB表锁模式兼容性列表" class="headerlink" title="InnoDB表锁模式兼容性列表"></a>InnoDB表锁模式兼容性列表</h4><table>
<thead>
<tr>
<th align="left">当前锁模式/请求锁模式</th>
<th align="left">X</th>
<th align="left">IX</th>
<th align="left">S</th>
<th align="left">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">IX</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">IS</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<h4 id="锁分类表"><a href="#锁分类表" class="headerlink" title="锁分类表"></a>锁分类表</h4><table>
<thead>
<tr>
<th align="left">锁粒度/锁分类</th>
<th align="left">排他锁</th>
<th align="left">共享锁</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">表级</td>
<td align="left">表级排他锁</td>
<td align="left">表级共享锁</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">行级</td>
<td align="left">行级排他锁</td>
<td align="left">行锁共享锁</td>
<td align="left">innoDB的行锁是加在索引项，通过索引检索的数据才能使用行锁，否则使用表锁</td>
</tr>
<tr>
<td align="left">多粒度共存</td>
<td align="left">表级意向排他锁</td>
<td align="left">表级意向共享锁</td>
<td align="left">表锁和行锁同时使用时，只有获取表级意向锁成功后，才可以加行锁。意向锁是innoDB的内部锁，保证了表锁和行锁不会冲突</td>
</tr>
</tbody></table>
<h4 id="多版本并发控制协议"><a href="#多版本并发控制协议" class="headerlink" title="多版本并发控制协议"></a>多版本并发控制协议</h4><p>mysql面对并发问题，使用了两个并发控制方法：</p>
<ol>
<li>基于锁的并发控制(Based-lock Concurrency Control)</li>
<li>基于多版本的并发控制(MVCC Multi-Version Concurrency Control)</li>
</ol>
<h5 id="mvcc优点："><a href="#mvcc优点：" class="headerlink" title="mvcc优点："></a>mvcc优点：</h5><ol>
<li>读操作不加锁</li>
<li>读写不冲突<br>这两个优点，使得数据库并发性很好。  </li>
</ol>
<h5 id="mvcc缺点："><a href="#mvcc缺点：" class="headerlink" title="mvcc缺点："></a>mvcc缺点：</h5><ol>
<li>每行都额外存储的版本信息</li>
<li>需要维护行的数据版本信息</li>
<li>检索时需要进行版本比较，降低查询效率</li>
<li>定期清理不需要的行版本，回收空间，增加了开销</li>
</ol>
<h5 id="mvcc实现机制"><a href="#mvcc实现机制" class="headerlink" title="mvcc实现机制"></a>mvcc实现机制</h5><ol>
<li>每行都隐藏一个版本字段，记录着该行的最新版本</li>
<li>每次查询开始时读取行数据并分配新的版本号</li>
<li>通过比较版本号确定后续操作</li>
</ol>
<h5 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h5><p>有两种读操作：快照读，当前读</p>
<ol>
<li><p>快照读 snapshot read</p>
<blockquote>
<p>快照读：读取的是记录的可见版本，不用加锁。<br>快照读适用隔离级别: Read Committed 和 Read Repeatable。<br>select语句使用的就是快照读，除了加锁的select。</p>
</blockquote>
</li>
<li><p>当前读 current</p>
<blockquote>
<p>当前读：读取最新成功事务的数据，并加锁，以阻塞其他事务修改数据。<br>当前读通过Next-key锁(行锁+间隙锁)来实现 。<br>使用当前读的有两类语句：</p>
</blockquote>
<ol>
<li>DML语句: insert(Unique Key的冲突检查)、update、delete</li>
<li>加锁select: select …for update; select … for share model</li>
</ol>
</li>
</ol>
<h4 id="sql显示指定锁"><a href="#sql显示指定锁" class="headerlink" title="sql显示指定锁"></a>sql显示指定锁</h4><ul>
<li><p>表级排他锁  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock tables tableName [LOW_PRIORITY] WRITE</span><br><span class="line">...</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT&#x3D;0;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>表级共享锁  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock tables tableName READ [LOCAL]</span><br><span class="line">...</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行级排他锁  </p>
<ol>
<li>insert、update、delete语句，innodb自动加排他锁(X锁)</li>
<li>查询语句指定排他锁：select * from table where ? for update;</li>
</ol>
</li>
<li><p>行级共享锁  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>MyIsam表锁是 deadlock free的，所以不会产生死锁。<br>在InnoDB 中锁逐步获取的，所以会发送死锁情况。发生死锁后数据库有两种方式解决：</p>
<ol>
<li>innoDB自动检查到死锁，会让一个事务释放锁并回退，另一个事务获得锁，继续完成事务。</li>
<li>行锁是数据库引擎级别，表锁是Mysql Server级别，所以涉及到外部锁或表锁时，innoDB不能完全检测到死锁。这就需要通过设置锁超时参数来解决了，锁超时参数：innodb_lock_wait_timeout。这个参数主要是解决大量事务无法获取锁而挂起消耗大量资源问题的。</li>
</ol>
<h5 id="避免死锁方法"><a href="#避免死锁方法" class="headerlink" title="避免死锁方法"></a>避免死锁方法</h5><ol>
<li>应用中尽量以相同的顺序访问多个表</li>
<li>批量处理数据时，让数据每次以固定的顺序进行处理</li>
<li>在事务中申请锁时尽量一步到位，不应先申请共享锁再申请排他锁</li>
<li>前面讲过，在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。</li>
<li>当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第3个线程又来申请排他锁，也会出现死锁。</li>
</ol>
<h5 id="减少锁冲突"><a href="#减少锁冲突" class="headerlink" title="减少锁冲突"></a>减少锁冲突</h5><ol>
<li>尽量使用较低的隔离级别</li>
<li>精心设计索引，尽量使用索引访问数据，可以加行锁，可以减少锁冲突的机会</li>
<li>选择合理的事物大小，事物越小发送冲突的几率越小</li>
<li>加锁时尽量一步到位</li>
<li>应用中尽量以相同的顺序访问多个表，减少死锁的机会</li>
<li>尽量用相等的条件访问数据，这样减少间隙锁对并发的影响</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ol>
<h4 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 查看进程</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</span><br><span class="line">// 查看是否锁表</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> In_use &gt; <span class="number">0</span>;</span><br><span class="line">// 查看正在锁的事务</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line">// 查看等待锁的事务</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br><span class="line">// 确定最后一个死锁产生的原因</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">innodb</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL内部有两组专门的状态变量记录系统内部锁资源争用情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">Table_locks_immediate：产生表级锁定的次数；</span><br><span class="line">Table_locks_waited：出现表级锁定争用而发生等待的次数；</span><br></pre></td></tr></table></figure>

<p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like 'InnoDB_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| InnoDB_row_lock_current_waits | 0     |</span><br><span class="line">| InnoDB_row_lock_time          | 0     |</span><br><span class="line">| InnoDB_row_lock_time_avg      | 0     |</span><br><span class="line">| InnoDB_row_lock_time_max      | 0     |</span><br><span class="line">| InnoDB_row_lock_waits         | 0     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InnoDB 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：</span><br><span class="line">InnoDB_row_lock_current_waits：当前正在等待锁定的数量；</span><br><span class="line">InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；</span><br><span class="line">InnoDB_row_lock_time_avg：每次等待所花平均时间；</span><br><span class="line">InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</span><br><span class="line">InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；</span><br><span class="line">尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>MySQL 锁机制——必知必会<br><a href="https://www.jianshu.com/p/0d5b7cd592f9" target="_blank" rel="noopener">https://www.jianshu.com/p/0d5b7cd592f9</a>  </p>
<p>MySQL优化笔记（八）–锁机制超详细解析（锁分类、事务并发、引擎并发控制）<br><a href="https://www.jianshu.com/p/163c96983ca9" target="_blank" rel="noopener">https://www.jianshu.com/p/163c96983ca9</a>  </p>
<p>mysql事务和锁InnoDB(转)<br><a href="https://yq.aliyun.com/articles/269775?spm=a2c4e.11153940.0.0.17e24148Ig0laX" target="_blank" rel="noopener">https://yq.aliyun.com/articles/269775?spm=a2c4e.11153940.0.0.17e24148Ig0laX</a></p>
<p>MySQL详解－－锁，事务<br><a href="https://yq.aliyun.com/articles/312765?spm=a2c4e.11153940.0.0.17e24148Ig0laX" target="_blank" rel="noopener">https://yq.aliyun.com/articles/312765?spm=a2c4e.11153940.0.0.17e24148Ig0laX</a></p>
<p>大众点评工程师：从特性说起，漫谈MySQL中的事务及其实现<br><a href="https://yq.aliyun.com/articles/79623?spm=a2c4e.11153940.0.0.279e908f4XiOak" target="_blank" rel="noopener">https://yq.aliyun.com/articles/79623?spm=a2c4e.11153940.0.0.279e908f4XiOak</a></p>
<p>MySQL—数据库从入门走向大神系列(六)-事务处理与事务隔离(锁机制)<br><a href="https://yq.aliyun.com/articles/272908?spm=a2c4e.11153940.0.0.279e908f4XiOak" target="_blank" rel="noopener">https://yq.aliyun.com/articles/272908?spm=a2c4e.11153940.0.0.279e908f4XiOak</a></p>
<p>MySQL中的锁（表锁、行锁）<br><a href="https://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenqionghe/p/4845693.html</a></p>
<p>mysql数据库的锁有多少种，怎么编写加锁的sql语句<br><a href="https://www.cnblogs.com/sessionbest/articles/8689071.html" target="_blank" rel="noopener">https://www.cnblogs.com/sessionbest/articles/8689071.html</a></p>
<p>探索Mysql锁机制(一)——乐观锁&amp;悲观锁<br><a href="https://www.jianshu.com/p/ed896335b3b4" target="_blank" rel="noopener">https://www.jianshu.com/p/ed896335b3b4</a></p>
<p>探索Mysql锁机制(二)——共享锁&amp;排他锁&amp;意向锁&amp;间隙锁<br><a href="https://www.jianshu.com/p/904f52bde904" target="_blank" rel="noopener">https://www.jianshu.com/p/904f52bde904</a></p>
<p>Mysql加锁过程详解<br><a href="https://www.cnblogs.com/crazylqy/p/7611069.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7611069.html</a></p>
<p>《快照读、当前读和MVCC》<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">https://www.cnblogs.com/AlmostWasteTime/p/11466520.html</a></p>
<p>从MVCC协议来区分不可重复读与幻读<br><a href="https://segmentfault.com/a/1190000020680168?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020680168?utm_source=tag-newest</a></p>
]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>node常用命令</title>
    <url>/2019/07/31/node%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>node常用到的一些命令</p>
<a id="more"></a>
<h3 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h3><p>官方地址： <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>nodejs中文：<a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a><br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p>
<h3 id="node-常用命令"><a href="#node-常用命令" class="headerlink" title="node 常用命令"></a>node 常用命令</h3><ol>
<li>node ##进入 REPL 环境</li>
<li>node -e ‘console.log(“Hello World”)’  ##执行脚本字符串</li>
<li>运行脚本文件<br>$ node index.js<br>$ node path/index.js<br>$ node path/index（可以不用加js后缀，默认就是js后缀）</li>
<li>node –help  ##查看帮忙文档</li>
</ol>
<h3 id="nvm-常用命令"><a href="#nvm-常用命令" class="headerlink" title="nvm 常用命令"></a>nvm 常用命令</h3><ol>
<li>nvm list  ##是查找本电脑上所有的node版本<ul>
<li>nvm list  ##查看已经安装的版本</li>
<li>nvm list installed  ##查看已经安装的版本</li>
<li>nvm list available  ##查看网络可以安装的版本</li>
</ul>
</li>
<li>nvm install  ##安装最新版本nvm</li>
<li>nvm use <version>  ## 切换使用指定的版本node</li>
<li>nvm ls  ##列出所有版本</li>
<li>nvm current  ##显示当前版本</li>
<li>nvm alias <name> <version>  ## 给不同的版本号添加别名</li>
<li>nvm unalias <name>  ## 删除已定义的别名</li>
<li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</li>
<li>nvm on  ##打开nodejs控制</li>
<li>nvm off  ##关闭nodejs控制</li>
<li>nvm proxy  ##查看设置与代理</li>
<li>nvm node_mirror [url]<br>设置或者查看setting.txt中的node_mirror，如果不设置的默认是 <a href="https://nodejs.org/dist/" target="_blank" rel="noopener">https://nodejs.org/dist/</a></li>
<li>nvm uninstall <version>  ##卸载制定的版本</li>
<li>nvm use [version] [arch]  ##切换制定的node版本和位数</li>
<li>nvm root [path]  ##设置和查看root路径</li>
<li>nvm version  ##查看当前的版本</li>
</ol>
<h3 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h3><ol>
<li>npm install <name> -g   ##将包安装到全局环境中    <ul>
<li>npm install –python=python2.7  </li>
<li>npm config set python python2.7   </li>
<li>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>   ##安装cnpm (国内淘宝镜像源),主要用于某些包或命令程序下载不下来的情况</li>
<li>npm install -g express 全局安装express模块</li>
</ul>
</li>
<li>npm list ## 查看当前目录下已安装的node包<ul>
<li>Node模块搜索是从代码执行的当前目录开始的，搜索结果取决于当前使用的目录中的node_modules下的内容。</li>
<li>$ npm list parseable=true可以目录的形式来展现当前安装的所有node包</li>
</ul>
</li>
<li>npm help  ## 查看帮助命令</li>
<li>npm view moudleName dependencies  ##查看包的依赖关系</li>
<li>npm view moduleName repository.url  ##查看包的源文件地址</li>
<li>npm view moduleName engines  ##查看包所依赖的Node的版本</li>
<li>npm help folders  ##查看npm使用的所有文件夹</li>
<li>npm rebuild moduleName  ##用于更改包内容后进行重建</li>
<li>npm outdated   ##检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</li>
<li>npm update moduleName  ##升级更新node模块   </li>
<li>npm uninstall moudleName  ##卸载node模块</li>
<li>npm search packageName  ##需要检验某个包名是否已存在</li>
<li>npm init  ##会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</li>
<li>npm root  ##查看当前包的安装路径</li>
<li>npm root -g   ##查看全局的包的安装路径</li>
<li>npm -v    ##查看npm安装的版本</li>
<li>npm show <name>  ##显示模块详情<br>npm show express</li>
<li>npm i n -g -f   ##安装 n 模块</li>
<li>n –version   ##查看n版本</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>命令提示工具navi</title>
    <url>/2020/05/26/%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E5%B7%A5%E5%85%B7navi/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>navi 是一个命令快速查找工具，官网地址：<a href="https://github.com/denisidoro/navi。" target="_blank" rel="noopener">https://github.com/denisidoro/navi。</a><br>navi中文本查找使用的是fzf(<a href="https://github.com/junegunn/fzf" target="_blank" rel="noopener">https://github.com/junegunn/fzf</a>) 。</p>
<a id="more"></a>

<h3 id="安装navi"><a href="#安装navi" class="headerlink" title="安装navi"></a>安装navi</h3><p>使用Homebrew 或 Linuxbrew安装navi<br>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> brew install navi</span></span><br></pre></td></tr></table></figure><br>其他方式参考官方文档</p>
<h3 id="配置navi"><a href="#配置navi" class="headerlink" title="配置navi"></a>配置navi</h3><ul>
<li><p>配置Shell widget<br>添加下面信息到 .bashrc中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> bash</span></span><br><span class="line">source &lt;(navi widget bash)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh</span></span><br><span class="line">source &lt;(navi widget zsh)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> fish</span></span><br><span class="line">navi widget fish | source</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置heatsheets</p>
<ol>
<li><p>引入官方cheatsheets</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> navi repo add https://github.com/denisidoro/cheats</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>添加自定义 cheatsheets</p>
<ul>
<li>navi自带的cheatsheets目录是 $(navi_home)/libexec/cheats, 远程仓库地址为：<a href="https://github.com/denisidoro/cheats" target="_blank" rel="noopener">https://github.com/denisidoro/cheats</a></li>
<li>在 .bashrc或 .zshrc中添加NAVI_PATH<br>export NAVI_PATH=/usr/local/opt/navi/libexec/cheats:/Users/myhome/navi-command-cheat/cheats</li>
<li>在命令中指定路径<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> navi --dir <span class="string">"/folder/with/cheats"</span></span></span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>cheatsheets(.cheats)文件编辑</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> % 表示文件中命令所属tag标签，多个用逗号分割</span></span><br><span class="line"><span class="meta">%</span><span class="bash"> git, code</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="comment">#表示注释, &lt;branch&gt; 表示需要收到输入的变量，如果不输入则使用 $ branch对应的值(git branch | awk '&#123;print $NF&#125;')</span></span></span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> &lt;branch&gt; 变量的默认值，&lt;branch&gt;不输入时使用 <span class="string">"git branch | awk '&#123;print <span class="variable">$NF</span>&#125;'"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> branch: git branch | awk <span class="string">'&#123;print $NF&#125;'</span></span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="开始使用navi"><a href="#开始使用navi" class="headerlink" title="开始使用navi"></a>开始使用navi</h3><ul>
<li><p>查看navi帮助文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> navi --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>查找命令并执行该命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> navi</span></span><br></pre></td></tr></table></figure>
<p>输入navi回车，进入navi中开始查找命令, 选择命令退出执行，如果想直接退出按下ESC。  </p>
</li>
<li><p>查找命令不执行只打印<br>如果不想执行命令，只想打印命令，使用–print参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> navi --<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure>
<p>一直想使用此模式，可以使用alias做个别名简化, 添加到 .bashrc或 .zshrc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">alias</span> navi=<span class="string">'navi --print'</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用在线文档<br>使用search命令从在线仓库下载对应cheatsheets</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> navi search &lt;cmd&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>navi查找模式中使用的是fzf的搜索语法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Token</th>
<th align="left">Match type</th>
<th align="left">Description</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">sbtrkt</td>
<td align="left">fuzzy-match</td>
<td align="left">Items that match sbtrkt</td>
<td align="left">模糊匹配</td>
</tr>
<tr>
<td align="left">‘wild</td>
<td align="left">exact-match (quoted)</td>
<td align="left">Items that include wild</td>
<td align="left">精准匹配</td>
</tr>
<tr>
<td align="left">^music</td>
<td align="left">prefix-exact-match</td>
<td align="left">Items that start with music</td>
<td align="left">前缀匹配</td>
</tr>
<tr>
<td align="left">.mp3$</td>
<td align="left">suffix-exact-match</td>
<td align="left">Items that end with .mp3</td>
<td align="left">结尾匹配</td>
</tr>
<tr>
<td align="left">!fire</td>
<td align="left">inverse-exact-match</td>
<td align="left">Items that do not include fire</td>
<td align="left">不包含</td>
</tr>
<tr>
<td align="left">!^music</td>
<td align="left">inverse-prefix-exact-match</td>
<td align="left">Items that do not start with music</td>
<td align="left">不包含开头</td>
</tr>
<tr>
<td align="left">!.mp3$</td>
<td align="left">inverse-suffix-exact-match</td>
<td align="left">Items that do not end with .mp3</td>
<td align="left">不包含结尾</td>
</tr>
</tbody></table>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p>navi官网<br><a href="https://github.com/denisidoro/navi" target="_blank" rel="noopener">https://github.com/denisidoro/navi</a></p>
<p>命令行提示工具 navi<br><a href="https://www.jianshu.com/p/dce764d2835e" target="_blank" rel="noopener">https://www.jianshu.com/p/dce764d2835e</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>00 前言</title>
    <url>/2020/01/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/00-%E5%89%8D%E8%A8%80/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>数据大爆炸时代，需要更好的根据处理这些大数据。<br>ElasticSearch 是一个分布式、可扩展、实时搜索和数据分析的引擎。<br>ElasticSearch两个功能：全文检索和结构化数据实时统计，具体内容：全文检索、结构化数据搜索、数据分析、<br>复杂的人类语言处理、地址位置和对象关系等。还会讨论如何建立模型、如何配置和监控集群。</p>
<a id="more"></a>

<h3 id="为什么写这本书"><a href="#为什么写这本书" class="headerlink" title="为什么写这本书"></a>为什么写这本书</h3><p>参考文档是教你如何使用这些功能，本书基于问题求解的方式：遇到什么问题？该怎么解决？如何对方案权衡取舍？从基础开始，循序渐进，理论结合实例进行解释。</p>
<h3 id="Elasticsearch-版本"><a href="#Elasticsearch-版本" class="headerlink" title="Elasticsearch 版本"></a>Elasticsearch 版本</h3><p>本书针对的是Elasticsearch 2.x。</p>
<h3 id="如何阅读这本书"><a href="#如何阅读这本书" class="headerlink" title="如何阅读这本书"></a>如何阅读这本书</h3><p>ES的成功是使复杂的事情变简单。搜索和分布式是比较复杂的，了解其内部原理能让你对ES理解更深刻。<br>本文介绍的深入的话题：集群内的原理、分布式文档存储、执行分布式检索和分片内部原理。</p>
<h3 id="本书导航"><a href="#本书导航" class="headerlink" title="本书导航"></a>本书导航</h3><ol>
<li>基础入门：管理索引和搜索操作，以及一些内部机制介绍。</li>
<li>深入搜索：深入了解搜索以及其高级特性。了解相关度评分是如果工作的。</li>
<li>处理人类语言：讲解ES处理人类语言的过程。</li>
<li>聚合：讨论数据的聚合分析</li>
<li>地理位置：介绍两种地理位置检索方式：经纬坐标点，地理形状</li>
<li>数据建模：如果通过数据建模表达实体之间的关系。</li>
<li>管理、监督和部署：讨论ES重要配置、监控点和如何诊断。</li>
</ol>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>02 基础入门 - 集群内的原来</title>
    <url>/2020/01/14/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/02-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E9%9B%86%E7%BE%A4%E5%86%85%E7%9A%84%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="集群内的原理"><a href="#集群内的原理" class="headerlink" title="集群内的原理"></a>集群内的原理</h3><p>ES集群主旨：</p>
<ol>
<li>随时可用</li>
<li>按需扩容</li>
</ol>
<p>集群两种扩容方式：</p>
<ol>
<li>垂直扩容(纵向扩容)：增强机器配置</li>
<li>水平扩容(横向扩容): 增加机器数量</li>
</ol>
<p>ES天生支持分布式，可管理多节点来提高扩容性和可用性</p>
<a id="more"></a>
<h3 id="空集群"><a href="#空集群" class="headerlink" title="空集群"></a>空集群</h3><p>节点：</p>
<blockquote>
<p>一个运行中的Elasticsearch实例称为一个节点</p>
</blockquote>
<p>集群:</p>
<blockquote>
<p>拥有相同集群名(cluster.name)的多个节点组成了一个集群，共同承担数据和负载的压力。</p>
</blockquote>
<p>节点有变动时集群怎么处理？</p>
<blockquote>
<p>当集群中有节点加入或移除时，集群会重新平均分布所有的数据。</p>
</blockquote>
<p>master节点</p>
<blockquote>
<p>集群中节点会选举出一个节点做为master节点，master节点负责管理集群级别的所有变更，例如：增加索引、删除索引、增加节点、删除节点等。master节点并不负责文档级别的变更和搜索等操作。</p>
</blockquote>
<p>节点平等</p>
<blockquote>
<ol>
<li>每个节点都可以成为master节点。</li>
<li>每个节点都可以接受外部请求，节点接到请求后把请求转发到存储数据的节点，数据节点处理完返回给该节点，该节点再返回给客户端。也是说每个节点都知道数据存储的位置。</li>
</ol>
</blockquote>
<h3 id="集群健康"><a href="#集群健康" class="headerlink" title="集群健康"></a>集群健康</h3><p>查询集群状态</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_cluster/health</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"cluster_name"</span>:          <span class="string">"elasticsearch"</span>,</span><br><span class="line">   <span class="attr">"status"</span>:                <span class="string">"green"</span>,</span><br><span class="line">   <span class="attr">"timed_out"</span>:             <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">"number_of_nodes"</span>:       <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"number_of_data_nodes"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"active_primary_shards"</span>: <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"active_shards"</span>:         <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"relocating_shards"</span>:     <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"initializing_shards"</span>:   <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"unassigned_shards"</span>:     <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>status状态值：</p>
<ol>
<li>green : 所有的主片和副片都运行正常</li>
<li>yellow : 所有的主片运行正常，有的副片都运行不正常</li>
<li>red : 有主片运行不正常</li>
</ol>
<h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><p>索引(名词) :</p>
<blockquote>
<p>保存相关数据的地方，是指向一个或多个物理分片的逻辑命名空间。</p>
</blockquote>
<p>分片</p>
<blockquote>
<ol>
<li>分片是一个底层的工作单元</li>
<li>一个分片就是一个Lucene实例，本身是一个完整的索引引擎</li>
<li>分片保存全部数据的一部分</li>
<li>文档被存储到分片中，但应用程序直接与索引交互，而不是与分片交互。</li>
<li>文档存储在分片内，分片又被分配到节点里，集群规模扩大或缩小时，ES会迁移节点中的分片是数据保持均衡</li>
<li>一个节点可以包含多个分片，也可以理解为：一个ES实例包含多个Lucene实例</li>
</ol>
</blockquote>
<p>分片：主分片(primary)、副本分片(replica)</p>
<blockquote>
<p>主分片 ：一个文档只能被保存到一个主分片中，索引建立时主分片数已经确定。<br>副本分片 : 副本分片只是主分片的拷贝，副本分片数可以随时修改。它的作用是：冗余备份和提供读操作<br>分片：主分片和副分片不能在一个节点上</p>
</blockquote>
<h3 id="添加故障转移"><a href="#添加故障转移" class="headerlink" title="添加故障转移"></a>添加故障转移</h3><p>单个节点时由于没有冗余的副本分片，所以存在单点故障。启动第二节点时会存储所有的副本分片，不存在单点故障问题了，集群状态会变为’green’</p>
<h3 id="水平扩容"><a href="#水平扩容" class="headerlink" title="水平扩容"></a>水平扩容</h3><p>分片配置如下：3个主分片，每个主分片对应一个1个副本分片，共3副分片</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"settings"</span> : &#123;</span><br><span class="line">		<span class="attr">"number_of_shards"</span> : <span class="number">3</span>,</span><br><span class="line">		<span class="attr">"number_of_replicas"</span> : <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3个主分片，3个副分片，分配图</p>
<ol>
<li>一个节点时，没有副本分片，状态为：yellow<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph Node1-master</span><br><span class="line">P1   </span><br><span class="line">P2</span><br><span class="line">P3</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>2个节点时，node2 拷贝所有的副本分片<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph Node2</span><br><span class="line">R1</span><br><span class="line">R2</span><br><span class="line">R3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph Node1-master</span><br><span class="line">P1</span><br><span class="line">P2</span><br><span class="line">P3</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>3个节点时，P1和R3重新分配到node3上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line"></span><br><span class="line">subgraph Node3</span><br><span class="line">P1</span><br><span class="line">R3</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph Node2</span><br><span class="line">R1</span><br><span class="line">R2</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph Node1-master</span><br><span class="line">P2</span><br><span class="line">P3</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>3个主分片和3个副分片最大节点数是6，如果节点大于6，可以通过调整副本分片数量来达到负责平衡，副本增加可以增加数据冗余量和系统吞吐量。</p>
<h3 id="应对故障"><a href="#应对故障" class="headerlink" title="应对故障"></a>应对故障</h3><p>3个节点，6个分片</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TB</span><br><span class="line">subgraph Node3</span><br><span class="line">P0(P0)</span><br><span class="line">R1(R1)</span><br><span class="line">R2(R2)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph Node2</span><br><span class="line">R0(R0)</span><br><span class="line">R11(R1)</span><br><span class="line">R22(R2)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph Node1-master</span><br><span class="line">R00(R0)</span><br><span class="line">P1(P1)</span><br><span class="line">P2(P2)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>应对故障步骤：</p>
<ol>
<li>节点1故障，节点1从集群中下线</li>
<li>失去主分片P1和P2，此时集群状态为red</li>
<li>马上节点2和节点3上R1、R2提升为主分片，集群状态变为yellow，集群对外正常提供服务</li>
<li>节点1回复正常，集群中分片重新调整，状态变为 green</li>
</ol>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>01 基础入门</title>
    <url>/2020/01/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BA%86%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="Elasticsearch-简介"><a href="#Elasticsearch-简介" class="headerlink" title="Elasticsearch 简介"></a>Elasticsearch 简介</h3><p>Elasticsearch 是一个实时的分布式搜索引擎。主要功能：全文检索、结构化搜索、分析以及这三功能的结合。<br>Elasticsearch 没有一个单独的组件是全新的，他革命性地把有用组件融合到一个单一的、一致的、实时的应用中.</p>
<a id="more"></a>

<h3 id="1-你知道，为了搜索"><a href="#1-你知道，为了搜索" class="headerlink" title="1. 你知道，为了搜索"></a>1. 你知道，为了搜索</h3><h4 id="1-1-Elasticsearch简介"><a href="#1-1-Elasticsearch简介" class="headerlink" title="1.1 Elasticsearch简介"></a>1.1 Elasticsearch简介</h4><p>Apache Lucene是当下最先进，高性能，全功能的搜索引擎库。<br>Elasticsearch 是一个开源搜索引擎，建立在Apache Lucene基础之上。<br>ES隐藏了Lucene的复杂性，对外提供统一的RESTful API，使得全文检索变得简单。<br>分布式特性:</p>
<ul>
<li>一个分布式的实时文档存储，每个字段都可以被索引和搜索</li>
<li>一个分布式的实时分析搜索引擎</li>
</ul>
<p>扩展性： 能胜任上百个服务节点的扩展，并支持PB级别的结构化或非结构化数据。</p>
<h4 id="1-2-安装并运行-Elasticsearch"><a href="#1-2-安装并运行-Elasticsearch" class="headerlink" title="1.2 安装并运行 Elasticsearch"></a>1.2 安装并运行 Elasticsearch</h4><ol>
<li>下载 <a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">Elasticsearch</a></li>
<li>系统上安装</li>
<li>启动ES ：./bin/elasticsearch， window是elasticsearch.bat</li>
<li>使用curl或浏览器访问 <a href="http://localhost:9200/?pretty" target="_blank" rel="noopener">http://localhost:9200/?pretty</a><br>返回报文:<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Tom Foster"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"2.1.0"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"72cd1f1a3eee09505e036106146dc1949dc5dc87"</span>,</span><br><span class="line">    <span class="attr">"build_timestamp"</span> : <span class="string">"2015-11-18T22:40:03Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"5.3.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>安装Kibana，新版kibana的devTool提供交互式控制台，通过浏览器向ES提交请求。<br><a href="http://localhost:5601/app/kibana#/dev_tools/console?_g=()" target="_blank" rel="noopener">http://localhost:5601/app/kibana#/dev_tools/console?_g=()</a></li>
</ol>
<h4 id="1-3-与Elasticsearch交互"><a href="#1-3-与Elasticsearch交互" class="headerlink" title="1.3 与Elasticsearch交互"></a>1.3 与Elasticsearch交互</h4><h5 id="1-3-1-java-api中的两个客户端："><a href="#1-3-1-java-api中的两个客户端：" class="headerlink" title="1.3.1 java api中的两个客户端："></a>1.3.1 java api中的两个客户端：</h5><ol>
<li>节点客户端 (node client)<br>节点客户端特点：<ul>
<li>在集群中</li>
<li>非数据节点，不保存数据只转发请求<br>如下图：N1就是节点客户端</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  n1((N1-非数据节点)) -- 通讯 --- n2((N2-数据节点))</span><br><span class="line">  --通讯--- n3((N3-数据节点))</span><br><span class="line">  --通讯--- n1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>传输客户端 (Transport client)<br>特点：<ul>
<li>不在集群中</li>
<li>可以把请求发送到远程集群中的一个节点上</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  tc[传输客户端] -- 发送请求 --- n1</span><br><span class="line">  subgraph 远程集群</span><br><span class="line">  n1((N1)) --- n2((N2))--- n3((N3)) ---n1</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-通过http访问RESTful-API"><a href="#1-3-2-通过http访问RESTful-API" class="headerlink" title="1.3.2 通过http访问RESTful API"></a>1.3.2 通过http访问RESTful API</h5><p>通过9200端口可以与ES进行http通讯。可以用多种客户端访问，各主流语言客户端，web浏览器，curl命令等。</p>
<h4 id="1-4-面向文档"><a href="#1-4-面向文档" class="headerlink" title="1.4 面向文档"></a>1.4 面向文档</h4><p>Elasticsearch 是面向文档的，使用JSON存储整个对象或文档。<br>ES不仅存储文档，而且还索引每个文档的内容，使之能被检索。<br>ES对文档进行索引、检索、排序和过滤的，与关系数据库的行列数据不同。</p>
<h4 id="1-5-适应新环境"><a href="#1-5-适应新环境" class="headerlink" title="1.5 适应新环境"></a>1.5 适应新环境</h4><p>通过雇员示例来介绍ES基本概念。</p>
<h4 id="1-6-索引员工文档"><a href="#1-6-索引员工文档" class="headerlink" title="1.6 索引员工文档"></a>1.6 索引员工文档</h4><p>一个集群可以包含多个索引，每个索引包含多个类型，每个类型包含多个文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  ES[ES集群] --&gt; i1[索引 Index01]</span><br><span class="line">  ES --&gt; i2[索引 Index02]</span><br><span class="line">  i1 --&gt; t1[类型 Type01]</span><br><span class="line">  i1 --&gt; t2[类型 Type02]</span><br><span class="line">  t1 --&gt; d1[文档 document01]</span><br><span class="line">  t1 --&gt; d2[文档 document02]</span><br></pre></td></tr></table></figure>

<p>  <strong>索引(index)</strong></p>
<ul>
<li><p>名词时 ：一个索引类似于关系型数据库中一个数据库，是存储关系型文档的地方。索引复数：indices 或 indexes</p>
</li>
<li><p>动词时： 索引一个文档就是存储一个文档到索引(名词)中以便被检索和查询。</p>
<p>创建员工信息</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /megacorp/employee/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"first_name"</span> : <span class="string">"John"</span>,</span><br><span class="line">    <span class="attr">"last_name"</span> :  <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="attr">"age"</span> :        <span class="number">25</span>,</span><br><span class="line">    <span class="attr">"about"</span> :      <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="attr">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>/megacorp/employee/1 包含了三部分的信息：<br>megacorp : 索引名称<br>employee : 类型名称<br>1 : 特定雇员的ID<br>请求体: JSON 文档 员工信息</p>
<h4 id="1-7-检索文档"><a href="#1-7-检索文档" class="headerlink" title="1.7 检索文档"></a>1.7 检索文档</h4><p>检索员工1信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/1</span><br></pre></td></tr></table></figure>
<p>删除员工1信息</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">delete /megacorp/employee/1</span><br></pre></td></tr></table></figure>

<h4 id="1-8-轻量搜索"><a href="#1-8-轻量搜索" class="headerlink" title="1.8 轻量搜索"></a>1.8 轻量搜索</h4><p>搜索所有员工</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br></pre></td></tr></table></figure>
<p>检索员工simth信息,使用了查询字符串(query-string) :  q=last_name:Smith</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search?q=Smith</span><br></pre></td></tr></table></figure>
<p>Query-string 搜索通过命令非常方便地进行临时性的即席搜索 ，但它有自身的局限性。</p>
<h4 id="1-9-使用查询表达式查询"><a href="#1-9-使用查询表达式查询" class="headerlink" title="1.9 使用查询表达式查询"></a>1.9 使用查询表达式查询</h4><p>ES提供了一个丰富灵活的查询语言叫 查询表达式，它支持更加复杂和健壮的查询。使用查询表达式重写之前的查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match"</span> : &#123;</span><br><span class="line">      <span class="attr">"last_name"</span> : <span class="string">"Smith"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-0-更复杂的查询"><a href="#2-0-更复杂的查询" class="headerlink" title="2.0 更复杂的查询"></a>2.0 更复杂的查询</h4><p>查询条件：名称Smith，年龄大于30。<br>使用：1. bool模型 2. match查询 3. range filter</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> :&#123;</span><br><span class="line">          <span class="attr">"last_name"</span> : <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"filter"</span> : &#123;</span><br><span class="line">        <span class="attr">"range"</span> : &#123;</span><br><span class="line">          <span class="attr">"age"</span> : &#123;</span><br><span class="line">            <span class="attr">"gt"</span> : <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-1-全文检索"><a href="#2-1-全文检索" class="headerlink" title="2.1 全文检索"></a>2.1 全文检索</h4><p>查询条件：所有喜欢攀岩(rock climbing)的员工.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match"</span> : &#123;</span><br><span class="line">      <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">结果有两条：1. 包含"rock climbing" 2. 包含 "rock"。</span><br><span class="line">原因是查询分词为'rock' 'climbing',匹配度最高的'rock climbing'在前，只包含'rock'在后。</span><br></pre></td></tr></table></figure>

<h4 id="2-2-短语查询"><a href="#2-2-短语查询" class="headerlink" title="2.2 短语查询"></a>2.2 短语查询</h4><p>使用match_phrase进行短语查询，只会返回一个包含’rock climbing’的结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">      <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-高亮查询"><a href="#2-3-高亮查询" class="headerlink" title="2.3 高亮查询"></a>2.3 高亮查询</h4><p>使用highlight表示需要高亮的字段。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match_phrase"</span> : &#123;</span><br><span class="line">      <span class="attr">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"highlight"</span> : &#123;</span><br><span class="line">    <span class="attr">"fields"</span> : &#123;</span><br><span class="line">      <span class="attr">"about"</span> : &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">返回结果中包含高亮：</span><br><span class="line">&#123; <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">     <span class="attr">"about"</span>: [</span><br><span class="line">        <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span></span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="2-4-分析"><a href="#2-4-分析" class="headerlink" title="2.4 分析"></a>2.4 分析</h4><p>利用ES中的聚合(aggregations)进行数据分析。</p>
<ol>
<li>分析员工最受欢迎的兴趣爱好.<br>新版ES需要设置fielddata=true</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacrop/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"aggs"</span> : &#123;</span><br><span class="line">		<span class="attr">"all_interests"</span> : &#123;</span><br><span class="line">			<span class="attr">"terms"</span> : &#123;</span><br><span class="line">				<span class="attr">"field"</span> : <span class="string">"interests"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>查询名称Smith的员工的最受欢迎的兴趣，先查询再聚合分析</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacrop/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match"</span> : &#123;</span><br><span class="line">      <span class="attr">"last_name"</span>: <span class="string">"smith"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">	<span class="attr">"aggs"</span> : &#123;</span><br><span class="line">		<span class="attr">"all_interests"</span> : &#123;</span><br><span class="line">			<span class="attr">"terms"</span> : &#123;</span><br><span class="line">				<span class="attr">"field"</span> : <span class="string">"interests"</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>聚合时进行汇总</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">    <span class="attr">"all_interests"</span> : &#123;</span><br><span class="line">      <span class="attr">"terms"</span> : &#123;<span class="attr">"field"</span> : <span class="string">"interests"</span>&#125;,</span><br><span class="line">      <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"avg_age"</span> : &#123;</span><br><span class="line">          <span class="attr">"avg"</span> : &#123;<span class="attr">"field"</span> : <span class="string">"age"</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="2-5-分布式特性"><a href="#2-5-分布式特性" class="headerlink" title="2.5 分布式特性"></a>2.5 分布式特性</h4><p>ES在后台做了大量工作尽可能地屏蔽分布式系统的复杂性，后台做的工作：</p>
<ol>
<li>分配文档到不同的容器或分片中，文档可以存储在一个或多个节点中</li>
<li>均衡分配分片，对索引和搜索过程进行负载均衡</li>
<li>复制每个分片以支持数据冗余，防止硬件故障导致的数据丢失</li>
<li>任意节点的请求都可以路由到相关数据的节点</li>
<li>集群扩容时无缝整合新节点，重新分配分片以便从离群节点恢复</li>
</ol>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03 基础入门-数据输入和输出</title>
    <url>/2020/01/16/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/03-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h3 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h3><p>Elasticsearch是分布式的文档存储系统，它能存储和检索复杂的数据结构(JSON)。<br>ES每个字段数据默认被索引，查询时使用倒排索引可以快速返回结果。<br>在本章中，我们展示了用来创建，检索，更新和删除文档的 API</p>
<a id="more"></a>
<h3 id="什么是文档？"><a href="#什么是文档？" class="headerlink" title="什么是文档？"></a>什么是文档？</h3><p>文档：是把最顶层或根对象序列号为JSON并存储到ES中，并指定唯一ID。</p>
<h3 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h3><p>文档元数据: 记录有关文档的信息。<br>必须的三个元数据：</p>
<ol>
<li><p>_index</p>
<blockquote>
<p>索引表示文档在那存放。索引是因有共同特性被分到一起的文档集合。<br>   一个索引是逻辑上的命名空间，这个命名空间由一个或多个分片组合在一起。<br>   索引命名：1. 名字小写 2. 不能以下划线开头 3. 不包含逗号</p>
</blockquote>
</li>
<li><p>_type</p>
<blockquote>
<p>type：类型，对索引进行逻辑区分，大部分字段相同，小部分字段不同的分为不同的type。<br>type命名 ：1. 大小写都可以 2.不能以下划线或句号开头 3. 不包含逗号</p>
</blockquote>
</li>
<li><p>_id</p>
<blockquote>
<ol>
<li>id是文档的唯一标识。</li>
<li>_index、_type 和ID唯一确定一个文档。</li>
<li>创建文档时可以指定id值，如果不指定ES会产生一个id。</li>
</ol>
</blockquote>
</li>
</ol>
<h3 id="索引文档"><a href="#索引文档" class="headerlink" title="索引文档"></a>索引文档</h3><p>索引文档格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /&#123;index&#125;/&#123;type&#125;/&#123;id&#125;</span><br></pre></td></tr></table></figure>
<p>手动指定id</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES自动生成id，使用POST请求，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/blog</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_index"</span>:    <span class="string">"website"</span>,</span><br><span class="line">   <span class="attr">"_type"</span>:     <span class="string">"blog"</span>,</span><br><span class="line">   <span class="attr">"_id"</span>:       <span class="string">"AVFgSgVHUP18jI2wRx0w"</span>,</span><br><span class="line">   <span class="attr">"_version"</span>:  <span class="number">1</span>,</span><br><span class="line">   <span class="attr">"created"</span>:   <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自动生成ID是是URL-safe、基于base64编码且长度为20的GUID字符串。</p>
<p><strong><em>_version</em></strong></p>
<blockquote>
<ol>
<li>version是使用乐观锁的方式解决并发冲突。</li>
<li>文档修改和删除时version会递增</li>
</ol>
</blockquote>
<h3 id="取回一个文档"><a href="#取回一个文档" class="headerlink" title="取回一个文档"></a>取回一个文档</h3><ol>
<li>获取一个文档所有信息<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123?pretty</span><br></pre></td></tr></table></figure></li>
<li>获取一个文档部分字段信息<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123?_source=title,text</span><br></pre></td></tr></table></figure></li>
<li>获取一个文档部分字段信息<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /website/blog/123/_source</span><br></pre></td></tr></table></figure>
<h3 id="检查文档是否存在"><a href="#检查文档是否存在" class="headerlink" title="检查文档是否存在"></a>检查文档是否存在</h3>使用Head 请求，通过响应返回码(200,404)判断文档是否存在。<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">HEAD /website/blog/123</span><br></pre></td></tr></table></figure>
<h3 id="更新整个文档"><a href="#更新整个文档" class="headerlink" title="更新整个文档"></a>更新整个文档</h3>新增和更新的请求结构相同，通过结果中的result可以知道新增还是更新。</li>
<li>新增<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"result": "created",</span><br></pre></td></tr></table></figure></li>
<li>更新<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"result": "updated",</span><br></pre></td></tr></table></figure>
由于ES中文档是不可变的，不能修改它们。这里的更新其实是删除后重建。<br>更新过程:  <blockquote>
<ol>
<li>从旧文档构建json</li>
<li>更改该json</li>
<li>删除旧文档</li>
<li>索引一个新文档</li>
</ol>
</blockquote>
</li>
</ol>
<p>删除的文档并不会马上消失，先标记为已删除，后续后台会清理这些已删除的文档。</p>
<h3 id="创建新文档"><a href="#创建新文档" class="headerlink" title="创建新文档"></a>创建新文档</h3><p>新建文档时如何知道正在新建一个文档，而不是覆盖已有的文档？<br>有2种方式：op_type和_create, 响应码：201:创建成功; 409 : 文档已存在</p>
<ol>
<li><p>op_type 指定类型</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/126?op_type=create</span><br></pre></td></tr></table></figure>
</li>
<li><p>_create 方式</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/126/_create</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /website/blog/127</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"_index"</span>: <span class="string">"website"</span>,</span><br><span class="line">    <span class="attr">"_type"</span>: <span class="string">"blog"</span>,</span><br><span class="line">    <span class="attr">"_id"</span>: <span class="string">"127"</span>,</span><br><span class="line">    <span class="attr">"_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">"result"</span>: <span class="string">"deleted"</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"_seq_no"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"_primary_term"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意结果：”result”: “deleted”, “_version”: 2</p>
<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><p>两种方法：</p>
<ol>
<li>悲观并发控制，使用悲观锁</li>
<li>乐观并发控制，使用乐观锁</li>
</ol>
<h3 id="乐观并发控制"><a href="#乐观并发控制" class="headerlink" title="乐观并发控制"></a>乐观并发控制</h3><p>使用_version实现乐观锁</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123?version=1</span><br></pre></td></tr></table></figure>

<p><strong>使用外部版本号数值</strong><br>版本号数值如果想使用外部指定值，增加参考：version_type=external<br>前提是外部版本号大于内部版本号，新建文档时可以指定外部版本号。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/123?version=25&amp;version_type=external</span><br></pre></td></tr></table></figure>

<h3 id="文档部分更新"><a href="#文档部分更新" class="headerlink" title="文档部分更新"></a>文档部分更新</h3><p><strong>全量更新用法：</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span> : &#123;</span><br><span class="line">      <span class="attr">"tags"</span> : [ <span class="string">"testing"</span> ],</span><br><span class="line">      <span class="attr">"views"</span>: <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>局部更新(partial update)用法</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"doc"</span> : &#123;</span><br><span class="line">      <span class="attr">"tags"</span> : [ <span class="string">"testing"</span> ],</span><br><span class="line">      <span class="attr">"views"</span>: <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h5><ol>
<li>内部先获取对应的document</li>
<li>将传递过来的字段更新到document的json中(全量：全量替换成新doc, 局部：与原数据进行合并成新doc)</li>
<li>将原doc标记为deleted</li>
<li>将新doc创建出来</li>
</ol>
<h5 id="区别和优点"><a href="#区别和优点" class="headerlink" title="区别和优点"></a>区别和优点</h5><ol>
<li>全量更新请求发生在分片外部，局部更新的操作发生在分片内部</li>
<li>全量更新会完全覆盖原文档，局部更新合并原文档，覆盖原字段，新增新字段</li>
<li>全量更新使用PUT或POST，局部更新使用POST</li>
</ol>
<h5 id="局部更新有点"><a href="#局部更新有点" class="headerlink" title="局部更新有点"></a>局部更新有点</h5><ol>
<li>局部更新所有操作(查询、修改、写回)都发生在ES分片内部(毫秒级瞬间完成)，避免了网络数据传输的开销，大大提升了性能</li>
<li>减少了查询和修改中的时间间隔，可以有效减少并发冲突。</li>
</ol>
<h5 id="局部更新的并发控制"><a href="#局部更新的并发控制" class="headerlink" title="局部更新的并发控制"></a>局部更新的并发控制</h5><p>局部更新内部使用版本进行并发控制。<br><strong>retry策略</strong><br>指定重试次数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/1/_update?retry_on_conflict=5</span><br></pre></td></tr></table></figure>
<p>指定某个版本重试次数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /website/blog/1/_update?retry_on_conflict=5&amp;version=3</span><br></pre></td></tr></table></figure>
<h5 id="使用内部脚本-painless-和外部脚本-Groovy"><a href="#使用内部脚本-painless-和外部脚本-Groovy" class="headerlink" title="使用内部脚本(painless)和外部脚本(Groovy)"></a>使用内部脚本(painless)和外部脚本(Groovy)</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/blog/123/_update</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"script"</span> : <span class="string">"ctx._source.views += 3"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/blog/123/_update</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"script"</span> : <span class="string">"ctx._source.views += num"</span>,</span><br><span class="line">  <span class="attr">"params"</span> : &#123;</span><br><span class="line">    <span class="attr">"num"</span> : <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/blog/123/_update</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"script"</span> : <span class="string">"ctx._source.views += 1"</span>,</span><br><span class="line">  <span class="attr">"upsert"</span> : &#123;</span><br><span class="line">    <span class="attr">"views"</span> : <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果字段不存在则使用upsert新增字段并设置默认.</p>
<p></p>
<h3 id="取回多个文档"><a href="#取回多个文档" class="headerlink" title="取回多个文档"></a>取回多个文档</h3><p>使用mget一次获取多个文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"docs"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> : <span class="string">"website"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> : <span class="string">"blog"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> : <span class="number">123</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_index"</span> : <span class="string">"website2"</span>,</span><br><span class="line">      <span class="attr">"_type"</span> : <span class="string">"pageview"</span>,</span><br><span class="line">      <span class="attr">"_id"</span> : <span class="number">1</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过索引和类型下时使用ids</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/blog/_mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"ids"</span> : [<span class="number">123</span>, <span class="number">124</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无论是否找到返回的状态码都是200，没找到时found标记为false</p>
<h3 id="代价较小的批量操作-bulk"><a href="#代价较小的批量操作-bulk" class="headerlink" title="代价较小的批量操作 bulk"></a>代价较小的批量操作 bulk</h3><p>bulk操作格式：<br>{ action : { metadata}}\n<br>{ request body}\n<br>各部分代表意思<br>action ：</p>
<blockquote>
<p>create- 创建文档，存在时报错<br>index - 不存在时创建，存在时全量更新,<br>update - 局部更新<br>delete - 删除</p>
</blockquote>
<p>metadata : 指定文档的 _index、_type和_id<br>requestbody : create、index和update时指定更新文档内容</p>
<p>例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span> : &#123;<span class="attr">"_index"</span> : <span class="string">"website"</span>, <span class="attr">"_type"</span> : <span class="string">"blog"</span>, <span class="attr">"_id"</span> : <span class="string">"125"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"create"</span> : &#123;<span class="attr">"_index"</span> : <span class="string">"website"</span>, <span class="attr">"_type"</span> : <span class="string">"blog"</span>, <span class="attr">"_id"</span> : <span class="string">"126"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"first_name"</span> : <span class="string">"Tom"</span>, <span class="attr">"last_name"</span> :  <span class="string">"Peter"</span>, <span class="attr">"title"</span> : <span class="string">"my blog 126"</span>&#125;</span><br><span class="line">&#123; <span class="attr">"index"</span> : &#123;<span class="attr">"_index"</span> : <span class="string">"website"</span>, <span class="attr">"_type"</span> : <span class="string">"blog"</span>, <span class="attr">"_id"</span> : <span class="string">"127"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"first_name"</span> : <span class="string">"Tony"</span>, <span class="attr">"last_name"</span> :  <span class="string">"Lee"</span>, <span class="attr">"title"</span> : <span class="string">"my blog 127"</span>&#125;</span><br><span class="line">&#123; <span class="attr">"update"</span> : &#123;<span class="attr">"_index"</span> : <span class="string">"website"</span>, <span class="attr">"_type"</span> : <span class="string">"blog"</span>, <span class="attr">"_id"</span> : <span class="string">"124"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123; <span class="attr">"views"</span> : <span class="number">10</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>请求路径中index和type可以被覆盖</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/blog/_bulk</span><br><span class="line">&#123; <span class="attr">"create"</span> : &#123;<span class="attr">"_id"</span> : <span class="string">"128"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"first_name"</span> : <span class="string">"Tom"</span>, <span class="attr">"last_name"</span> :  <span class="string">"Peter"</span>, <span class="attr">"title"</span> : <span class="string">"my blog 126"</span>&#125;</span><br><span class="line">&#123; <span class="attr">"index"</span> : &#123;<span class="attr">"_index"</span> : <span class="string">"website2"</span>, <span class="attr">"_type"</span> : <span class="string">"pageviews"</span>, <span class="attr">"_id"</span> : <span class="string">"5"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"first_name"</span> : <span class="string">"Tony"</span>, <span class="attr">"last_name"</span> :  <span class="string">"Lee"</span>, <span class="attr">"title"</span> : <span class="string">"my blog 127"</span>&#125;</span><br><span class="line">&#123; <span class="attr">"create"</span> : &#123;<span class="attr">"_index"</span> : <span class="string">"website3"</span>, <span class="attr">"_type"</span> : <span class="string">"article"</span>, <span class="attr">"_id"</span> : <span class="string">"1"</span> &#125; &#125;</span><br><span class="line">&#123; <span class="attr">"doc"</span> : &#123; <span class="attr">"views"</span> : <span class="number">0</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>bulk批量操作不是原子操作，其中一个报错不影响其他操作。如果操作中有失败时errors标记为true。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>04 基础入门-分布式文档存储</title>
    <url>/2020/01/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/04-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E6%A1%A3%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h3 id="分布式文档存储"><a href="#分布式文档存储" class="headerlink" title="分布式文档存储"></a>分布式文档存储</h3><p>此章节主要介绍文件是如果分布到集群的，又如何从集群中获取的。</p>
<a id="more"></a>
<h3 id="路由一个文档到一个分片"><a href="#路由一个文档到一个分片" class="headerlink" title="路由一个文档到一个分片"></a>路由一个文档到一个分片</h3><p>分片位置计算公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shard &#x3D; hash(routing) % number_of_primary_shards</span><br></pre></td></tr></table></figure>
<p>routing : 一个可变值，默认是_id,也可以自己指定。<br>hash函数 ： 生成一个数字<br>number_of_primary_shards : 主分片数量<br>公式计算后的结果值分布在[0, number_of_primary_shards-1],检索时也是使用这个公式。</p>
<h3 id="主分片和副本分片如何交互"><a href="#主分片和副本分片如何交互" class="headerlink" title="主分片和副本分片如何交互"></a>主分片和副本分片如何交互</h3><p>每个节点都有能力处理任何请求，每个节点都知道集群中任何文档的位置。<br>我们发送请求到集群中的任意节点，节点把请求转发需要的节点上。<br>接受请求的节点称为 协调节点(coordinating node)</p>
<h3 id="新建、索引和删除文档"><a href="#新建、索引和删除文档" class="headerlink" title="新建、索引和删除文档"></a>新建、索引和删除文档</h3><p>新建、索引和删除文档都是写操作。<br>背景：</p>
<blockquote>
<ol>
<li>3个节点，2个主分片，每个主分片对应2个副分片</li>
<li>请求id的最终目标分片是P0分片</li>
</ol>
</blockquote>
<p>写操作内部流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">q[request] -- 1.发送请求 --&gt; P1</span><br><span class="line">P1 --&gt; |2.转发请求| P0</span><br><span class="line">P0 --&gt; |3.P0处理完后转发到副本| r0</span><br><span class="line">P0 --&gt; |4.P0处理完后转发到副本| r00</span><br><span class="line">P1 --&gt; |5.返回结果| q</span><br><span class="line">subgraph cdoe</span><br><span class="line">  subgraph Node1-master</span><br><span class="line">    r00[R0]</span><br><span class="line">    P1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  subgraph Node2</span><br><span class="line">    r0[R0]</span><br><span class="line">    r11[R1]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  subgraph Node3</span><br><span class="line">    P0</span><br><span class="line">    r1[R1]</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>可选的请求参数，以数据安全为代价提升性能</p>
<h5 id="consistency-一致性"><a href="#consistency-一致性" class="headerlink" title="consistency 一致性"></a>consistency 一致性</h5><p>可选参数：one, all, quorum</p>
<ul>
<li>one : 主分片状态ok就允许执行</li>
<li>all : 所有的主分片和副本分片状态都没问题才允许执行</li>
<li>quorum : ES默认值，全部主分片和大多数副本分片状态ok就允许执行，计算公式：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">quorum = int ((primary主分片 + number_of_replicas副本分片数)/2) + 1</span><br><span class="line">number_of_replicas : 每个主分片对应副本分片数,即setting中设置的副本值</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="timeout-超时时间"><a href="#timeout-超时时间" class="headerlink" title="timeout 超时时间"></a>timeout 超时时间</h5><p>当不满足一致性要求时ES的等待超时时间。默认是1分钟。</p>
<h3 id="取回一个文档"><a href="#取回一个文档" class="headerlink" title="取回一个文档"></a>取回一个文档</h3><p>可以从主分片或副本分片检索文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">q[request] -- 1.发送请求 --&gt; P1</span><br><span class="line">P1 --&gt; |2.转发请求| r0</span><br><span class="line">r0 --&gt; |3.P0处理完后返回| P1</span><br><span class="line">P1 --&gt; |4.返回结果| q</span><br><span class="line">subgraph cdoe</span><br><span class="line">  subgraph Node1-master</span><br><span class="line">    r00[R0]</span><br><span class="line">    P1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  subgraph Node2</span><br><span class="line">    r0[R0]</span><br><span class="line">    r11[R1]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  subgraph Node3</span><br><span class="line">    P0</span><br><span class="line">    r1[R1]</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<ol>
<li>客户端发送请求到Node1上</li>
<li>根据节点_id确定文档在分片0上，轮询所有的副本分片后，请求转发到Node2</li>
<li>Node2处理完返回给Node1</li>
</ol>
<h3 id="局部更新文档-partial-update"><a href="#局部更新文档-partial-update" class="headerlink" title="局部更新文档 partial update"></a>局部更新文档 partial update</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">q[request] -- 1.发送请求 --&gt; P1</span><br><span class="line">P1 --&gt; |2.转发请求| P0</span><br><span class="line">P0 --&gt; |3.修改字段并重新索引主分片| P0</span><br><span class="line">P0 --&gt; |4.把新文档转发给副本| r0</span><br><span class="line">P0 --&gt; |5.把新文档转发给副本| r00</span><br><span class="line">P1 --&gt; |6.返回结果| q</span><br><span class="line">subgraph cdoe</span><br><span class="line">  subgraph Node1-master</span><br><span class="line">    r00[R0]</span><br><span class="line">    P1</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  subgraph Node2</span><br><span class="line">    r0[R0]</span><br><span class="line">    r11[R1]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  subgraph Node3</span><br><span class="line">    P0</span><br><span class="line">    r1[R1]</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<ol>
<li>客户端向Node1发送局部更新请求</li>
<li>Node1转发请求到主分片所在的Node3上</li>
<li>Node3主分片修改字段并重新索引文档</li>
<li>Node3把处理完的新文档转发给副本，副本都成功后，Node3向协调节点返回成功</li>
<li>协调节点向客户端返回成功</li>
</ol>
<p>注意：</p>
<blockquote>
<ol>
<li>主分片转发给副本分片的是新文档而不是跟新请求。</li>
<li>转发是异步的不能保证转发顺序和达到顺序相同</li>
</ol>
</blockquote>
<h3 id="多文档模式"><a href="#多文档模式" class="headerlink" title="多文档模式"></a>多文档模式</h3><p>bulk格式可以直接解析action/metadata,无需要解析requestbody，直接把bulk数据转发到主分片，不需要序列化为内部传输格式。<br>bulk的优势：解析速度快，占用内存小</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>05 基础入门-搜索-最基本的工具</title>
    <url>/2020/01/19/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/05-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%90%9C%E7%B4%A2-%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>ES存储功能：1. 存储文档 2. 为文档添加索引。<br>ES搜索功能：1. 全文检索 3. 结构化查询   </p>
<p>搜索相关的3个概念：<br><strong>映射(Mapping)</strong></p>
<blockquote>
<p>描述数据在字段内如果被存储。</p>
</blockquote>
<p><strong>分析(Analysis)</strong></p>
<blockquote>
<p>全文是如果处理使之能被搜索。</p>
</blockquote>
<p><strong>领域特定查询语言(Query DSL)</strong><br>ES中强大灵活的查询语</p>
<a id="more"></a>
<h3 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">返回：</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"hits"</span> : &#123;</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">14</span>,</span><br><span class="line">      <span class="attr">"hits"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"_index"</span>:   <span class="string">"us"</span>,</span><br><span class="line">          <span class="attr">"_type"</span>:    <span class="string">"tweet"</span>,</span><br><span class="line">          <span class="attr">"_id"</span>:      <span class="string">"7"</span>,</span><br><span class="line">          <span class="attr">"_score"</span>:   <span class="number">1</span>,</span><br><span class="line">          <span class="attr">"_source"</span>: &#123;</span><br><span class="line">             <span class="attr">"date"</span>:    <span class="string">"2014-09-17"</span>,</span><br><span class="line">             <span class="attr">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">             <span class="attr">"tweet"</span>:   <span class="string">"The Query DSL is really powerful and flexible"</span>,</span><br><span class="line">             <span class="attr">"user_id"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... <span class="number">9</span> RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"max_score"</span> :   <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"took"</span> :           <span class="number">4</span>,</span><br><span class="line">   <span class="attr">"_shards"</span> : &#123;</span><br><span class="line">      <span class="attr">"failed"</span> :      <span class="number">0</span>,</span><br><span class="line">      <span class="attr">"successful"</span> :  <span class="number">10</span>,</span><br><span class="line">      <span class="attr">"total"</span> :       <span class="number">10</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"timed_out"</span> :      <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个字段简介：<br>hits :</p>
<blockquote>
<p>hit是最重要部分，包含 total(匹配文档数)，_index,_type, _source(文档内容), _score(相关度分值), _max_score(最大分值)</p>
</blockquote>
<p>took：</p>
<blockquote>
<p>搜索花费的时间(毫秒)</p>
</blockquote>
<p>shards：</p>
<blockquote>
<p>分片信息，总分片数，成功分片数，失败分片数</p>
</blockquote>
<p>time_out:</p>
<blockquote>
<p>查询是否超时，默认没有指定超时时间，可以收到指定’/_search?timeout=10ms’<br>timeout 不是停止执行查询，而是告诉协调节点在timeout之前返回收集的结果并关闭连接。在后台可能还有查询再执行。</p>
</blockquote>
<h3 id="多索引-多类型"><a href="#多索引-多类型" class="headerlink" title="多索引 多类型"></a>多索引 多类型</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">/_search</span><br><span class="line">在所有的索引中搜索所有的类型</span><br><span class="line">/gb/_search</span><br><span class="line">在 gb 索引中搜索所有的类型</span><br><span class="line">/gb,us/_search</span><br><span class="line">在 gb 和 us 索引中搜索所有的文档</span><br><span class="line">/g*,u*/_search</span><br><span class="line">在任何以 g 或者 u 开头的索引中搜索所有的类型</span><br><span class="line">/gb/user/_search</span><br><span class="line">在 gb 索引中搜索 user 类型</span><br><span class="line">/gb,us/user,tweet/_search</span><br><span class="line">在 gb 和 us 索引中搜索 user 和 tweet 类型</span><br><span class="line">/_all/user,tweet/_search</span><br><span class="line">在所有的索引中搜索 user 和 tweet 类型</span><br></pre></td></tr></table></figure>
<p>请求单个索引和多个索引时过程是一样的，多索引时协调节点转发给多个索引。</p>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>分页参数：<br>size : 返回的结果数量，默认 10<br>from : 跳过的结果数量, 默认 0</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search?size=5</span><br><span class="line">GET /_search?size=5&amp;from=5</span><br><span class="line">GET /_search?size=5&amp;from=10</span><br></pre></td></tr></table></figure>
<p>分页过程（假设5个分片，size=10，from=0）：</p>
<ol>
<li>客户端向协调节点发送请求</li>
<li>协调节点转发给相关节点的分片,每个分片查询前10个结果</li>
<li>5个分片处理完结果返回给协调节点</li>
<li>协调节点收到50个结果，对50个结果集中排序，然后分页取出前10条，返回给客户端</li>
</ol>
<p>深度分页（deep page）<br>随着分页深度越深，每个分片查询的记录越多，协调节点集中排序的结果越多，性能越差。<br>例如：size=10，from=10000，分片数=5<br>==&gt; 每个分片需要查询10010个结果，协调节点处理50050个结果，取出10个结果，丢弃掉50040个结果</p>
<h3 id="轻量搜索"><a href="#轻量搜索" class="headerlink" title="轻量搜索"></a>轻量搜索</h3><p>两种搜索形式：</p>
<ol>
<li>查询字符串形式 ： 轻量的形式，在查询字符串中传递所有参数。</li>
<li>请求体形式 ： 使用JSON格式和更丰富的查询表达式作为搜索语言。</li>
</ol>
<h5 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h5><p>语法格式:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search?q=+name:john++tweet:mary+date:&gt;2014-09-10</span><br><span class="line">经过URL encode后：</span><br><span class="line">GET /_search?q=%2Bname:john+%3Atweet:mary</span><br></pre></td></tr></table></figure>
<blockquote>
<p>‘+’ : 必须与查询条件匹配<br>‘-‘ : 一定不与查询条件匹配</p>
</blockquote>
<p>优点 :</p>
<ol>
<li>可以用简洁语法表达复杂的查询</li>
<li>做一次性查询比较方便，适合开发阶段</li>
<li>缺点 :</li>
<li>经过URL编码后可读性比较差</li>
<li>调式比较困难</li>
<li>语法容易出错，很脆弱</li>
<li>允许然后用户在索引的任意字段上执行比较慢且重量级查询，会暴露隐私，甚至拖垮集群。</li>
</ol>
<p>根据以上特点不建议在生产环境使用查询字符串，建议使用功能更全面的 request body 查询。</p>
<h5 id="all字段"><a href="#all字段" class="headerlink" title="_all字段"></a>_all字段</h5><p>ES默认是有存储_all字段，ES把所有字段的值拼接成一个大的字符串做为’_all’字段进行索引. 如果不指定字段时就是搜索的’_all’字段。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>06 基础入门-映射和分析</title>
    <url>/2020/01/19/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/06-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%98%A0%E5%B0%84%E5%92%8C%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="映射和分析"><a href="#映射和分析" class="headerlink" title="映射和分析"></a>映射和分析</h3><p>映射设置方式：1. 手动设置映射 2. 动态生成映射</p>
<a id="more"></a>
<p>查看映射：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_mapping/tweet</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"gb"</span>: &#123;</span><br><span class="line">      <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">         <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">               <span class="attr">"date"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">                  <span class="attr">"format"</span>: <span class="string">"strict_date_optional_time||epoch_millis"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"name"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"user_id"</span>: &#123;</span><br><span class="line">                  <span class="attr">"type"</span>: <span class="string">"long"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES核心数据类型：string、numbers、Booleans和dates<br>索引方式：1. 全文 2. 精确值<br>不同数据类型索引方式不同，</p>
<h3 id="精确值-VS-全文"><a href="#精确值-VS-全文" class="headerlink" title="精确值 VS 全文"></a>精确值 VS 全文</h3><p>精确值 :</p>
<blockquote>
<p>所有数据类型都可以表示精确值。例如：Foo和foo不同，2014和2014-09 不同。<br>  搜索时精确值可以用匹配和不匹配表示。</p>
</blockquote>
<p>全文 :</p>
<blockquote>
<p>是指文本数据，例如一篇文章的内容.<br>搜索时全文用匹配程度表示。</p>
</blockquote>
<p>全文索引建立过程：</p>
<ol>
<li>分析文档</li>
<li>根据分析结果创建倒排索引</li>
</ol>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>概念：</p>
<blockquote>
<p>倒排索引文档中所有不重复的词的列表构成，每个词都有一个包含它的文档列表。<br>两个列表： 1. 词列表 2. 每个词对应一个文档列表</p>
</blockquote>
<p>分析：分词和标准化的过程。<br>分词 ： 提取全文中的词条(词项、tokens)<br>标准化：转化成小写，转化成词根，转化成同义词等。</p>
<h5 id="倒排索引示例"><a href="#倒排索引示例" class="headerlink" title="倒排索引示例"></a>倒排索引示例</h5><ul>
<li><p>两个文档content字段内容如下：</p>
<ol>
<li>The quick brown fox jumped over the lazy dog</li>
<li>Quick brown foxes leap over lazy dogs in summer</li>
</ol>
</li>
<li><p>提取词条：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Term</th>
<th align="left">Doc_1</th>
<th align="left">Doc_2</th>
<th align="left">标准化</th>
</tr>
</thead>
<tbody><tr>
<td align="left">brown</td>
<td align="left">X (brown)</td>
<td align="left">X (brown)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">dog</td>
<td align="left">X (dog)</td>
<td align="left">X (dogs)</td>
<td align="left">复数还原为词干</td>
</tr>
<tr>
<td align="left">fox</td>
<td align="left">X (fox)</td>
<td align="left">X (foxes)</td>
<td align="left">复数还原为词干</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left"></td>
<td align="left">X (in)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">jump</td>
<td align="left">X (jumped)</td>
<td align="left">X (leap)</td>
<td align="left">同义词</td>
</tr>
<tr>
<td align="left">lazy</td>
<td align="left">X (lazy)</td>
<td align="left">X (lazy)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">over</td>
<td align="left">X (over)</td>
<td align="left">X (over)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">quick</td>
<td align="left">X (quick)</td>
<td align="left">X (Quick)</td>
<td align="left">大写变小写</td>
</tr>
<tr>
<td align="left">summer</td>
<td align="left"></td>
<td align="left">X (summer)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">the</td>
<td align="left">X (the)</td>
<td align="left">X (the)</td>
<td align="left"></td>
</tr>
</tbody></table>
<ul>
<li>搜索 quick fox</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Term</th>
<th align="left">Doc_1</th>
<th align="left">Doc_2</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fox</td>
<td align="left">X (fox)</td>
<td align="left">X (foxes)</td>
</tr>
<tr>
<td align="left">quick</td>
<td align="left">X (quick)</td>
<td align="left">X (Quick)</td>
</tr>
<tr>
<td align="left">—</td>
<td align="left">—</td>
<td align="left">—</td>
</tr>
<tr>
<td align="left">Total</td>
<td align="left">2</td>
<td align="left">1</td>
</tr>
</tbody></table>
<h3 id="分析和分析器"><a href="#分析和分析器" class="headerlink" title="分析和分析器"></a>分析和分析器</h3><p>分析过程：</p>
<blockquote>
<ol>
<li>将文本分成独立的词条</li>
<li>将这些词条统一化为标准格式</li>
</ol>
</blockquote>
<p><strong>分析器包含的3个功能：</strong></p>
<ol>
<li><p>字符过滤器</p>
<blockquote>
<p>分词前整理字符串，比如 去掉HTML，&amp;转化为 and</p>
</blockquote>
</li>
<li><p>分词器</p>
<blockquote>
<p>分词器把字符串分为单个的词条。例如：遇到空格和标点时拆分成词条。</p>
</blockquote>
</li>
<li><p>Token过滤器</p>
<blockquote>
<p>词条按顺序通过每一个Token过滤器。这个过程可能会改变词条、删除词条、增加词条。<br>改变词条 : 例如：Quick 变小写<br>删除词条 : 例如：像a,and,the等无用词，删除掉<br>增加词条 : 例如 : jump 和leap这同义词</p>
</blockquote>
</li>
</ol>
<p><strong>内置分析器：</strong></p>
<ol>
<li>标准分析器 Standard analyzer</li>
<li>简单分析器 Simple analyzer</li>
<li>空格分析器 Whitespace analyzer</li>
<li>语言分析器 Language analyzer</li>
</ol>
<p><strong>什么时候使用分析器</strong></p>
<ol>
<li>索引文档时</li>
<li>全文检索时</li>
</ol>
<p><strong>测试分析器</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"analyzer"</span> : <span class="string">"standard"</span>,</span><br><span class="line">  <span class="attr">"text"</span> : <span class="string">"Text to analyzer"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"tokens"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"text"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">4</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"to"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">7</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>:        <span class="string">"analyze"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">8</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>:   <span class="number">15</span>,</span><br><span class="line">         <span class="attr">"type"</span>:         <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>:     <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>token : 存储在索引中的词条<br>position : 词条在原文中的序号<br>start_offset : 字符在原文中的其实位置<br>end_offset : 字符在原文中的结束位置</p>
<h5 id="指定分析器"><a href="#指定分析器" class="headerlink" title="指定分析器"></a>指定分析器</h5><p>对于全文的字符串，默认是标准分析器，也可以手动指定分析器。</p>
<h3 id="映射-mapping"><a href="#映射-mapping" class="headerlink" title="映射 mapping"></a>映射 mapping</h3><h5 id="关于映射"><a href="#关于映射" class="headerlink" title="关于映射"></a>关于映射</h5><p>每个文档都有类型，每个类型有自己的映射。<br>ES动态映射(dynamic mapping)和指定映射</p>
<h5 id="类型和动态映射"><a href="#类型和动态映射" class="headerlink" title="类型和动态映射"></a>类型和动态映射</h5><p>核心简单域类型：</p>
<ul>
<li>字符串 : string</li>
<li>整数 ：byte,short,integer,long</li>
<li>浮点数 ：double，float</li>
<li>布尔型 ： boolean</li>
<li>日期 ：date</li>
<li>ES 7.5 中的其他类型：text,keyword，ip, object,nested,geo_point,geo_shape,completion</li>
</ul>
<p>动态映射 dynamic mapping<br>| JSON type    | field type     |<br>| :—- | :—- |<br>|Boolean: true or false| boolean |<br>|whole number： 123| long |<br>|Floating point: 123.45 | double|<br>|String,valid date:2014-09-15 | date|<br>|String: foo bar  | string|<br>如果映射类型为整数或浮点数，传入的是字符串时会自动转换为整数或浮点数，如果无法转化则抛出一个异常。</p>
<h5 id="查看映射"><a href="#查看映射" class="headerlink" title="查看映射"></a>查看映射</h5><p>查看映射</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /gb/_mapping</span><br><span class="line">GET /gb/_mapping/tweet</span><br><span class="line">GET /gb/_mapping/field/name</span><br></pre></td></tr></table></figure>

<h5 id="自定义映射"><a href="#自定义映射" class="headerlink" title="自定义映射"></a>自定义映射</h5><p>为什么需要自定义映射？</p>
<blockquote>
<ol>
<li>全文字符串域和精确值的区别</li>
<li>指定特定语言分析器</li>
<li>优化域以适应部分匹配</li>
<li>指定自定义的数据格式</li>
<li>更多</li>
</ol>
</blockquote>
<p>指定映射类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /book</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span> : &#123;</span><br><span class="line">    <span class="attr">"school"</span> : &#123;</span><br><span class="line">      <span class="attr">"properties"</span> : &#123;</span><br><span class="line">        <span class="attr">"bookname"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"keyword"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"description"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"text"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span> : <span class="string">"standard"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"price"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"double"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"publish"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"date"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"comments"</span> : &#123;</span><br><span class="line">          <span class="attr">"type"</span> : <span class="string">"keyword"</span>,</span><br><span class="line">          <span class="attr">"index"</span> : <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>映射只能新增不能修改。</p>
<h3 id="复杂核心域类型"><a href="#复杂核心域类型" class="headerlink" title="复杂核心域类型"></a>复杂核心域类型</h3><h5 id="多值域使用数组表示"><a href="#多值域使用数组表示" class="headerlink" title="多值域使用数组表示"></a>多值域使用数组表示</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"tag"</span>: [ <span class="string">"search"</span>, <span class="string">"nosql"</span> ]&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<ol>
<li>数组内元素类型必须一致</li>
<li>数组内元素可以被索引，但是无序的，搜索时不指定数组元素的顺序</li>
</ol>
</blockquote>
<h5 id="空域"><a href="#空域" class="headerlink" title="空域"></a>空域</h5><p>lucene中不存在的空域，我们认为存在null值的为空域。<br>空域形式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"null_value":               null,</span><br><span class="line">"empty_array":              [],</span><br><span class="line">"array_with_null_value":    [ null ]</span><br></pre></td></tr></table></figure>

<h5 id="多层级对象-使用类型-object-表示"><a href="#多层级对象-使用类型-object-表示" class="headerlink" title="多层级对象 使用类型 object 表示"></a>多层级对象 使用类型 object 表示</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:            <span class="string">"Elasticsearch is very flexible"</span>,</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">        <span class="attr">"id"</span>:           <span class="string">"@johnsmith"</span>,</span><br><span class="line">        <span class="attr">"gender"</span>:       <span class="string">"male"</span>,</span><br><span class="line">        <span class="attr">"age"</span>:          <span class="number">26</span>,</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">            <span class="attr">"full"</span>:     <span class="string">"John Smith"</span>,</span><br><span class="line">            <span class="attr">"first"</span>:    <span class="string">"John"</span>,</span><br><span class="line">            <span class="attr">"last"</span>:     <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部对象的映射</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"gb"</span>: &#123;</span><br><span class="line">    <span class="attr">"tweet"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"tweet"</span>:            &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">        <span class="attr">"user"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:             <span class="string">"object"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"id"</span>:           &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">            <span class="attr">"gender"</span>:       &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">            <span class="attr">"age"</span>:          &#123; <span class="attr">"type"</span>: <span class="string">"long"</span>   &#125;,</span><br><span class="line">            <span class="attr">"name"</span>:   &#123;</span><br><span class="line">              <span class="attr">"type"</span>:         <span class="string">"object"</span>,</span><br><span class="line">              <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"full"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">                <span class="attr">"first"</span>:    &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;,</span><br><span class="line">                <span class="attr">"last"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"string"</span> &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="内部对象和数组如何索引"><a href="#内部对象和数组如何索引" class="headerlink" title="内部对象和数组如何索引"></a>内部对象和数组如何索引</h5><p>Lucene文档是有一组键值列表组成，无法理解内部对象。<br>ES内部对象转成如下形式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tweet"</span>:            [elasticsearch, flexible, very],</span><br><span class="line">    <span class="attr">"user.id"</span>:          [@johnsmith],</span><br><span class="line">    <span class="attr">"user.gender"</span>:      [male],</span><br><span class="line">    <span class="attr">"user.age"</span>:         [<span class="number">26</span>],</span><br><span class="line">    <span class="attr">"user.name.full"</span>:   [john, smith],</span><br><span class="line">    <span class="attr">"user.name.first"</span>:  [john],</span><br><span class="line">    <span class="attr">"user.name.last"</span>:   [smith]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>内部对象数组如何被索引的?<br>内部对象数组:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"followers"</span>: [</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">35</span>, <span class="attr">"name"</span>: <span class="string">"Mary White"</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">26</span>, <span class="attr">"name"</span>: <span class="string">"Alex Jones"</span>&#125;,</span><br><span class="line">        &#123; <span class="attr">"age"</span>: <span class="number">19</span>, <span class="attr">"name"</span>: <span class="string">"Lisa Smith"</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES把内部对象数组扁平化为下面形式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"followers.age"</span>:    [<span class="number">19</span>, <span class="number">26</span>, <span class="number">35</span>],</span><br><span class="line">    <span class="attr">"followers.name"</span>:   [alex, jones, lisa, smith, mary, white]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>07 基础入门-请求体查询</title>
    <url>/2020/01/20/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/07-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E8%AF%B7%E6%B1%82%E4%BD%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h3 id="请求体查询"><a href="#请求体查询" class="headerlink" title="请求体查询"></a>请求体查询</h3><p>两种查询：</p>
<ol>
<li>查询字符串查询(query-string search)</li>
<li>请求体查询(Full-Body Search)</li>
</ol>
<a id="more"></a>
<h3 id="空查询"><a href="#空查询" class="headerlink" title="空查询"></a>空查询</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_all/_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /us,gb/_search</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /us,gb/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"from"</span> : <span class="number">10</span>,</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match_all"</span> : &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h3><p>查询表达式(query DSL)是一种灵活又富有表现力的查询语言。<br>格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot; : YOUR_QUERY_HERE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>YOUR_QUERY_HERE可以是叶子语句(Leaf clauses)和复合(compound)语句.<br>叶子语句(Leaf clauses)</p>
<blockquote>
<p>叶子语句被用于查询一个或多个字段。例如：match语句，match_phrase，match_phrase_prefix,term,terms,match_all,multi_match等</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match"</span> : &#123;</span><br><span class="line">      <span class="attr">"tweet"</span> : <span class="string">"Elasticsearch"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复合(compound)语句：</p>
<blockquote>
<p>复合语句主要用于合并其他查询语句。<br>比例：bool语句允许组合其他语句：must、must_not、should，filter</p>
</blockquote>
<p>复合语句 ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> :   &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"tweet"</span>: <span class="string">"Elasticsearch"</span>&#125;&#125;,</span><br><span class="line">      <span class="attr">"must_not"</span> : &#123;<span class="attr">"match"</span>: &#123;<span class="attr">"name"</span> : <span class="string">"mary"</span>&#125;&#125;,</span><br><span class="line">      <span class="attr">"should"</span> : &#123; <span class="attr">"match"</span> : &#123;<span class="attr">"tweet"</span>: <span class="string">"full text"</span>&#125;&#125;,</span><br><span class="line">      <span class="attr">"filter"</span> : &#123; <span class="attr">"range"</span> : &#123;<span class="attr">"age"</span> :&#123;<span class="attr">"gt"</span> : <span class="number">30</span>&#125;&#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套的复合语句：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"must"</span> : &#123; <span class="attr">"match"</span> : &#123;<span class="attr">"email"</span> : <span class="string">"business opportunity"</span>&#125; &#125;,</span><br><span class="line">      <span class="attr">"should"</span> : [</span><br><span class="line">        &#123;<span class="attr">"match"</span> : &#123;<span class="attr">"email"</span> : <span class="string">"business opportunity"</span>&#125; &#125;,</span><br><span class="line">        &#123;<span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span>:      &#123;<span class="attr">"match"</span> : &#123;<span class="attr">"folder"</span> : <span class="string">"inbox"</span>&#125;&#125;,</span><br><span class="line">            <span class="attr">"must_not"</span> : &#123;<span class="attr">"match"</span> : &#123;<span class="attr">"spam"</span>: <span class="literal">true</span>&#125;&#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"minimum_should_match"</span> : <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询与过滤"><a href="#查询与过滤" class="headerlink" title="查询与过滤"></a>查询与过滤</h3><p>查询语言有一套查询组件，这套组件在两种情况下使用：</p>
<ol>
<li>过滤情况(filtering context)</li>
<li>查询情况(query context)</li>
</ol>
<p>过滤查询(filtering queries)</p>
<blockquote>
<p>过滤查询只需要知道是否匹配，不需要评分。<br>性能比较好，原因 ：</p>
<ol>
<li>由于过滤查询不评分，只简单检查是否匹配，所以计算非常快。</li>
<li>常用使用不评分查询时结果会被缓存到内存中以便快速读取。</li>
</ol>
</blockquote>
<p>评分查询(scoring queries)</p>
<blockquote>
<p>评分查询不仅需要找出匹配的文档，还要计算文档相关性，同时，结果并不缓存。所以没有过滤查询性能好。</p>
</blockquote>
<h5 id="如何选择查询和过滤？"><a href="#如何选择查询和过滤？" class="headerlink" title="如何选择查询和过滤？"></a>如何选择查询和过滤？</h5><p>使用查询(query)语句进行 全文搜索或任何需要影响相关性得分的搜索，其他情况都使用过滤(filter)</p>
<h3 id="最重要的查询"><a href="#最重要的查询" class="headerlink" title="最重要的查询"></a>最重要的查询</h3><h5 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h5><p>查询所有文档,没有指定查询方式时默认使用match_all</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match_all"</span> : &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="match-查询"><a href="#match-查询" class="headerlink" title="match 查询"></a>match 查询</h5><p>match查询既可以用于全文搜索，又可以用于精准查询。对于精准查询考虑替换为filter，filter会被缓存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"bool"</span> : &#123;</span><br><span class="line">			<span class="attr">"should"</span> : [</span><br><span class="line">				&#123;<span class="attr">"match"</span> : &#123;<span class="attr">"tweet"</span> : <span class="string">"About Search"</span>&#125; &#125;,</span><br><span class="line">				&#123;<span class="attr">"match"</span> : &#123;<span class="attr">"user_id"</span> : <span class="number">1</span>&#125; &#125;,</span><br><span class="line">				&#123;<span class="attr">"match"</span> : &#123;<span class="attr">"date"</span> : <span class="string">"2014-09-17"</span>&#125; &#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h5><p>multi_match查询可以在多个字段上执行相同的match</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"multi_match"</span> : &#123;</span><br><span class="line">			<span class="attr">"query"</span> :  <span class="string">"Elasticsearch Mary"</span>,</span><br><span class="line">			<span class="attr">"fields"</span> : [<span class="string">"tweet"</span>,<span class="string">"name"</span> ]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="range-查询"><a href="#range-查询" class="headerlink" title="range 查询"></a>range 查询</h5><p>range 查询那些落在在指定区间内的数字或时间</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">			<span class="attr">"filter"</span> : &#123;</span><br><span class="line">				<span class="attr">"range"</span> : &#123;</span><br><span class="line">					<span class="attr">"user_id"</span> : &#123;</span><br><span class="line">						<span class="attr">"gt"</span> : <span class="number">1</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作符：gt : 大于，gte : 大于等于, lt : 小于, lte : 小于等于</p>
<h5 id="term-查询"><a href="#term-查询" class="headerlink" title="term 查询"></a>term 查询</h5><p>term查询被用于精确值匹配，这些值可能是数字、时间、布尔或未分词的字符串。使用term查询字符串时不会对字符串进行分词。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"bool"</span> : &#123;</span><br><span class="line">			<span class="attr">"must"</span> : [</span><br><span class="line">				&#123;<span class="attr">"term"</span> : &#123;<span class="attr">"user_id"</span> : <span class="number">1</span>&#125; &#125;,</span><br><span class="line">				&#123;<span class="attr">"term"</span> : &#123;<span class="attr">"date"</span> : <span class="string">"2014-09-20"</span> &#125; &#125;</span><br><span class="line">			]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="terms查询"><a href="#terms查询" class="headerlink" title="terms查询"></a>terms查询</h5><p>与term查询一下，但terms查询允许字段使用数组指定多个值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"terms"</span> : &#123;<span class="attr">"date"</span> : [<span class="string">"2014-09-19"</span>,<span class="string">"2014-09-20"</span>] &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="exists查询和missing查询"><a href="#exists查询和missing查询" class="headerlink" title="exists查询和missing查询"></a>exists查询和missing查询</h5><p>查询字段中有值(exists)或无值(missing)的文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"terms"</span> : &#123;<span class="attr">"date"</span> : [<span class="string">"2014-09-19"</span>,<span class="string">"2014-09-20"</span>] &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组合多个查询"><a href="#组合多个查询" class="headerlink" title="组合多个查询"></a>组合多个查询</h4><p>使用bool组合多个查询。<br>操作符如下：<br>must : 文档<strong>必须匹配</strong>这些条件才能被包含进来。<br>must_not : 文档<strong>必须不匹配</strong>这些条件才能被包含进来<br>should : 满足任意语句会增加评分值，否则无影响。<br>filter : <strong>必须匹配</strong>，但它以不评分、过滤模式来进行。用来排除或包含文档不评分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>:   [ &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125; ],</span><br><span class="line">        <span class="attr">"filter"</span>:   &#123;</span><br><span class="line">          <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"how to make millions"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>:   <span class="string">"spam"</span> &#125;&#125;,</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"starred"</span> &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">              <span class="attr">"must"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"date"</span>: &#123; <span class="attr">"gte"</span>: <span class="string">"2014-01-01"</span> &#125;&#125;&#125;,</span><br><span class="line">                  &#123; <span class="attr">"range"</span>: &#123; <span class="attr">"price"</span>: &#123; <span class="attr">"lte"</span>: <span class="number">29.99</span> &#125;&#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"must_not"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"category"</span>: <span class="string">"ebooks"</span> &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="constant-score查询"><a href="#constant-score查询" class="headerlink" title="constant_score查询"></a>constant_score查询</h5><p>如果只执行filter时而没有其他查询时，使用constant_score查询。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_search</span><br><span class="line">&#123;</span><br><span class="line">	<span class="attr">"query"</span> : &#123;</span><br><span class="line">		<span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">			<span class="attr">"filter"</span> : &#123;</span><br><span class="line">				<span class="attr">"range"</span> : &#123;</span><br><span class="line">					<span class="attr">"date"</span> : &#123; <span class="attr">"gte"</span> : <span class="string">"2014-09-19"</span>&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="验证查询"><a href="#验证查询" class="headerlink" title="验证查询"></a>验证查询</h4><p>使用validate-query 来验证查询的合法性。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /gb/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"tweet"</span> : &#123;</span><br><span class="line">         <span class="attr">"match"</span> : <span class="string">"really powerful"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>explain 参数可以提供不合法的信息。每个索引都有自己的映射和分析器，所以每一个索引返回对应的explanation.</p>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>08 基础入门-排序与相关性</title>
    <url>/2020/03/05/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/08-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%8E%92%E5%BA%8F%E4%B8%8E%E7%9B%B8%E5%85%B3%E6%80%A7/</url>
    <content><![CDATA[<h3 id="排序与相关性"><a href="#排序与相关性" class="headerlink" title="排序与相关性"></a>排序与相关性</h3><p>默认情况 返回结果按照<strong>相关性</strong>进行排序—最相关的文档排在最前。</p>
<a id="more"></a>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用_score参数表示排序，默认降序。</p>
<h5 id="评分为零或不关心评分时"><a href="#评分为零或不关心评分时" class="headerlink" title="评分为零或不关心评分时"></a>评分为零或不关心评分时</h5><p>使用constant_score查询,将分值设为1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">      <span class="attr">"filter"</span> : &#123;</span><br><span class="line">        <span class="attr">"term"</span> : &#123;</span><br><span class="line">          <span class="attr">"user_id"</span> : <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用’sort’-按照字段排序"><a href="#使用’sort’-按照字段排序" class="headerlink" title="使用’sort’,按照字段排序"></a>使用’sort’,按照字段排序</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"filter"</span> : &#123;<span class="attr">"term"</span> : &#123;<span class="attr">"user_id"</span> : <span class="number">1</span>&#125;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span> : &#123; <span class="attr">"date"</span> : &#123;<span class="attr">"order"</span>: <span class="string">"desc"</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>选择排序后不会计算score值，如果想计算score值，可以设置track_scores为true。</li>
<li>排序只指定字段时，默认是降序，上例中可以简化为： “sort” : “date”.</li>
</ol>
<h5 id="sort-多级排序"><a href="#sort-多级排序" class="headerlink" title="sort 多级排序"></a>sort 多级排序</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"bool"</span> : &#123;</span><br><span class="line">            <span class="attr">"must"</span>:   &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"tweet"</span>: <span class="string">"manage text search"</span> &#125;&#125;,</span><br><span class="line">            <span class="attr">"filter"</span> : &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"user_id"</span> : <span class="number">2</span> &#125;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [</span><br><span class="line">        &#123; <span class="attr">"date"</span>:   &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"_score"</span>: &#123; <span class="attr">"order"</span>: <span class="string">"desc"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>第一排序字段是date，第二排序字段是_score</li>
<li>query-string形式：’GET /_search?sort=date:desc&amp;sort=_score&amp;q=search’</li>
</ol>
<h6 id="多值字段排序"><a href="#多值字段排序" class="headerlink" title="多值字段排序"></a>多值字段排序</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"sort" : &#123;</span><br><span class="line">  "dates" : &#123;</span><br><span class="line">    "order" : "asc",</span><br><span class="line">    "mode" : "min"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>数值和日期，可以通过聚合函数得出单一值，聚合函数包括: min,max,avg,sum</li>
</ol>
<h3 id="字符串排序和多字段"><a href="#字符串排序和多字段" class="headerlink" title="字符串排序和多字段"></a>字符串排序和多字段</h3><p>对于已经分词的字段进行排序时，映射时新增一个fields保留原值，利用原值进行排序。<br>mapping 配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"tweet": &#123;</span><br><span class="line">    "type":     "string",</span><br><span class="line">    "analyzer": "english",</span><br><span class="line">    "fields": &#123;</span><br><span class="line">        "raw": &#123;</span><br><span class="line">            "type":  "string",</span><br><span class="line">            "index": "not_analyzed"</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>tweet 仍是全文分词字段</li>
<li>新的tweet.raw 是一个非分词字段，可以对此字段进行排序</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"tweet"</span>: <span class="string">"elasticsearch"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: <span class="string">"tweet.raw"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="什么是相关性？"><a href="#什么是相关性？" class="headerlink" title="什么是相关性？"></a>什么是相关性？</h3><ol>
<li>_score 表示相关性评分的分值，分值越大相关性越高。</li>
<li>term: 关键词和内容的匹配百分比；fuzzy： 关键词和内容的拼写相似度。</li>
</ol>
<h5 id="相似度算法"><a href="#相似度算法" class="headerlink" title="相似度算法"></a>相似度算法</h5><p>TF/IDF算法：</p>
<ol>
<li>词频TF：检索词在字段出现的频率，频率越高，相关性越高</li>
<li>反向文档频率： 检索词在索引中出现的频率，频率越高，相关性越低。</li>
<li>字段长度准则：字段长度越长相关性越低。</li>
</ol>
<p>结合其他方式：</p>
<ol>
<li>短语查询中检索词的距离</li>
<li>模糊查询里的检索词相似度</li>
</ol>
<p>相关性也适用于yes|no子句，匹配的越多相关性越高。<br>多条查询子句时评分是各个查询子句的之和。</p>
<h5 id="理解评分标准"><a href="#理解评分标准" class="headerlink" title="理解评分标准"></a>理解评分标准</h5><ol>
<li>TF/IDF是在分片上计算的，不是在整个索引计算的</li>
<li>查询时添加explain查看打分情况.<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search?explain</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>   : &#123; <span class="attr">"match"</span> : &#123; <span class="attr">"tweet"</span> : <span class="string">"honeymoon"</span> &#125;&#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
返回的explain详情的评分结果，包含：TF（词频),IDF(反向文档频率)和字段长度准则(fieldNorm)          </li>
</ol>
<h6 id="理解文档是如何被匹配到的"><a href="#理解文档是如何被匹配到的" class="headerlink" title="理解文档是如何被匹配到的"></a>理解文档是如何被匹配到的</h6><h3 id="Doc-Values-介绍"><a href="#Doc-Values-介绍" class="headerlink" title="Doc Values 介绍"></a>Doc Values 介绍</h3><ol>
<li><p>为什么使用Doc Values？<br>ES的倒排索引为搜索而生，但排序和聚合不太适合，所以创建Doc Values，它排序和聚合速度比倒排索引快。</p>
</li>
<li><p>Doc Values 存储结构<br>Doc Values 是倒排索引的倒置结构，也是个列式存储结构。这样结构方便排序和聚合</p>
</li>
<li><p>Doc Values 存储时机？<br>索引创建时会创建倒排索引和Doc Values，默认分词字段不存储Doc Values，分词字段使用fieldData。</p>
</li>
<li><p>应用场景</p>
<ul>
<li>对一个字段进行排序</li>
<li>对一个字段进行聚合</li>
<li>某些过滤，比如地理位置过滤</li>
<li>某些与字段相关的脚本计算</li>
</ul>
</li>
<li><p>Doc Values 优势</p>
<ul>
<li>列式存储便于排序和聚合</li>
<li>Doc Values序列化到硬盘文件，可以根据需求加入内存，或从内存中移除</li>
</ul>
</li>
</ol>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>09 基础入门 - 执行分布式检索</title>
    <url>/2020/03/05/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/09-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E6%89%A7%E8%A1%8C%E5%88%86%E5%B8%83%E5%BC%8F%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="执行分布式检索"><a href="#执行分布式检索" class="headerlink" title="执行分布式检索"></a>执行分布式检索</h3><p>问题： 分布式环境中是怎么执行搜索的？<br>两个步骤：</p>
<ol>
<li>到所有相关的分片搜索结果</li>
<li>多分片的结果组合然后进行列表排序</li>
</ol>
<a id="more"></a>
<h3 id="查询阶段"><a href="#查询阶段" class="headerlink" title="查询阶段"></a>查询阶段</h3><p>概念：<br> 协调节点：请求发到哪个节点，该节点就变为协调节点</p>
<p>分布式查询过程：</p>
<ol>
<li>客户端发送查询请求到Node3，此时Node3变为协调节点，协调节点创建空的优先队列</li>
<li>协调节点Node3将查询请求转发到索引的每个分片上（主或副本分片），每个分片在本地执行查询，<br>把大小为from+size的结果放到本地的优先队列中。</li>
<li>每个分片把各自的优先队列中的结果返回给协调节点Node3，结果中包含文档Id和排序值，<br>Node3把所有结果放到自己的优先队列中产生一个全局的结果列表。</li>
</ol>
<h3 id="取回阶段"><a href="#取回阶段" class="headerlink" title="取回阶段"></a>取回阶段</h3><p>过程：</p>
<ol>
<li>协调节点Node3 辨别出那些文档需要被取回，并向相关分片提交多个GET请求</li>
<li>每个分片加载并丰富文档，返回文档给协调节点</li>
<li>等所有的文档都被取回后，协调节点返回结果给客户端</li>
</ol>
<p>深分页 (Deep Pagination)<br>查询{“from”:90,”size”:10}时，每个分片都需要查询100条记录返回给协调节点，<br>协调节点把所有结果排序后取出序号为[90,99]的记录，其他记录全部抛弃。<br>如果分页深度很大时，分片和协调节点排序变得很沉重，因为使用大量cpu、内存和带宽。<br>当需要取回大量文档时，可以使用scroll查询禁用排序，这样可以避免深分页问题。</p>
<h3 id="搜索选项"><a href="#搜索选项" class="headerlink" title="搜索选项"></a>搜索选项</h3><p>影响搜索的几个参数：perference(偏好)，timeout(超时)，routing(路由)</p>
<h5 id="perference-偏好"><a href="#perference-偏好" class="headerlink" title="perference(偏好)"></a>perference(偏好)</h5><p>preference 可以控制由那些分片或节点来处理搜索请求。<br>常用参数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_primary, _primary_first, _local, _only_node:xyz, _prefer_node:xyz, 和 _shards:2,3</span><br></pre></td></tr></table></figure>
<p>最有用的值是某些随机字符串，它可以避免Bouncing result问题(两次查询结果不同)。<br>(问题产生的原因：假如两个文档的字段A，它的值相同，如果每次查询跳到不同的分片上，会导致每次字段A的排序结果不同。<br>  要让用户每次查询都发到固定的分片上就可以保证每次查询结果都相同)</p>
<h5 id="timeout-超时"><a href="#timeout-超时" class="headerlink" title="timeout(超时)"></a>timeout(超时)</h5><p>一次查询的时间 = 查询最慢的分片时间 + 协调节点处理时间<br>timeout 设置了分片的最大时间，如果超时就返回部分或空结果。<br>超时检查是基于每个文档做的。</p>
<h5 id="routing-路由"><a href="#routing-路由" class="headerlink" title="routing(路由)"></a>routing(路由)</h5><p>路由是把请求路由到特定的分片中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_search?routing&#x3D;user_1,user2</span><br></pre></td></tr></table></figure>

<h5 id="搜索类型"><a href="#搜索类型" class="headerlink" title="搜索类型"></a>搜索类型</h5><p>缺省搜索类型 query_then_fetch<br>某些情况下明确使用dfs_query_then_fetch来改善相关性精确度</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search?search_type=dfs_query_then_fetch</span><br></pre></td></tr></table></figure>

<p>搜索类型 dfs_query_then_fetch 有预查询阶段，这个阶段可以从所有相关分片获取词频来计算全局词频。</p>
<h3 id="游标查询-scroll"><a href="#游标查询-scroll" class="headerlink" title="游标查询 scroll"></a>游标查询 scroll</h3><p>游标查询用来进行大批量文档查询。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123; <span class="attr">"match_all"</span>: &#123;&#125;&#125;,</span><br><span class="line">    <span class="attr">"sort"</span> : [<span class="string">"_doc"</span>],</span><br><span class="line">    <span class="attr">"size"</span>:  <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>scroll 查询取的是某个时间点的快照数据</li>
<li>scroll查询数据使用’_doc’排序</li>
<li>scroll需要设置过期时间，过期时间会在每次做查询的时候刷新</li>
<li>再次scroll查询时传入参数：过期时间和scroll_id</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search/scroll</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scroll"</span>: <span class="string">"1m"</span>,</span><br><span class="line">    <span class="attr">"scroll_id"</span> : <span class="string">"cXVlcnlUaGVuRmV0Y2g7NTsxMDk5NDpkUmpiR2FjOFNhNnlCM1ZDMWpWYnRROzEwOTk1OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MTA5OTM6ZFJqYkdhYzhTYTZ5QjNWQzFqVmJ0UTsxMTE5MDpBVUtwN2lxc1FLZV8yRGVjWlI2QUVBOzEwOTk2OmRSamJHYWM4U2E2eUIzVkMxalZidFE7MDs="</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>10 基础入门-索引管理</title>
    <url>/2020/03/05/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/10-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><p>优化索引和搜索过程，定制索引和类型</p>
<a id="more"></a>

<h3 id="创建一个索引"><a href="#创建一个索引" class="headerlink" title="创建一个索引"></a>创建一个索引</h3><p>手动建立索引，配置索引分片，分析器和映射。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  "settings": &#123;... any settings ...  &#125;,</span><br><span class="line">  "mappings" : &#123;</span><br><span class="line">    "type_one" : &#123;... any mappings ...&#125;,</span><br><span class="line">    "type_two" : &#123;... any mappings ...&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>禁止自动创建索引，修改配置文件 config/elasticsearch.yml<br>action.auto_create_index: false</p>
<h3 id="删除一个或多个索引"><a href="#删除一个或多个索引" class="headerlink" title="删除一个或多个索引"></a>删除一个或多个索引</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line">DELETE /index_one,index_two</span><br><span class="line">DELETE /index_*</span><br></pre></td></tr></table></figure>

<p>删除全部索引</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /_all</span><br><span class="line">DELETE /*</span><br></pre></td></tr></table></figure>

<h3 id="索引配置"><a href="#索引配置" class="headerlink" title="索引配置"></a>索引配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_temp_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span> :   <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"number_of_replicas"</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>number_of_shards : 主分片数，默认值是5，配置后不能修改<br>number_of_replicas: 每个主分片的副本数，默认值是1，这个配置可以修改。</p>
<p>修改副本数量：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_temp_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"number_of_replicas"</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置分析器analysis"><a href="#配置分析器analysis" class="headerlink" title="配置分析器analysis"></a>配置分析器analysis</h3><p>standard分析器,系统默认分析器，适合大部分西方语系：</p>
<ul>
<li>standard 分词器，通过单词边界分割输入的文本。</li>
<li>standard 语汇单元过滤器，目的是整理分词器触发的语汇单元</li>
<li>lowercase 语汇单元过滤器，转换所有的语汇单元为小写。</li>
<li>stop 语汇单元过滤器，删除停用词—​对搜索相关性影响不大的常用词，如 a,the,and,is。</li>
</ul>
<p>启用停用词过滤器，创建新的分析器并预定义停用词</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /spanish_docs</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span> : &#123;</span><br><span class="line">    <span class="attr">"analysis"</span> : &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"es_std"</span>:  &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"stopwords"</span>: <span class="string">"_spanish_"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /spanish_docs/_analyze?analyzer=es_std</span><br><span class="line">El veloz zorro marrón</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">    &#123; <span class="attr">"token"</span> :    <span class="string">"veloz"</span>,   <span class="attr">"position"</span> : <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"token"</span> :    <span class="string">"zorro"</span>,   <span class="attr">"position"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">"token"</span> :    <span class="string">"marrón"</span>,  <span class="attr">"position"</span> : <span class="number">4</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义分析器"><a href="#自定义分析器" class="headerlink" title="自定义分析器"></a>自定义分析器</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            "char_filter": &#123; ... custom character filters ... &#125;,</span><br><span class="line">            "tokenizer":   &#123; ...    custom tokenizers     ... &#125;,</span><br><span class="line">            "filter":      &#123; ...   custom token filters   ... &#125;,</span><br><span class="line">            "analyzer":    &#123; ...    custom analyzers      ... &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析器中执行顺序依次是：字符过滤器、分词器、词汇单元过滤器，3个自由组合创建自定义的分析器。</p>
<ul>
<li>字符过滤器(char filter)，在分词之前，处理内容中的特殊字符（清除字符，zif转换），可以有0个或多个字符过滤器。</li>
<li>分词器(tokenizer)，一个分析器只能有一个分词器，分词器把字符串分解成单个词条或词汇单元。</li>
<li>词汇单元过滤器(token filter)，分词后词单元流按指定顺序通过词单元过滤器，过滤器可以修改，添加或移除词单元。</li>
</ul>
<p>完整自定义</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"&amp;_to_and"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:       <span class="string">"mapping"</span>,</span><br><span class="line">                    <span class="attr">"mappings"</span>: [ <span class="string">"&amp;=&gt; and "</span>]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_stopwords"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:       <span class="string">"stop"</span>,</span><br><span class="line">                    <span class="attr">"stopwords"</span>: [ <span class="string">"the"</span>, <span class="string">"a"</span> ]</span><br><span class="line">            &#125;&#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:         <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>:  [ <span class="string">"html_strip"</span>, <span class="string">"&amp;_to_and"</span> ],</span><br><span class="line">                    <span class="attr">"tokenizer"</span>:    <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"filter"</span>:       [ <span class="string">"lowercase"</span>, <span class="string">"my_stopwords"</span> ]</span><br><span class="line">            &#125;&#125;</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 analyze API来测试my_analyzer</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_analyzer</span><br><span class="line">The quick &amp; brown fox</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tokens"</span> : [</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"quick"</span>,    <span class="attr">"position"</span> : <span class="number">2</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"and"</span>,      <span class="attr">"position"</span> : <span class="number">3</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"brown"</span>,    <span class="attr">"position"</span> : <span class="number">4</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">"token"</span> :   <span class="string">"fox"</span>,      <span class="attr">"position"</span> : <span class="number">5</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型和映射"><a href="#类型和映射" class="headerlink" title="类型和映射"></a>类型和映射</h3><p>类型： 一类相似的文档，类型由名称和映射组成<br>映射： 映射就是数据库的schema,描述字段或属性以及字段的数据类型，例如 string，integer,date等</p>
<h5 id="Lucene-如何处理文档"><a href="#Lucene-如何处理文档" class="headerlink" title="Lucene 如何处理文档"></a>Lucene 如何处理文档</h5><p>Lucene中一个文档有一组简单的键值对组成，一个字段可以有多个值，这些值没有具体类型。<br>索引文档时字段的值被添加到倒排索引中。</p>
<h5 id="类型是如何实现的"><a href="#类型是如何实现的" class="headerlink" title="类型是如何实现的"></a>类型是如何实现的</h5><ol>
<li>Elasticsearch类型是以Lucene处理文档的方式为基础实现的。</li>
<li>Lucene中没有类型概念，ES在每个文档的_type元数据中存储类型名，检索类型时通过_type进行过滤限制。</li>
<li>Lucene中也没有映射概念，ES将复杂的JSON文档映射为Lucene扁平化的数据结构。</li>
</ol>
<h5 id="避免类型陷阱"><a href="#避免类型陷阱" class="headerlink" title="避免类型陷阱"></a>避免类型陷阱</h5><p>陷阱： 两个类型中不能定义相同名称的字段</p>
<ol>
<li>每个 Lucene 索引中的所有字段都包含一个单一的、扁平的模式。一个特定字段可以映射成 string或number，但是不能两者兼具。</li>
<li>两个不同类型中的字段，映射到Lucene中一个索引中，没有类型区分。</li>
</ol>
<h5 id="类型结论"><a href="#类型结论" class="headerlink" title="类型结论"></a>类型结论</h5><ol>
<li>一个索引中可以有两个类型，但两个类型中不能有相同名称的字段，否则会有字段冲突。</li>
<li>一个索引中定义两个或多个类型时，大部分字段都相同，只有部分字段不同。</li>
<li>如果两个类型字段完全不同，这时最好使用两个索引，因为字段互不相同时索引中一半数据是空的(稀疏)，最终导致性能问题</li>
</ol>
<h3 id="根对象"><a href="#根对象" class="headerlink" title="根对象"></a>根对象</h3><p>根对象包含内容：</p>
<ul>
<li>properties节点，包含字段的映射</li>
<li>各种元数据，以下划线开头，例如:_type,_id,_source</li>
<li>设置项，控制如何动态处理新字段，例如：analyzer、dynamic_date_formats和dynamic_templates</li>
<li>其他设置，可以应该到根对象和其他object类型上，例如：enabled,dynamic和include_in_all</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><ul>
<li>type 字段的数据类型</li>
<li>index 值包含：analyzed(分词会索引)，not_analyzed(keyword)，no(不被搜索)</li>
<li>analyzer 使用的分析器</li>
</ul>
<h5 id="元数据：-source字段"><a href="#元数据：-source字段" class="headerlink" title="元数据：_source字段"></a>元数据：_source字段</h5><p>_source字段 代表文档体的json字符串，包含所有我们想要的。</p>
<p>如果不需source时使用禁用命令</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">            <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                <span class="attr">"enabled"</span>:  <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询时指定返回的字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>:   &#123; <span class="attr">"match_all"</span>: &#123;&#125;&#125;,</span><br><span class="line">    <span class="attr">"_source"</span>: [ <span class="string">"title"</span>, <span class="string">"created"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="元数据：-all-字段"><a href="#元数据：-all-字段" class="headerlink" title="元数据：_all 字段"></a>元数据：_all 字段</h5><ul>
<li>_all :把其他字段当做一个大字符串来索引的特殊字符。</li>
<li>_all是应急情况使用，快速查找想了解的索引信息。</li>
<li>_all 记录其他字段所有字符串，all字段指定的分词器会对all字段进行分词。</li>
<li>禁用某索引的all字段。</li>
<li>配置字段中的include_in_all属性，指定该字段是否加入all字段。</li>
</ul>
<p>query-string查询all</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search?q=tom</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"_all"</span>: <span class="string">"john smith marketing"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>禁止索引中的all</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">        <span class="attr">"_all"</span>: &#123; <span class="attr">"enabled"</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过include_in_all配置字段中的加入’_all‘字段中,默认值是true</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">        <span class="attr">"include_in_all"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"include_in_all"</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="元数据：文档标识"><a href="#元数据：文档标识" class="headerlink" title="元数据：文档标识"></a>元数据：文档标识</h5><p>4个相关字段：</p>
<ul>
<li>_id 文档的id，既没有被索引也没被存储，不是真实存在的。</li>
<li>_type 文档的类型名，被索引但没被存储。</li>
<li>_index 文档所在的索引，既没有被索引也没被存储，不是真实存在的。</li>
<li>_uid _type和_id连接在一起构造成type#id，被索引(可搜索)和被存储(可取回)。   </li>
</ul>
<p>_id可以像真实字段一样查询,ES使用_uid字段来派生出_id</p>
<h3 id="动态映射-dynamic-mapping"><a href="#动态映射-dynamic-mapping" class="headerlink" title="动态映射 dynamic mapping"></a>动态映射 dynamic mapping</h3><ul>
<li>动态映射: 遇到新字段时动态映射会确定字段类型并添加字段的类型映射。</li>
<li>用dynamic来配置是否需要动态映射</li>
<li>dynamic 使用：<ol>
<li>在根object或任何object类型上设置</li>
<li>指定某些字段使用dynamic: 先设置默认值，再定义某些字段启用</li>
</ol>
</li>
<li>dynamic可选值：<ol>
<li>true ： 动态添加新字段，默认值</li>
<li>false ： 忽略新字段，字段会被存储但不会被搜索。</li>
<li>strict : 如果遇到新字段抛出异常</li>
</ol>
</li>
</ul>
<p>部分字段启用dynamic</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">            <span class="attr">"dynamic"</span>:      <span class="string">"strict"</span>,</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>:  &#123; <span class="attr">"type"</span>: <span class="string">"string"</span>&#125;,</span><br><span class="line">                <span class="attr">"stash"</span>:  &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"object"</span>,</span><br><span class="line">                    <span class="attr">"dynamic"</span>:  <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义动态映射"><a href="#自定义动态映射" class="headerlink" title="自定义动态映射"></a>自定义动态映射</h3><h5 id="日期检测"><a href="#日期检测" class="headerlink" title="日期检测"></a>日期检测</h5><p>在动态映射情况下日期检查有异常情况，当然可以禁止进行日期检测。<br>日期检测规则可以通过<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/dynamic-field-mapping.html#date-detection" target="_blank" rel="noopener">dynamic_date_formats setting</a>设置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">            <span class="attr">"date_detection"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="动态模板-dynamic-templates"><a href="#动态模板-dynamic-templates" class="headerlink" title="动态模板 dynamic_templates"></a>动态模板 dynamic_templates</h5><p>动态模板组成部分</p>
<ul>
<li>模板名称</li>
<li>匹配规则</li>
<li>匹配类型</li>
<li>映射mapping</li>
</ul>
<p>动态模板配置：</p>
<ul>
<li>‘es’模板匹配字段名以 _es 结尾的字段。</li>
<li>‘en’模板匹配其他所有字符串类型字段。</li>
<li>‘match’ 只匹配名称</li>
<li>‘path_match’匹配对象上的完整路径 <code>address.*.name</code></li>
<li>unmatch和path_unmatch用于未被匹配的字段。</li>
</ul>
<p>更多配置(动态映射文档)[<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/dynamic-mapping.html]" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/reference/5.6/dynamic-mapping.html]</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">            <span class="attr">"dynamic_templates"</span>: [</span><br><span class="line">                &#123; <span class="attr">"es"</span>: &#123;</span><br><span class="line">                      <span class="attr">"match"</span>:              <span class="string">"*_es"</span>,</span><br><span class="line">                      <span class="attr">"match_mapping_type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                      <span class="attr">"mapping"</span>: &#123;</span><br><span class="line">                          <span class="attr">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                          <span class="attr">"analyzer"</span>:       <span class="string">"spanish"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">"en"</span>: &#123;</span><br><span class="line">                      <span class="attr">"match"</span>:              <span class="string">"*"</span>,</span><br><span class="line">                      <span class="attr">"match_mapping_type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                      <span class="attr">"mapping"</span>: &#123;</span><br><span class="line">                          <span class="attr">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">                          <span class="attr">"analyzer"</span>:       <span class="string">"english"</span></span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>#####<br>#####</p>
<h3 id="缺省映射"><a href="#缺省映射" class="headerlink" title="缺省映射"></a>缺省映射</h3><p>在索引中通过<code>_default_</code>指定所有字段的默认设置，字段可以重新设置以覆盖<code>_default_</code>中设置。<br>_default_ 映射也是一个指定索引 dynamic templates 的好方法。</p>
<p>例如，我们可以使用 <code>_default_</code> 映射为所有的类型禁用 <code>_all</code> 字段， 而只在 blog 类型启用：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"_default_"</span>: &#123;</span><br><span class="line">            <span class="attr">"_all"</span>: &#123; <span class="attr">"enabled"</span>:  <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"blog"</span>: &#123;</span><br><span class="line">            <span class="attr">"_all"</span>: &#123; <span class="attr">"enabled"</span>:  <span class="literal">true</span>  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="重新索引你的数据"><a href="#重新索引你的数据" class="headerlink" title="重新索引你的数据"></a>重新索引你的数据</h3><p>重建索引的两种方式：</p>
<ol>
<li>通过scroll查询大量文档，然后通过bulk api批量插入新索引中</li>
<li>ES2.3后引入的 Reindex api,参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/docs-reindex.html" target="_blank" rel="noopener">Reindex api</a></li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /old_index/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">            <span class="attr">"date"</span>: &#123;</span><br><span class="line">                <span class="attr">"gte"</span>:  <span class="string">"2014-01-01"</span>,</span><br><span class="line">                <span class="attr">"lt"</span>:   <span class="string">"2014-02-01"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"sort"</span>: [<span class="string">"_doc"</span>],</span><br><span class="line">    <span class="attr">"size"</span>:  <span class="number">1000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reindex 操作：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"source"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"twitter"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dest"</span>: &#123;</span><br><span class="line">    <span class="attr">"index"</span>: <span class="string">"new_twitter"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引别名和零停机"><a href="#索引别名和零停机" class="headerlink" title="索引别名和零停机"></a>索引别名和零停机</h3><ol>
<li>别名：别名就是快捷方式或软连接，可以指向一个或多个索引，可以给api使用。</li>
<li>功能：<ul>
<li>在集群中从一个索引到另一个索引的无缝切换</li>
<li>给多个索引分组</li>
<li>给索引的子集创建视图</li>
</ul>
</li>
<li>两种管理方式: _alias用于单个操作，_aliases用于执行多个原子级操作</li>
<li>利用别名重建索引步骤：<ol>
<li>现有索引my_index_v1创建一个别名my_index</li>
<li>创建新索引my_index_v2并修改类型，然后把my_index_v1的数据导入my_index_v2</li>
<li>更换别名指向，my_index_v1移除别名，my_index_v2添加别名指向my_index</li>
</ol>
</li>
</ol>
<p>相关操作如下：</p>
<ol>
<li>创建索引 my_index_v1 ，然后将别名 my_index 指向它：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index_v1</span><br><span class="line">PUT /my_index_v1/_alias/my_index</span><br></pre></td></tr></table></figure></li>
<li>查询别名<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /*/_alias/my_index</span><br><span class="line">GET /my_index_v1/_alias/*</span><br></pre></td></tr></table></figure></li>
<li>转移别名指向<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"actions"</span>: [</span><br><span class="line">        &#123; <span class="attr">"remove"</span>: &#123; <span class="attr">"index"</span>: <span class="string">"my_index_v1"</span>, <span class="attr">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"add"</span>:    &#123; <span class="attr">"index"</span>: <span class="string">"my_index_v2"</span>, <span class="attr">"alias"</span>: <span class="string">"my_index"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>11 基础入门-内部分片原理</title>
    <url>/2020/03/06/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/11-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8-%E5%88%86%E7%89%87%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="使文本可被搜索"><a href="#使文本可被搜索" class="headerlink" title="使文本可被搜索"></a>使文本可被搜索</h3><ul>
<li>倒排索引：倒排索引包含一个有序列表，列表包含所有文档中的词项，每个词项包含了它曾出现过文档的列表。</li>
<li>倒排索引需要知道集合中的所有文档</li>
<li>词项包含信息：词项出现总次数，词项在文档中的顺序，文档长度等等</li>
</ul>
<a id="more"></a>
<p>索引的不变性：索引被写入磁盘后是 不可改变的（它永远不会修改）。<br>不变性的优点：</p>
<ul>
<li>不需要加锁，不用担心多线程问题。</li>
<li>不变性可使索引被内核的文件系统缓存，提高了搜索的性能。 一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其他缓存(filter缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>可被压缩。写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和 需要被缓存到内存的索引的使用量。<br>缺点：</li>
<li>索引不能修改</li>
<li>让新文档可被搜索，需要重建整个索引</li>
<li>限制了索引的数量，限制了更新频率</li>
</ul>
<h3 id="动态更新索引"><a href="#动态更新索引" class="headerlink" title="动态更新索引"></a>动态更新索引</h3><p>保留不变性的前提下如果实现索引的更新？<br>答：用更多的索引，新增补充索引，旧索引标记为删除。</p>
<h5 id="Lucene-概念"><a href="#Lucene-概念" class="headerlink" title="Lucene 概念"></a>Lucene 概念</h5><ul>
<li>ES一个索引包含多个分片，每个分片就是Lucene的一个索引。</li>
<li>Lucene的一个索引由多个段组成，每个段本都是倒排索引</li>
<li>ES中的’提交点’：包含所有已知段的文件</li>
<li>ES搜索是按段搜索</li>
</ul>
<p>新增文档到被搜索经历的过程：</p>
<ol>
<li>新增文档时先保存到内存索引缓存中</li>
<li>不时地提交缓存<ul>
<li>一个新的段被写入磁盘</li>
<li>新的段名称加入到提交点中</li>
<li>磁盘同步，把磁盘缓存中等待的写入都刷入磁盘，保存成物理文件</li>
</ul>
</li>
<li>新的段开启，可以被搜索</li>
<li>内存缓存被清空，等待接收新的文档</li>
</ol>
<h6 id="删除和更新"><a href="#删除和更新" class="headerlink" title="删除和更新"></a>删除和更新</h6><ul>
<li>删除：文档被删除时，在.del文件中被标记删除。</li>
<li>更新：文档更新时先删除旧文档再新增新文档。</li>
<li>被标记删除的文档：一个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除</li>
</ul>
<h3 id="近实时搜索"><a href="#近实时搜索" class="headerlink" title="近实时搜索"></a>近实时搜索</h3><ul>
<li>新建文档到被搜索，整个过程的瓶颈在文件系统刷新(fsync)到磁盘的这一步。</li>
<li>轻量级方式，把fsync从过程中移除，写到文件系统中就可以被搜索。Lucene 允许新段被写入和打开—​使其包含的文档在未进行一次完整提交时便对搜索可见。</li>
<li>refresh操作：ES中新建和打开一个新段的轻量的过程叫做 refesh。该操作把文档从内存中写入到文件系统缓存新段中，新段被打开可被搜索，并没有刷到硬盘中。</li>
</ul>
<p>refresh配置：</p>
<ol>
<li><p>refresh操作：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">## 刷新（Refresh）所有的索引。</span><br><span class="line">POST /_refresh</span><br><span class="line">## 只刷新（Refresh） blogs 索引。</span><br><span class="line">POST /blogs/_refresh</span><br></pre></td></tr></table></figure></li>
<li><p>设置refresh间隔时间 refresh_interval</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_logs</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"refresh_interval"</span>: <span class="string">"30s"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; <span class="attr">"refresh_interval"</span>: <span class="string">"1s"</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭refresh</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_logs/_settings</span><br><span class="line">&#123; <span class="attr">"refresh_interval"</span>: <span class="number">-1</span> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="持久化变更"><a href="#持久化变更" class="headerlink" title="持久化变更"></a>持久化变更</h3><ul>
<li>事务日志(translog): ES每次操作时都会进行日志记录。</li>
<li>什么时候清除translog? 执行全量提交(fsync)数据刷到硬盘中后，会清除translog中的数据。</li>
<li>translog提供实时CRUD，通过ID查询、更新、删除一个文档时，首先检查translog最近变更。</li>
<li>translog刷到硬盘两种策略：<ol>
<li>默认5秒一次fsync到硬盘</li>
<li>每次写请求完成后fsync到硬盘，例如:index,delete,update,bulk等</li>
</ol>
</li>
<li>写操作是在translog在主和副分片上全部落盘之后才返回给客户端的。</li>
</ul>
<p>translog落盘策略配置：</p>
<ol>
<li>间隔落盘<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"index.translog.durability"</span>: <span class="string">"async"</span>,</span><br><span class="line">    <span class="attr">"index.translog.sync_interval"</span>: <span class="string">"5s"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>请求时落盘 【默认】<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_settings</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"index.translog.durability"</span>: <span class="string">"request"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
参考文档： <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/index-modules-translog.html#_translog_settings" target="_blank" rel="noopener">translog</a></li>
</ol>
<p><strong><em>flush api</em></strong></p>
<p>从新建到可被搜索的整个过程：</p>
<blockquote>
<ol>
<li>所有在内存缓冲区的文档都被写入一个新的段。</li>
<li>缓冲区被清空。</li>
<li>一个提交点被写入硬盘。</li>
<li>文件系统缓存通过 fsync 被刷新（flush）。</li>
<li>老的 translog 被删除。</li>
</ol>
</blockquote>
<p>什么是flush操作？</p>
<blockquote>
<p>ES中执行一次提交并截断translog的行为叫做 flush。</p>
</blockquote>
<p>flush触发条件：</p>
<blockquote>
<ol>
<li>固定间隔时间执行flush,默认30分钟。<br>index.translog.flush_threshold_period : 30m</li>
<li>translog文件达到指定大小时触发flush.<br>index.translog.flush_threshold_size : 512mb</li>
<li>手动刷新</li>
</ol>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 刷新（flush） blogs 索引</span><br><span class="line">POST /blogs/_flush</span><br><span class="line"># 刷新（flush）所有的索引并且并且等待所有刷新在返回前完成</span><br><span class="line">POST /_flush?wait_for_ongoing</span><br></pre></td></tr></table></figure>

<p>flush使用情景：</p>
<ol>
<li>重启或关闭索引之前执行flush，如果不执行，重启后会重放translog进行恢复。</li>
<li>手动flush，不常用。</li>
</ol>
<h3 id="段合并"><a href="#段合并" class="headerlink" title="段合并"></a>段合并</h3><p>段数目太多的缺点：</p>
<ol>
<li>一个段会消耗文件句、内存和cpu运行周期，段多会消耗系统资源</li>
<li>搜索请求必须轮流检查每个段，段越多就越慢</li>
</ol>
<p>段合并：</p>
<ol>
<li>小段合并为大段，打段合并为更大的段</li>
<li>段合并时清除已删除的旧文档</li>
<li>合并时不影响索引和搜索</li>
<li>合并大的段需要消耗大量的IO和CPU资源，ES会做资源限制，不会影响正常搜索</li>
</ol>
<p>optimize API</p>
<ol>
<li>max_num_segments 限制段的数目，减少段的数量</li>
<li>optimize API 不应该用在一个活跃(频繁更新)的索引上。</li>
<li>某些特定情况 optimize API很有用处，例如日志收集系统，老日志只读不会发生变化</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST /logstash-2014-10/_optimize?max_num_segments=1</span><br></pre></td></tr></table></figure>

<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>12-深入搜索-简介</title>
    <url>/2020/03/08/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/12-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><a href="">中文参考</a>，<a href="">英文参考</a></p>
<h3 id="本章主要内容"><a href="#本章主要内容" class="headerlink" title="本章主要内容"></a>本章主要内容</h3><ol>
<li>理解数据以及如何搜索它们</li>
<li>词的相似度(word proximity)</li>
<li>部分匹配(partial matching)</li>
<li>模糊匹配(fuzzy matching)</li>
<li>语言感知(language awareeness)</li>
<li>理解相关度评分，消除长尾(long tail)</li>
<li>结构化搜索和全文搜索高效结合</li>
</ol>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>13-深入搜索-结构化搜索</title>
    <url>/2020/03/08/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/13-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E7%BB%93%E6%9E%84%E5%8C%96%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="结构化搜索（structured-search）"><a href="#结构化搜索（structured-search）" class="headerlink" title="结构化搜索（structured search）"></a>结构化搜索（structured search）</h3><p>结构化数据：</p>
<ol>
<li>有精确的格式</li>
<li>能进行逻辑操作，例如：比较数字和时间范围，判定两值大小</li>
<li>文本也可以是结构化的，要遵循严格规定的结构化格式。例如:颜色：red,green,blue</li>
</ol>
<p>结构化查询结果为 是或否，结果在或不在集合中，简单地包括或排除文档，不关心相关度或评分。</p>
<a id="more"></a>

<h3 id="精确值查找"><a href="#精确值查找" class="headerlink" title="精确值查找"></a>精确值查找</h3><p>使用过滤器filter进行精确值查询，尽可能多地使用过滤式查询。<br>filter优点：</p>
<ol>
<li>执行速度快</li>
<li>不计算相关度</li>
<li>容易被缓存</li>
</ol>
<h5 id="term查询数字"><a href="#term查询数字" class="headerlink" title="term查询数字"></a>term查询数字</h5><ol>
<li>constant_score将term转化为过滤器</li>
<li>term查询数字</li>
<li>filter不评分，返回评分默认值为1.0</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"term"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="term-查询文本"><a href="#term-查询文本" class="headerlink" title="term 查询文本"></a>term 查询文本</h5><p>前提是文本字段没有被分词，查询字段的index定义为not_analyzed或keyword</p>
<ol>
<li><p>定义不分词</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_store</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span> : &#123;</span><br><span class="line">        <span class="attr">"products"</span> : &#123;</span><br><span class="line">            <span class="attr">"properties"</span> : &#123;</span><br><span class="line">                <span class="attr">"productID"</span> : &#123;</span><br><span class="line">                    <span class="attr">"type"</span> : <span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"index"</span> : <span class="string">"not_analyzed"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>精确查询文本：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"term"</span> : &#123;</span><br><span class="line">                    <span class="attr">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="内部过滤器的操作"><a href="#内部过滤器的操作" class="headerlink" title="内部过滤器的操作"></a>内部过滤器的操作</h5><p>非评分多个步骤：</p>
<ol>
<li>在倒排索引中查询匹配文档</li>
<li>创建bitset，每个文档都加个标志位，匹配为1，未匹配为0。</li>
<li>迭代bitset, 找到满足所有条件的文档集合</li>
<li>增量使用计数，通过计数设置缓存门槛</li>
</ol>
<p>非评分查询首先执行，再执行评分查询，有助于加快搜索速度。</p>
<h3 id="组合过滤器"><a href="#组合过滤器" class="headerlink" title="组合过滤器"></a>组合过滤器</h3><p>bool(布尔)过滤器就是个 复合过滤器(compound filter),可以接受其他过滤器做为参数，组成各种逻辑组合。</p>
<h5 id="布尔过滤器"><a href="#布尔过滤器" class="headerlink" title="布尔过滤器"></a>布尔过滤器</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span> : &#123;</span><br><span class="line">    <span class="attr">"must"</span> : [],</span><br><span class="line">    <span class="attr">"should"</span> : [],</span><br><span class="line">    <span class="attr">"must_not"</span> : []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>布尔过滤器三部分组成</p>
<ol>
<li>must : 必须匹配，与AND等价</li>
<li>must_not : 不能匹配，与NOT等价</li>
<li>should 至少有一个语句匹配，与OR等价</li>
</ol>
<p>样例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span> : &#123;</span><br><span class="line">      <span class="attr">"filtered"</span> : &#123;</span><br><span class="line">         <span class="attr">"filter"</span> : &#123;</span><br><span class="line">            <span class="attr">"bool"</span> : &#123;</span><br><span class="line">              <span class="attr">"should"</span> : [</span><br><span class="line">                 &#123; <span class="attr">"term"</span> : &#123;<span class="attr">"price"</span> : <span class="number">20</span>&#125;&#125;,</span><br><span class="line">                 &#123; <span class="attr">"term"</span> : &#123;<span class="attr">"productID"</span> : <span class="string">"XHDK-A-1293-#fJ3"</span>&#125;&#125;</span><br><span class="line">              ],</span><br><span class="line">              <span class="attr">"must_not"</span> : &#123;</span><br><span class="line">                 <span class="attr">"term"</span> : &#123;<span class="attr">"price"</span> : <span class="number">30</span>&#125;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： 需要一个filtered查询包起所有的东西</p>
<h5 id="嵌套布尔过滤器"><a href="#嵌套布尔过滤器" class="headerlink" title="嵌套布尔过滤器"></a>嵌套布尔过滤器</h5><p>bool过滤器可以嵌套bool过滤器，可以处理任意复杂布尔逻辑。<br>例如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span> : &#123;</span><br><span class="line">      <span class="attr">"filtered"</span> : &#123;</span><br><span class="line">         <span class="attr">"filter"</span> : &#123;</span><br><span class="line">            <span class="attr">"bool"</span> : &#123;</span><br><span class="line">              <span class="attr">"should"</span> : [</span><br><span class="line">                &#123; <span class="attr">"term"</span> : &#123;<span class="attr">"productID"</span> : <span class="string">"KDKE-B-9947-#kL5"</span>&#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">"bool"</span> : &#123;</span><br><span class="line">                  <span class="attr">"must"</span> : [</span><br><span class="line">                    &#123; <span class="attr">"term"</span> : &#123;<span class="attr">"productID"</span> : <span class="string">"JODL-X-1937-#pV7"</span>&#125;&#125;,</span><br><span class="line">                    &#123; <span class="attr">"term"</span> : &#123;<span class="attr">"price"</span> : <span class="number">30</span>&#125;&#125;</span><br><span class="line">                  ]</span><br><span class="line">                &#125;&#125;</span><br><span class="line">              ]</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询多个精确值"><a href="#查询多个精确值" class="headerlink" title="查询多个精确值"></a>查询多个精确值</h3><p>使用terms（注意末尾的s）查找多个精确值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"terms"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="包含而不是相等"><a href="#包含而不是相等" class="headerlink" title="包含而不是相等"></a>包含而不是相等</h5><p>term和terms 是 包含(contains)操作，而非 等值(equals)，相等于 should 操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>] &#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>] &#125;</span><br></pre></td></tr></table></figure>
<p>上面两个查询都会返回包含’search’的文档</p>
<h5 id="精确相等"><a href="#精确相等" class="headerlink" title="精确相等"></a>精确相等</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>], <span class="attr">"tag_count"</span> : <span class="number">1</span> &#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>], <span class="attr">"tag_count"</span> : <span class="number">2</span> &#125;</span><br></pre></td></tr></table></figure>
<p>等价</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                 <span class="attr">"bool"</span> : &#123;</span><br><span class="line">                    <span class="attr">"must"</span> : [</span><br><span class="line">                        &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"tags"</span> : <span class="string">"search"</span> &#125; &#125;,</span><br><span class="line">                        &#123; <span class="attr">"term"</span> : &#123; <span class="attr">"tag_count"</span> : <span class="number">1</span> &#125; &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h3><p>range查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_store/products/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"range"</span> : &#123;</span><br><span class="line">                    <span class="attr">"price"</span> : &#123;</span><br><span class="line">                        <span class="attr">"gte"</span> : <span class="number">20</span>,</span><br><span class="line">                        <span class="attr">"lt"</span>  : <span class="number">40</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>range查询：</p>
<ol>
<li>两种范围表达式：包含(inclusive)和不包含(exclusive)</li>
<li>组合选项：gt: &gt; 大于；lt : &lt; 小于；get: &gt;= 大于等于；lte: &lt;= 小于等于</li>
</ol>
<h5 id="日期范围"><a href="#日期范围" class="headerlink" title="日期范围"></a>日期范围</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "2014-01-01 00:00:00",</span><br><span class="line">        "lt" : "2014-01-07 00:00:00"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>range查找支持日期计算：<br>查询过去一个小时文档。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "now-1th"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双管符号(||)后可以加 日期数学表达式, ||+1M :日期加一个月</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "timestamp" : &#123;</span><br><span class="line">        "gt" : "2014-01-01 00:00:00",</span><br><span class="line">        "lt" : "2014-01-01 00:00:00||+1M"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/mapping-date-format.html" target="_blank" rel="noopener">时间格式参考文档</a></p>
<h5 id="字符串查询"><a href="#字符串查询" class="headerlink" title="字符串查询"></a>字符串查询</h5><ul>
<li>字符串范围查找可采用 字典顺序(Iexicographically)或 字母顺序(alphabetically).</li>
<li>倒排索引采用字典顺序</li>
<li>字符串范围在低基数(少量唯一词项)可以正常工作，唯一词项越多查询越慢。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"range" : &#123;</span><br><span class="line">    "title" : &#123;</span><br><span class="line">        "gte" : "a",</span><br><span class="line">        "lt" :  "b"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="处理null值"><a href="#处理null值" class="headerlink" title="处理null值"></a>处理null值</h3><p>实例数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /my_index/posts/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"1"</span>              &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>]                &#125;  </span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"2"</span>              &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>, <span class="string">"open_source"</span>] &#125;  </span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"3"</span>              &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"other_field"</span> : <span class="string">"some data"</span>        &#125;  </span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"4"</span>              &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : <span class="literal">null</span>                      &#125;  </span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"5"</span>              &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"tags"</span> : [<span class="string">"search"</span>, <span class="literal">null</span>]          &#125;</span><br></pre></td></tr></table></figure>

<h5 id="存在查询-exists"><a href="#存在查询-exists" class="headerlink" title="存在查询 exists"></a>存在查询 exists</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span> : &#123;</span><br><span class="line">                <span class="attr">"exists"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"tags"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果为：1，2，5</p>
<h5 id="missing-缺失查询"><a href="#missing-缺失查询" class="headerlink" title="missing 缺失查询"></a>missing 缺失查询</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/posts/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span> : &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"missing"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"tags"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果：3，4</p>
<p>关于null值：</p>
<ol>
<li>我们可以选择将显式的 null 值替换成我们指定 占位符（placeholder）</li>
<li>字符串（string）、数字（numeric）、布尔值（Boolean）或日期（date）字段指定映射时，可以为之设置 null_value 空值。</li>
<li>选择null_value 时<ol>
<li>null_value要匹配字典类型</li>
<li>null_value必须与普通值不一样</li>
</ol>
</li>
</ol>
<h5 id="对象上的存在与缺失"><a href="#对象上的存在与缺失" class="headerlink" title="对象上的存在与缺失"></a>对象上的存在与缺失</h5><p>exists 和missing除了过滤核心类型，还可以处理一个对象的内部字段。<br>处理对象的要求：对象内部是偏平的字段与值的简单的键值结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"name"</span> : &#123;</span><br><span class="line">      <span class="attr">"first"</span> : <span class="string">"John"</span>,</span><br><span class="line">      <span class="attr">"last"</span> :  <span class="string">"Smith"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"exists"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"name"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于name 字段并不真实存在于倒排索引中，所以内部转为以下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"exists"</span>: &#123; <span class="attr">"field"</span>: <span class="string">"name.first"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"exists"</span>: &#123; <span class="attr">"field"</span>: <span class="string">"name.last"</span> &#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于缓存"><a href="#关于缓存" class="headerlink" title="关于缓存"></a>关于缓存</h3><ol>
<li>ES把过滤器A的bitsets缓存起来，下次再需要过滤器A时，就可以复用了</li>
<li>bitests缓存是增量式更新的，索引新文档时把新文档加入bitsets缓存中。</li>
</ol>
<h5 id="独立的过滤器缓存"><a href="#独立的过滤器缓存" class="headerlink" title="独立的过滤器缓存"></a>独立的过滤器缓存</h5><ol>
<li>bitsets 独立于它所属的搜索请求，可以被多个搜索请求使用</li>
</ol>
<p>举例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /inbox/emails/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123;</span><br><span class="line">              <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                 <span class="attr">"should"</span>: [</span><br><span class="line">                    &#123; <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                          <span class="attr">"must"</span>: [</span><br><span class="line">                             &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"folder"</span>: <span class="string">"inbox"</span> &#125;&#125;,</span><br><span class="line">                             &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"read"</span>: <span class="literal">false</span> &#125;&#125;</span><br><span class="line">                          ]</span><br><span class="line">                    &#125;&#125;,</span><br><span class="line">                    &#123; <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                          <span class="attr">"must_not"</span>: &#123;</span><br><span class="line">                             <span class="attr">"term"</span>: &#123; <span class="attr">"folder"</span>: <span class="string">"inbox"</span> &#125;</span><br><span class="line">                          &#125;,</span><br><span class="line">                          <span class="attr">"must"</span>: &#123;</span><br><span class="line">                             <span class="attr">"term"</span>: &#123; <span class="attr">"important"</span>: <span class="literal">true</span> &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                    &#125;&#125;</span><br><span class="line">                 ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个相同的过滤器<code>&quot;term&quot;: { &quot;folder&quot;: &quot;inbox&quot; }</code>使用的是同一个bitset。</p>
<h5 id="自动缓存行为"><a href="#自动缓存行为" class="headerlink" title="自动缓存行为"></a>自动缓存行为</h5><ol>
<li>为了避免使用频率低的过滤器查询被缓存，ES会基于使用频次自动缓存查询。例如 最近查询使用256次则被缓存</li>
<li>非评分技术的bitset会一直驻留缓存中，直到它被剔除。</li>
<li>剔除规则：基于LRU，剔除最近最少使用的过滤器。</li>
</ol>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>14-深入搜索-全文搜索</title>
    <url>/2020/03/08/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/14-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="全文检索-full-text-search"><a href="#全文检索-full-text-search" class="headerlink" title="全文检索 full-text search"></a>全文检索 full-text search</h3><p>两个重要方面：</p>
<ol>
<li>相关性 Relevance,评价查询与其结果间的相关程度，并根据相关度进行排名。<br>相关度计算方法：<ol>
<li>TF/IDF 方法 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/relevance-intro.html" target="_blank" rel="noopener">相关性的介绍</a></li>
<li>地理位置邻近</li>
<li>模糊相似</li>
<li>其他算法</li>
</ol>
</li>
<li>分析 Analysis，分析是将文本转换为token的过程，目的是创建索引和查询倒排索引。</li>
</ol>
<a id="more"></a>
<h3 id="基于词项与基于全文"><a href="#基于词项与基于全文" class="headerlink" title="基于词项与基于全文"></a>基于词项与基于全文</h3><h5 id="基于词项的查询"><a href="#基于词项的查询" class="headerlink" title="基于词项的查询"></a>基于词项的查询</h5><ol>
<li>不需要分析阶段，对单个词项进行操作，例如 term，fuzzy这样的操作</li>
<li>term查询只对倒排索引的词项进行精确匹配</li>
</ol>
<h5 id="基于全文的查询"><a href="#基于全文的查询" class="headerlink" title="基于全文的查询"></a>基于全文的查询</h5><p>像match 或 query_string 这样的高层查询，对查询映射信息进行区别对待：</p>
<ol>
<li>查询字段为日期和整数时，将查询字符串当做日期和整数</li>
<li>查询字段为未分析(not_analyzed)的字符串时，会把查询字符串作为单个词项对待。</li>
<li>查询字段为已分析(analyzed)字符串时，会将查询字符串交给分析器生成一个词项列表</li>
</ol>
<p>单词项查询通常用是非这种二元问题表示，更适合用过滤，还有效利用缓存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"term"</span>: &#123; <span class="attr">"gender"</span>: <span class="string">"female"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配-match-查询"><a href="#匹配-match-查询" class="headerlink" title="匹配(match)查询"></a>匹配(match)查询</h3><ol>
<li>match查询是核心查询，首页查询方式</li>
<li>match是高级的全文查询, 既能处理全文字段，又能处理精确字段</li>
<li>match主要场景是全文搜索</li>
</ol>
<h5 id="索引一些数据"><a href="#索引一些数据" class="headerlink" title="索引一些数据"></a>索引一些数据</h5><p>创建一些索引数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">DELETE /my_index</span><br><span class="line"></span><br><span class="line">PUT /my_index</span><br><span class="line">&#123; <span class="attr">"settings"</span>: &#123; <span class="attr">"number_of_shards"</span>: <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">POST /my_index/my_type/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">1</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"The quick brown fox"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">2</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"The quick brown fox jumps over the lazy dog"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">3</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"The quick brown fox jumps over the quick dog"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">4</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"Brown fox brown dog"</span> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="单个词查询"><a href="#单个词查询" class="headerlink" title="单个词查询"></a>单个词查询</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"QUICK!"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>match步骤：</p>
<ol>
<li>检查字段类型，判断是否对字符串进行分析</li>
<li>分析查询字符串，分析器把字符串分析成词项，执行单个底层term查询</li>
<li>查找匹配文档， 用term查询在倒排索引中查询quick，然后获取一组包含该项的文档</li>
<li>为每个文档评分，技术每个文档相关度评分_score, score由3部分组成：词频(TF: term frequcncy),反向文档频率(IDF:inverse document frequency), 字段长度(字段越短相关度越高)。</li>
</ol>
<h3 id="多词查询-multi-word"><a href="#多词查询-multi-word" class="headerlink" title="多词查询 multi_word"></a>多词查询 multi_word</h3><h5 id="多词查询"><a href="#多词查询" class="headerlink" title="多词查询"></a>多词查询</h5><p>match查询多词很简单，查询字符串换成多词就可以。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"BROWN DOG!"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于 term should ‘BROWN’ ‘DOG’</p>
<h5 id="提高精度"><a href="#提高精度" class="headerlink" title="提高精度"></a>提高精度</h5><p>通过operator操作符可以接受 or 和 and，默认值 or</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;      </span><br><span class="line">                <span class="attr">"query"</span>:    <span class="string">"BROWN DOG!"</span>,</span><br><span class="line">                <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h5><p>通过minimum_should_match(最小匹配参数)控制精度。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>: <span class="string">"quick brown dog"</span>,</span><br><span class="line">        <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三词项的示例中， 75% 会自动被截断成 66.6% ，即三个里面两个词</p>
<h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><ol>
<li>组合查询与组合过滤器一样，通过bool模型实现</li>
<li>组合查询与组合过滤器中的bool使用，唯一不同之处是 组合查询会计算相关度</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>:     &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">      <span class="attr">"must_not"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"lazy"</span>  &#125;&#125;,</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">                  &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">                  &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>should语句中有一个词项匹配，文档就算相关。</p>
<h5 id="评分计算"><a href="#评分计算" class="headerlink" title="评分计算"></a>评分计算</h5><p>查询的评分步骤：</p>
<ol>
<li>计算每个文档相关度评分score</li>
<li>将must和should语句的分数score求和</li>
<li>求和的分数除以must和should语句的总数</li>
</ol>
<p>注意：must_not 语句不影响评分，因为它只是排除不相关文档</p>
<h5 id="控制精度-1"><a href="#控制精度-1" class="headerlink" title="控制精度"></a>控制精度</h5><ol>
<li>must 必须匹配</li>
<li>must_not 必须不匹配</li>
<li>should 至少一个匹配，可以通过 minimum_should_match 控制精度，</li>
<li>minimum_should_match可以是数字，也可以是百分比</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"minimum_should_match"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="如何使用布尔匹配"><a href="#如何使用布尔匹配" class="headerlink" title="如何使用布尔匹配"></a>如何使用布尔匹配</h3><ol>
<li>常用match查询，如果match无法满足控制过程，就需要使用bool组合查询</li>
<li>match查询可以转换为等价的bool组合查询</li>
</ol>
<p>等价转换例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"brown fox"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span>: &#123;</span><br><span class="line">    <span class="attr">"should"</span>: [</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"brown fox"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span>: &#123;</span><br><span class="line">    <span class="attr">"must"</span>: [</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:                <span class="string">"quick brown fox"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span>: &#123;</span><br><span class="line">    <span class="attr">"should"</span>: [</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"quick"</span> &#125;&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"minimum_should_match"</span>: <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询语句提升权重-boost"><a href="#查询语句提升权重-boost" class="headerlink" title="查询语句提升权重 boost"></a>查询语句提升权重 boost</h3><ol>
<li>使用boost控制语句的权重</li>
<li>boost默认值为1，提升权重(boost大于1), 降低权重(boost 介于 0到 1之间)</li>
<li>权重提升不少线性的，boost=2不等于2倍评分</li>
<li>权重应用之后会被归一化</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"should": [</span><br><span class="line">    &#123; <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"content"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"Elasticsearch"</span>,</span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;,</span><br><span class="line">    &#123; <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"content"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"Lucene"</span>,</span><br><span class="line">            <span class="attr">"boost"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="控制分析"><a href="#控制分析" class="headerlink" title="控制分析"></a>控制分析</h3><ol>
<li>字段可以指定分析器，也可使用类型(type)、索引(index)或节点(node)的默认配置。</li>
<li>索引阶段和搜索阶段可以使用不同分析器analyzer</li>
</ol>
<p>索引时分析器使用优先级：</p>
<ol>
<li>字段映射里定义的分析器analyzer</li>
<li>索引中默认分析器(standard 标准分析器)</li>
<li>全局缺省的分析器</li>
</ol>
<p>搜索时分析器使用优先级：</p>
<ol>
<li>自定义的分析器analyzer</li>
<li>字段映射里定义的搜索分析器 search_analyzer</li>
<li>字段映射里定义的分析器analyzer</li>
<li>索引设置中默认的分析器(standard 标准分析器)</li>
</ol>
<h5 id="分析器配置实践"><a href="#分析器配置实践" class="headerlink" title="分析器配置实践"></a>分析器配置实践</h5><p>两种策略</p>
<ol>
<li>为每个字段指定分析器<br>1.1 好处：清楚了解每个字段的分析器配置<br>1.2 缺点 ： 配置项太多太麻烦</li>
<li>索引中设置默认分析器，个别字段使用自定义分析器</li>
</ol>
<h3 id="被破坏的相关度"><a href="#被破坏的相关度" class="headerlink" title="被破坏的相关度"></a>被破坏的相关度</h3><p>问题：IDF在单个分片上计算的，在数据少且分布不均匀时，IDF在每个分片中会不同。<br>解决方法：</p>
<ol>
<li>只在主分片上创建索引，本地IDF就是全局IDF</li>
<li>搜索请求后加?search_type=dfs_query_then_fetch,dfs是指 分布式频率搜索(Distributed Frequency Search)。<br>ES会先获取每个分片本地的IDF，然后再根据结果计算索引的全局IDF。注意：不要在生产环境使用</li>
</ol>
<p>注意：在实际应用中，本地和全局的 IDF 的差异会随着索引里文档数的增多渐渐消失，在真实世界的数据量下，局部的 IDF 会被迅速均化，所以上述问题并不是相关度被破坏所导致的，而是由于数据太少。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>15-深入搜索-多字段搜索</title>
    <url>/2020/03/08/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/15-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E5%A4%9A%E5%AD%97%E6%AE%B5%E6%90%9C%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="多字段搜索-multi-field-search"><a href="#多字段搜索-multi-field-search" class="headerlink" title="多字段搜索 multi_field_search"></a>多字段搜索 multi_field_search</h3><p>常用查询是 查询多个字符串和多个字段</p>
<h3 id="多字符串查询"><a href="#多字符串查询" class="headerlink" title="多字符串查询"></a>多字符串查询</h3><ul>
<li>最简单的多字符串查询将搜索项映射到具体的字段。</li>
<li>match查询，然后用bool组合起来</li>
<li>最终分数是每个语句的评分的和</li>
</ul>
<a id="more"></a>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>:  <span class="string">"War and Peace"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"author"</span>: <span class="string">"Leo Tolstoy"</span>   &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"bool"</span>:  &#123;</span><br><span class="line">          <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"translator"</span>: <span class="string">"Constance Garnett"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"translator"</span>: <span class="string">"Louise Maude"</span>      &#125;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题：为什么不把should中的语句放在title同一级别？</p>
<blockquote>
<p>答案：计算得分不同，因为每个同级的子句权重是相同的。should中2个语句占三分之一的权重，如果移出来title和author权重都变为四分之一了。</p>
</blockquote>
<p>bool中的语句分值计算步骤：</p>
<ol>
<li>计算每个匹配查询得分</li>
<li>每个匹配查询得分加在一起为总得分</li>
<li>总得分乘以匹配语句数量</li>
<li>再除以语句的总数</li>
</ol>
<h5 id="语句的优先级"><a href="#语句的优先级" class="headerlink" title="语句的优先级"></a>语句的优先级</h5><p>通过权重boost设置语句的优先级</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">ET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>:  &#123;</span><br><span class="line">              <span class="attr">"query"</span>: <span class="string">"War and Peace"</span>,</span><br><span class="line">              <span class="attr">"boost"</span>: <span class="number">2</span></span><br><span class="line">        &#125;&#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"author"</span>:  &#123;</span><br><span class="line">              <span class="attr">"query"</span>: <span class="string">"Leo Tolstoy"</span>,</span><br><span class="line">              <span class="attr">"boost"</span>: <span class="number">2</span></span><br><span class="line">        &#125;&#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"bool"</span>:  &#123;</span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">              &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"translator"</span>: <span class="string">"Constance Garnett"</span> &#125;&#125;,</span><br><span class="line">              &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"translator"</span>: <span class="string">"Louise Maude"</span>      &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>权重调优实践：</p>
<blockquote>
<p>最简单的方式就是不断试错：设定boost值，测试，如此反复。<br>boost值比较合理的区间处于 1和10 之间，也可以设置15，设置更高的值，评分都会被归一化，所以不会对评分最终结果产生影响。</p>
</blockquote>
<h3 id="单字符串搜索"><a href="#单字符串搜索" class="headerlink" title="单字符串搜索"></a>单字符串搜索</h3><ul>
<li>查询： 多词查询(multi_word), 多字段查询(multi_field)</li>
<li>多字段查询(multi_field)适应场景：将不同的查询字符串映射到不同字段。</li>
<li>简单查询和高级查询，用户常用简单查询<ol>
<li>简单查询：像搜索引擎一样搜索；</li>
<li>高级搜索：多字段搜索</li>
</ol>
</li>
<li>简单搜索没有简单的方案，根据不同数据结构选择不同的方案。</li>
</ul>
<p>简单搜索几种数据情况</p>
<ol>
<li>最佳字段(Best fields)。把字段中最高评分作为文档的评分</li>
<li>多数字段(Most fields)。原字段保留，新建字段做搜索用。</li>
<li>混合字段(Cross fields)。 实体信息分散在多个字段中。</li>
</ol>
<h3 id="最佳字段-Best-Fields"><a href="#最佳字段-Best-Fields" class="headerlink" title="最佳字段 Best Fields"></a>最佳字段 Best Fields</h3><p>问题：两个一般匹配字段的评分比一个高度匹配字段的评分分高。<br>解决方法：文档评分采用多字段中分值最高那一个。<br>采用dis_max查询：通过dis_max查询解决此问题。</p>
<p>什么是dis_max查询？</p>
<blockquote>
<p>dis_max(Disjunction Max Query) : 分离最大化查询。<br>分离(Disjunction)意思是 或(or); 结合(Conjunction)意思是 与(and)<br>分离最大化查询: 将任何与任一查询匹配的文档作为结果返回，但只将最佳匹配的评分作为查询的评分结果返回。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"dis_max"</span>: &#123;</span><br><span class="line">            <span class="attr">"queries"</span>: [</span><br><span class="line">                &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"Brown fox"</span> &#125;&#125;,</span><br><span class="line">                &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"body"</span>:  <span class="string">"Brown fox"</span> &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最佳字段查询调优"><a href="#最佳字段查询调优" class="headerlink" title="最佳字段查询调优"></a>最佳字段查询调优</h3><p>dis_max存在的问题：当两个文档中到字段最高值一样，而其他字段分值不一样时，最终文档分值却是一样的。<br>例如：<br>Doc1 ：字段F1=1，字段F2=0，文档1评分为1；<br>Doc2：字段F1=1，字段F2=1，文档1评分为1；</p>
<p>通过tie_breaker解决dis_max的问题。</p>
<h5 id="tie-breaker-连接中断器"><a href="#tie-breaker-连接中断器" class="headerlink" title="tie_breaker 连接中断器"></a>tie_breaker 连接中断器</h5><ul>
<li>tie_breaker是一种 dis_max 和 bool 之间的折中选择</li>
<li>加上tie_breaker后会考虑所有匹配语句，但最佳匹配语句仍然占大部分</li>
<li>tie_breaker取值0到1之间的浮点数，0 表示只使用dis_max最佳匹配语句，1表示 所有匹配语句同等重要。</li>
<li>最佳实践：合理值应该与零接近(01.-0.4),这样不会颠覆dis_max作用</li>
</ul>
<p>tie_breaker评分过程：</p>
<ol>
<li>获得最佳匹配语句的评分_score</li>
<li>将其他匹配语句的评分结果与tie_breaker相乘</li>
<li>对以上评分求和并规范化</li>
</ol>
<h3 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h3><p>multi_match查询 : 多个字段上反复执行相同查询。<br>格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:                <span class="string">"Quick brown fox"</span>,</span><br><span class="line">        <span class="attr">"type"</span>:                 <span class="string">"best_fields"</span>,</span><br><span class="line">        <span class="attr">"fields"</span>:               [ <span class="string">"title"</span>, <span class="string">"body"</span> ],</span><br><span class="line">        <span class="attr">"tie_breaker"</span>:          <span class="number">0.3</span>,</span><br><span class="line">        <span class="attr">"minimum_should_match"</span>: <span class="string">"30%"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>query  查询语句</li>
<li>type ：取值：best_fields、most_fields、cross_fields，默认值是 best_fields，</li>
<li>fields 指定查询的多个字段</li>
<li>tie_breaker : best_fields下的配置</li>
<li>minimun_should_match : 多字符中最少匹配数量</li>
<li>operator : 逻辑操作 or、and</li>
</ul>
<h6 id="查询字段名称的模糊匹配"><a href="#查询字段名称的模糊匹配" class="headerlink" title="查询字段名称的模糊匹配"></a>查询字段名称的模糊匹配</h6><p>fields可以指定字段名列表，也可以用正则匹配模糊模式。<br>例如： <code>*_title 匹配3个字段： book_title,chapter_title,section_title</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:  <span class="string">"Quick brown fox"</span>,</span><br><span class="line">        <span class="attr">"fields"</span>: <span class="string">"*_title"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="提升单个字段的权重"><a href="#提升单个字段的权重" class="headerlink" title="提升单个字段的权重"></a>提升单个字段的权重</h5><p>使用 ^ 字符语法为单个字段提升权重</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">    <span class="attr">"query"</span>: <span class="string">"Quick brown fox"</span>,</span><br><span class="line">    <span class="attr">"fields"</span>: [<span class="string">"*_title"</span>, <span class="string">"chapter_title^2"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多数字段-most-fields"><a href="#多数字段-most-fields" class="headerlink" title="多数字段 most_fields"></a>多数字段 most_fields</h3><p>全文检索两个重要指标：召回率(Recall)和精确率(Precision)<br>召回率(Recall) : 返回所有相关文档，扩大搜索范围可以提高召回率。<br>精确率(Precision): 不返回无关文档，常用方式：为同一文本建立多种方式的索引，每种方式提供一个不同的相关度信号signal。</p>
<p>提高精确率：<br>常用方法： 为同一文本建立多种方式的索引，每种方式提供一个不同的相关度信号signal。<br>例如：jump,字段1 存储jump词根形式，字段2存储同义词，字段3存储口音词，如果查询字段与3个字段匹配越多分值越高。</p>
<h5 id="多字段映射-Multifield-Mapping"><a href="#多字段映射-Multifield-Mapping" class="headerlink" title="多字段映射 Multifield Mapping"></a>多字段映射 Multifield Mapping</h5><p>为了提高精确率，多字段映射(multifields)就可以实现一个文本多种方式的索引。<br>在’fields’中配置其他索引字段。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">UT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123; <span class="attr">"number_of_shards"</span>: <span class="number">1</span> &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"title"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"analyzer"</span>: <span class="string">"english"</span>,</span><br><span class="line">                    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">                        <span class="attr">"std"</span>:   &#123;</span><br><span class="line">                            <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">                            <span class="attr">"analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用match查询title</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"jumping rabbits"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用multi_match 查询, 字段为：title和title.std。<br>type 为 most_fields，most_fields会使两个字段评分合并起来。<br>type如果不指定默认使用dis_max.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:  <span class="string">"jumping rabbits"</span>,</span><br><span class="line">            <span class="attr">"type"</span>:   <span class="string">"most_fields"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"title.std"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过权重boost可以让多字段区分主字段和信号字段。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:       <span class="string">"jumping rabbits"</span>,</span><br><span class="line">            <span class="attr">"type"</span>:        <span class="string">"most_fields"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:      [ <span class="string">"title^10"</span>, <span class="string">"title.std"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此例子中titile为用广度匹配字段，包括尽可能多的文档，提升召回率。title.std作为信号可以将相关度更高的文档至于结果顶部。</p>
<h3 id="跨字段实体搜索-Cross-fields-Entity-Search"><a href="#跨字段实体搜索-Cross-fields-Entity-Search" class="headerlink" title="跨字段实体搜索 Cross-fields Entity Search"></a>跨字段实体搜索 Cross-fields Entity Search</h3><p>一个实体信息有多个字段组成。例如：person(firstname,lastname),address(country,city,street)</p>
<p>简单的实现方式： 使用multi_match的most_fields</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>:       <span class="string">"Poland Street W1V"</span>,</span><br><span class="line">      <span class="attr">"type"</span>:        <span class="string">"most_fields"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>:      [ <span class="string">"street"</span>, <span class="string">"city"</span>, <span class="string">"country"</span>, <span class="string">"postcode"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>most_fields存在的问题：</p>
<ol>
<li>不能找最匹配字段。 它是为多数字段匹配 任意 词设计的，而不是在 所有字段 中找到最匹配的。</li>
<li>不能使用operator/minimum_should_match降低长尾效应。</li>
<li>排序结果不好。 词频对于每个字段是不一样的，而且它们之间的相互影响会导致不好的排序结果。</li>
</ol>
<h3 id="字段中心式查询"><a href="#字段中心式查询" class="headerlink" title="字段中心式查询"></a>字段中心式查询</h3><p>字段中心式： 处理的是多个字段。best_fields，<br>词中心式：把所有字段中的词放入同一个字段中，处理的是一个字段的所有词。</p>
<p>问题：</p>
<ol>
<li>在多个字段中匹配相同的词，导致排序结果不精确</li>
<li>无法剪掉长尾</li>
<li>词频相互影响，导致排序结果不精确</li>
</ol>
<p>解决方案：<br>将所有这些字段组合成单个字段。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"first_name"</span>:  <span class="string">"Peter"</span>,</span><br><span class="line">    <span class="attr">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="attr">"full_name"</span>:   <span class="string">"Peter Smith"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义-all-字段"><a href="#自定义-all-字段" class="headerlink" title="自定义 _all 字段"></a>自定义 <code>_all</code> 字段</h3><p>使用copy_to 自定义组合字段</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"person"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"first_name"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"copy_to"</span>:  <span class="string">"full_name"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"last_name"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"copy_to"</span>:  <span class="string">"full_name"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">"full_name"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"string"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意 :</strong>  copy_to只能用在主字段上，不能用在fields中字段，因为fields中的字段没有自己的数据源。</p>
<h3 id="cross-fields-跨字段查询"><a href="#cross-fields-跨字段查询" class="headerlink" title="cross-fields 跨字段查询"></a>cross-fields 跨字段查询</h3><ul>
<li>自定义_all方式是个好方案，缺点是需要索引文档时需要设置好映射。</li>
<li>ES也提供了另一个好的方案是: cross_fields跨字段查询。</li>
<li>cross_fields跨字段查询避开了 字段中心式的3个缺点。</li>
<li>cross_fields比自定义的优势：<ol>
<li>索引文档时不需要设置映射。</li>
<li>可以为搜索字段设置权限。</li>
</ol>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /books/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:       <span class="string">"peter smith"</span>,</span><br><span class="line">            <span class="attr">"type"</span>:        <span class="string">"cross_fields"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:      [ <span class="string">"title^2"</span>, <span class="string">"description"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>自定义单字段查询是否能够优于多字段查询，取决于在多字段查询与单字段自定义 _all 之间代价的权衡，即哪种解决方案会带来更大的性能优化就选择哪一种。</p>
<h3 id="Exact-Value-精确值字段"><a href="#Exact-Value-精确值字段" class="headerlink" title="Exact-Value 精确值字段"></a>Exact-Value 精确值字段</h3><p>需要在 multi_match 查询中避免使用 not_analyzed(keyword) 字段</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>16-深入搜索-近似匹配</title>
    <url>/2020/03/09/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/16-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E8%BF%91%E4%BC%BC%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h3 id="近似匹配"><a href="#近似匹配" class="headerlink" title="近似匹配"></a>近似匹配</h3><p>match查询只能告诉我是否包含查询词条，无法告知词语的关系。</p>
<h3 id="短语匹配-Phrase-Matching"><a href="#短语匹配-Phrase-Matching" class="headerlink" title="短语匹配 Phrase Matching"></a>短语匹配 Phrase Matching</h3><p>短语匹配：</p>
<ol>
<li>使用match_phrase关键词</li>
<li>查询字符串解析成搜索词项(与match查询相同)</li>
<li>全部词项：返回结果应包含搜索语句中的全部的词项</li>
<li>位置顺序相同：返回结果中包含词项的位置与搜索词项相同。</li>
</ol>
<a id="more"></a>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"quick brown fox"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转化为等价的match查询</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"match": &#123;</span><br><span class="line">    "title": &#123;</span><br><span class="line">        "query": "quick brown fox",</span><br><span class="line">        "type":  "phrase"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="词项的位置-Term-Positions"><a href="#词项的位置-Term-Positions" class="headerlink" title="词项的位置 Term Positions"></a>词项的位置 Term Positions</h5><ol>
<li>索引文档时会存储位置信息</li>
<li>位置信息由3个字段组成，起始点(start_offset),结束点(end_offset), 词项位置(positions)</li>
<li>起始点(start_offset) : 词项在原始字符串中的起始位置</li>
<li>结束点(end_offset) ：词项在原始字符串中的结束位置</li>
<li>词项位置(positions)：词项在原始字符串中的位置号。</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_analyze</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"text"</span> : <span class="string">"Quick brown fox"</span>,</span><br><span class="line">  <span class="attr">"analyzer"</span> : <span class="string">"standard"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"tokens"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>: <span class="string">"quick"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">0</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>: <span class="number">5</span>,</span><br><span class="line">         <span class="attr">"type"</span>: <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>: <span class="number">1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>: <span class="string">"brown"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">6</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>: <span class="number">11</span>,</span><br><span class="line">         <span class="attr">"type"</span>: <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>: <span class="number">2</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"token"</span>: <span class="string">"fox"</span>,</span><br><span class="line">         <span class="attr">"start_offset"</span>: <span class="number">12</span>,</span><br><span class="line">         <span class="attr">"end_offset"</span>: <span class="number">15</span>,</span><br><span class="line">         <span class="attr">"type"</span>: <span class="string">"&lt;ALPHANUM&gt;"</span>,</span><br><span class="line">         <span class="attr">"position"</span>: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="什么是短语"><a href="#什么是短语" class="headerlink" title="什么是短语"></a>什么是短语</h5><ol>
<li>搜索词项全部出现在字段中</li>
<li>搜索词项位置不变</li>
</ol>
<h3 id="混合起来-slop"><a href="#混合起来-slop" class="headerlink" title="混合起来 slop"></a>混合起来 slop</h3><p>原文：quick brown fox<br>使用slop参数的短语匹配:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">ET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">            	<span class="attr">"query"</span>: <span class="string">"quick fox"</span>,</span><br><span class="line">            	<span class="attr">"slop"</span>:  <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>slop : 原意是：溢出，这里是指词条移动。查询词条位置移动多少次才能与文档匹配。<br>移动：词项向右移动</p>
<h3 id="多值字段-Multivalue-Fields"><a href="#多值字段-Multivalue-Fields" class="headerlink" title="多值字段 Multivalue Fields"></a>多值字段 Multivalue Fields</h3><p>短语查询在查询多值字段(数组)时会出现奇怪问题。<br>问题：ES索引数组时生成词汇单元都紧紧相邻，没有区分开数组中的字符串。<br>解决方法：利用position_increment_gap在各元素间插入位置增量值。<br>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/groups/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"names"</span>: [ <span class="string">"John Abraham"</span>, <span class="string">"Lincoln Smith"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于下面</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/groups/1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"names"</span>: <span class="string">"John Abraham Lincoln Smith"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的短语查询就会匹配到上面的文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/groups/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">            <span class="attr">"names"</span>: <span class="string">"Abraham Lincoln"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决方法：position_increment_gap 为多值字段中的每值间插入间隔值。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/groups</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"names"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>:                <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"position_increment_gap"</span>: <span class="number">100</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>位置信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Position 1: john</span><br><span class="line">Position 2: abraham</span><br><span class="line">Position 103: lincoln</span><br><span class="line">Position 104: smith</span><br></pre></td></tr></table></figure>


<h3 id="越近越好-Closer-Is-Better"><a href="#越近越好-Closer-Is-Better" class="headerlink" title="越近越好 Closer Is Better"></a>越近越好 Closer Is Better</h3><ul>
<li>邻近查询(proximity query) : 短语查询中配置一个大于0的slop值。</li>
<li>高slop值的好处：1. 排查距离太远的文档 2. 距离越近分值越高</li>
</ul>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">         <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"quick dog"</span>,</span><br><span class="line">            <span class="attr">"slop"</span>:  <span class="number">50</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果第1句比第2句的距离近，所以分值高。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"hits"</span>: [</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">"_id"</span>:      <span class="string">"3"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>:   <span class="number">0.75</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">           <span class="attr">"title"</span>: <span class="string">"The quick brown fox jumps over the quick dog"</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">        <span class="attr">"_id"</span>:      <span class="string">"2"</span>,</span><br><span class="line">        <span class="attr">"_score"</span>:   <span class="number">0.28347334</span>,</span><br><span class="line">        <span class="attr">"_source"</span>: &#123;</span><br><span class="line">           <span class="attr">"title"</span>: <span class="string">"The quick brown fox jumps over the lazy dog"</span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用邻近度提高相关度-Proximity-for-Relevance"><a href="#使用邻近度提高相关度-Proximity-for-Relevance" class="headerlink" title="使用邻近度提高相关度 Proximity for Relevance"></a>使用邻近度提高相关度 Proximity for Relevance</h3><p>邻近查询要求所有词条都出现在文档中，要求过于严格，可以把邻近查询作为信号(signal信号)使用。</p>
<p>总结：</p>
<ol>
<li>match增加广度，提高召回率</li>
<li>通过minimum_should_match参数去除长尾</li>
<li>邻近查询做为辅助(signal)查询，提高相关度</li>
</ol>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:                <span class="string">"quick brown fox"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"30%"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"should"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"quick brown fox"</span>,</span><br><span class="line">            <span class="attr">"slop"</span>:  <span class="number">50</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="性能优化-Improving-Performance"><a href="#性能优化-Improving-Performance" class="headerlink" title="性能优化 Improving Performance"></a>性能优化 Improving Performance</h3><ol>
<li>短语查询和邻近查询比简单的query代价更高</li>
<li>简单query只需要查看词条是否存在；match_phrase 还需要计算和比较词项位置。</li>
<li>term查询比短语查询快10倍，比邻近查询快20倍。</li>
</ol>
<h5 id="结果集重新评分-Rescoring-Results"><a href="#结果集重新评分-Rescoring-Results" class="headerlink" title="结果集重新评分 Rescoring Results"></a>结果集重新评分 Rescoring Results</h5><p>通过短语查询限制文档总数，这样可以限制短语查询和邻近查询的性能消耗。<br>重新评分结果集可以达到限制文档数的效果。<br>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;  </span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>:                <span class="string">"quick brown fox"</span>,</span><br><span class="line">                <span class="attr">"minimum_should_match"</span>: <span class="string">"30%"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"rescore"</span>: &#123;</span><br><span class="line">        <span class="attr">"window_size"</span>: <span class="number">50</span>,</span><br><span class="line">        <span class="attr">"query"</span>: &#123;         </span><br><span class="line">            <span class="attr">"rescore_query"</span>: &#123;</span><br><span class="line">                <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">                    <span class="attr">"title"</span>: &#123;</span><br><span class="line">                        <span class="attr">"query"</span>: <span class="string">"quick brown fox"</span>,</span><br><span class="line">                        <span class="attr">"slop"</span>:  <span class="number">50</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>match 包含在最终结果集中，并通过 TF/IDF 排序</li>
<li>window_size <strong><em>每一分片</em></strong> 进行重新评分的顶部文档数量。</li>
<li>目前唯一支持的重新打分算法就是另一个查询，但是以后会有计划增加更多的算法。</li>
</ol>
<h3 id="Shingles-寻找相关词-Finding-Associated-Words"><a href="#Shingles-寻找相关词-Finding-Associated-Words" class="headerlink" title="Shingles - 寻找相关词 Finding Associated Words"></a>Shingles - 寻找相关词 Finding Associated Words</h3><p><strong><em>Shingles是替换match_phrase查询的一个好的方案,性能优于match_phrase查询。_</em></strong></p>
<p>短语查询和邻近查询的缺点：</p>
<ol>
<li>过于严格：所有词项必须存在</li>
<li>slop虽然得到单词顺序灵活性，但也失去了 <strong><em>单词对</em></strong> 之间的联系。</li>
</ol>
<h6 id="shinlges"><a href="#shinlges" class="headerlink" title="shinlges"></a>shinlges</h6><ul>
<li>shinles: 对字符串中的词项进行N-gram标记的方法。</li>
<li>N-gram ：1-grams(unigrams),2-grams(Bigrams), 3-grams(Trigrams) …</li>
</ul>
<table>
<thead>
<tr>
<th align="left">N-grams</th>
<th align="left">字符： apple</th>
<th align="left">词项: sue ate the alligator</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1 Unigrams</td>
<td align="left">a,p,p,l,e</td>
<td align="left">“sue”,”ate”,”the”,”alligator”</td>
</tr>
<tr>
<td align="left">2 Bigrams</td>
<td align="left">ap,pp,pl,le</td>
<td align="left">“sue ate”, “ate the”, “the alligator”</td>
</tr>
<tr>
<td align="left">3 Trigrams</td>
<td align="left">app,ppl,ple</td>
<td align="left">“sue ate the”, “ate the alligator”</td>
</tr>
</tbody></table>
<h5 id="生成-Shingles，Producing-Shingles"><a href="#生成-Shingles，Producing-Shingles" class="headerlink" title="生成 Shingles，Producing Shingles"></a>生成 Shingles，Producing Shingles</h5><p>映射配置步骤：</p>
<ol>
<li>analyzer中配置一个shingle过滤器</li>
<li>配置shingle过滤器</li>
<li>shingle过滤器参数包含：<ul>
<li>type 指定为shingle,</li>
<li>min_shingle_size和max_shingle_size 指定shingle最小和最大值，默认为2</li>
<li>output_unigrams 设置是否输出unigrams, 默认true，会输出unigrams</li>
</ul>
</li>
</ol>
<p>例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">1</span>,  </span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_shingle_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:             <span class="string">"shingle"</span>,</span><br><span class="line">                    <span class="attr">"min_shingle_size"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"max_shingle_size"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"output_unigrams"</span>:  <span class="literal">false</span>   </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_shingle_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:             <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="attr">"tokenizer"</span>:        <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"filter"</span>: [</span><br><span class="line">                        <span class="string">"lowercase"</span>,</span><br><span class="line">                        <span class="string">"my_shingle_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试shingle</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_shingle_analyzer</span><br><span class="line">Sue ate the alligator</span><br></pre></td></tr></table></figure>
<p>结果为：”sue ate”, “ate the”, “the alligator”</p>
<h5 id="多字段-Multifields"><a href="#多字段-Multifields" class="headerlink" title="多字段 Multifields"></a>多字段 Multifields</h5><p>在多字段中配置shingle,主字段使用unigrams,其他字段使用自定义shingle.<br>这样就把unigram和bigrams分开索引了。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"fields"</span>: &#123;</span><br><span class="line">                    <span class="attr">"shingles"</span>: &#123;</span><br><span class="line">                        <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">                        <span class="attr">"analyzer"</span>: <span class="string">"my_shingle_analyzer"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="搜索Shingles"><a href="#搜索Shingles" class="headerlink" title="搜索Shingles"></a>搜索Shingles</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"query"</span>: &#123;</span><br><span class="line">      <span class="attr">"bool"</span>: &#123;</span><br><span class="line">         <span class="attr">"must"</span>: &#123;</span><br><span class="line">            <span class="attr">"match"</span>: &#123;</span><br><span class="line">               <span class="attr">"title"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"should"</span>: &#123;</span><br><span class="line">            <span class="attr">"match"</span>: &#123;</span><br><span class="line">               <span class="attr">"title.shingles"</span>: <span class="string">"the hungry alligator ate sue"</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h5><ul>
<li>shingles 不仅比短语查询更灵活，而且性能也更好。</li>
<li>shingles在索引时会索引更多的字段，占用更多的磁盘空间，但是每次查询不用花费短语查询那样高的代价，可以跟一个简单的 match 查询一样高效</li>
</ul>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>17-深入搜索-部分匹配(Partial_Matching)</title>
    <url>/2020/03/10/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/17-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E9%83%A8%E5%88%86%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><p>前面介绍的都是整个词的匹配，最小单元为单个词。<br>部分匹配(Partial matching)：</p>
<blockquote>
<p>允许查询词的一部分并返回包含这部分片断的词。</p>
</blockquote>
<p>部分匹配的应用场景：</p>
<ul>
<li>某个特定前缀开始，例如 邮编，产品序列或未分析值</li>
<li>某种模式匹配，例如 邮编，产品序列或未分析值</li>
<li>与某个正则式相匹配，例如 邮编，产品序列或未分析值</li>
<li>输入即搜索(search-as-you-type) : 用户搜索时呈现可能的结果</li>
<li>匹配如德语或荷兰语这样有长组合词的语言，如： Weltgesundheitsorganisation （世界卫生组织，英文 World Health Organization）。</li>
</ul>
<a id="more"></a>

<h3 id="邮编与结构化数据"><a href="#邮编与结构化数据" class="headerlink" title="邮编与结构化数据"></a>邮编与结构化数据</h3><p>邮编是有规律的结构化数据，需要配置成not_analyzed(keyword).<br>初始化邮编数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/address/1</span><br><span class="line">&#123; <span class="attr">"postcode"</span>: <span class="string">"W1V 3DG"</span> &#125;</span><br><span class="line">PUT /my_index/address/2</span><br><span class="line">&#123; <span class="attr">"postcode"</span>: <span class="string">"W2F 8HW"</span> &#125;</span><br><span class="line">PUT /my_index/address/3</span><br><span class="line">&#123; <span class="attr">"postcode"</span>: <span class="string">"W1F 7HW"</span> &#125;</span><br><span class="line">PUT /my_index/address/4</span><br><span class="line">&#123; <span class="attr">"postcode"</span>: <span class="string">"WC1N 1LZ"</span> &#125;</span><br><span class="line">PUT /my_index/address/5</span><br><span class="line">&#123; <span class="attr">"postcode"</span>: <span class="string">"SW5 0BE"</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="prefix-前缀查询"><a href="#prefix-前缀查询" class="headerlink" title="prefix 前缀查询"></a>prefix 前缀查询</h3><p>前缀查询</p>
<ul>
<li>前缀查询是一个词级别的底层查询</li>
<li>不会对前缀进行分词</li>
<li>前缀查询不做相关度评分计算，结果评分都是1.</li>
<li>前缀查询和前缀过滤器唯一区别就是过滤器可以被缓存</li>
<li>前缀查询过程是依次匹配倒排索引的词列表中词。</li>
<li>注意事项：字段中词的集合要小，前缀长度不要太短，否则会有性能问题</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"prefix"</span>: &#123;</span><br><span class="line">            <span class="attr">"postcode"</span>: <span class="string">"W1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通配符与正则表达式查询-wildcard-and-regexp-Queries"><a href="#通配符与正则表达式查询-wildcard-and-regexp-Queries" class="headerlink" title="通配符与正则表达式查询 (wildcard and regexp Queries)"></a>通配符与正则表达式查询 (wildcard and regexp Queries)</h3><p>通配符(wildcard)和正则式</p>
<ul>
<li>通配符是一种底层基于词的查询</li>
<li>允许指定匹配的正则表达式</li>
<li>通配符使用shell通配符：？匹配任意字符，<code>*</code> 匹配 0或多个字符</li>
<li>regexp 可以定义复杂的匹配模式</li>
<li>wildcard 和 regexp 查询的工作方式与 prefix 查询完全一样，需要扫描倒排索引中的词列表才能找到所有匹配的词，然后依次获取每个词相关的文档 ID</li>
<li>wildcard 和 regexp 查询同样也存在性能问题，应该避免使用左通配的匹配(如:<code>*foo</code>)</li>
<li>prefix 、 wildcard 和 regexp 查询虽然有使用场景，但仍需谨慎使用。</li>
</ul>
<p>通配符</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"wildcard"</span>: &#123;</span><br><span class="line">            <span class="attr">"postcode"</span>: <span class="string">"W?F*HW"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正则表达式</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/address/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"regexp"</span>: &#123;</span><br><span class="line">            <span class="attr">"postcode"</span>: <span class="string">"W[0-9].+"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><code>prefix 、 wildcard 和 regexp 查询是基于词操作的</code><br>正常查询返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"regexp"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"br.*"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>以下查询不是基于词操作，无法返回结果</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"regexp"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"Qu.*"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"regexp"</span>: &#123; <span class="attr">"title"</span>: <span class="string">"quick br*"</span> &#125;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="查询时输入即搜索-Index-Time-Optimizations"><a href="#查询时输入即搜索-Index-Time-Optimizations" class="headerlink" title="查询时输入即搜索(Index-Time Optimizations)"></a>查询时输入即搜索(Index-Time Optimizations)</h3><p>即时搜索（instant search）或 输入即搜索（search-as-you-type）: 用户未输入完内容之前就能展现结果。<br>通过<code>match_phrase_prefix</code>实现即时搜索的功能.</p>
<p>match_phrase_prefix</p>
<ul>
<li>与match_phrase类似，唯一不同的是最后一个词作为前缀使用。</li>
<li>match_phrase_prefix也可以接受slop参数</li>
<li>match_phrase_prefix也存在严重的资源消耗问题</li>
<li>通过max_expansions参数来限制匹配数量，合理值是50, 匹配倒排索引词列表的前N个词项。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match_phrase_prefix"</span> : &#123;</span><br><span class="line">        <span class="attr">"brand"</span> : &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"walker johnnie bl"</span>,</span><br><span class="line">            <span class="attr">"max_expansions"</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="attr">"slop"</span>:  <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引时优化"><a href="#索引时优化" class="headerlink" title="索引时优化"></a>索引时优化</h3><p>查询时解决方案都是以牺牲搜索性能为代价的。<br>索引时优化数据可以提供搜索的灵活性，提升系统性能。<br>索引优化的代价是：1. 增加索引空间 2.索引能力变慢</p>
<h3 id="Ngrams-在部分匹配的应用"><a href="#Ngrams-在部分匹配的应用" class="headerlink" title="Ngrams 在部分匹配的应用"></a>Ngrams 在部分匹配的应用</h3><p>‘profix,wildcard,regexp’的方案是:</p>
<blockquote>
<p>搜索内容与词的各个字母比较匹配。</p>
</blockquote>
<p>N-Grams 方案是:</p>
<blockquote>
<p>把词项拆分成各种组合列表，然后索引起来，搜索时只需要像term一样查询，只进行词相等比较。</p>
</blockquote>
<p>n-grams 形式如下：</p>
<ul>
<li>长度 1（unigram）： [ q, u, i, c, k ]</li>
<li>长度 2（bigram）： [ qu, ui, ic, ck ]</li>
<li>长度 3（trigram）： [ qui, uic, ick ]</li>
<li>长度 4（four-gram）： [ quic, uick ]</li>
<li>长度 5（five-gram）： [ quick ]</li>
</ul>
<p>edge n-grams(边界n-grams)形式如下：</p>
<ul>
<li>q</li>
<li>qu</li>
<li>qui</li>
<li>quic</li>
<li>quick</li>
</ul>
<p>edge n-grams能满足输入即搜索（search-as-you-type）这种应用场景。</p>
<h3 id="索引时输入即搜索-Index-Time-Search-as-You-Type"><a href="#索引时输入即搜索-Index-Time-Search-as-You-Type" class="headerlink" title="索引时输入即搜索(Index-Time Search-as-You-Type)"></a>索引时输入即搜索(Index-Time Search-as-You-Type)</h3><p>配置边界ngram(edge ngram):</p>
<ol>
<li>在analysis.filter中配置过滤器autocomplete_filter</li>
<li>在analysis.analyzer中配置分析器autocomplete，并在起filter中添加autocomplete_filter</li>
<li>在映射中给属性配置上自定义分析器autocomplete</li>
<li>搜索时索引分析器(index_search)和搜索分析器(search_index)需要指定不同的分析器，两种方法：<ol>
<li>在搜索语句中指定搜索分析器。</li>
<li>映射mapping配置时，索引和搜索分析器配置不同的分析器。</li>
</ol>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"number_of_shards"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"autocomplete_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"edge_ngram"</span>,</span><br><span class="line">                    <span class="attr">"min_gram"</span>: <span class="number">1</span>,</span><br><span class="line">                    <span class="attr">"max_gram"</span>: <span class="number">20</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"autocomplete"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:      <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"filter"</span>: [</span><br><span class="line">                        <span class="string">"lowercase"</span>,</span><br><span class="line">                        <span class="string">"autocomplete_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种方法：在搜索语句中指定搜索分析器,不使用分析器autocomplete。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>:    <span class="string">"brown fo"</span>,</span><br><span class="line">                <span class="attr">"analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行测试</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: &#123;</span><br><span class="line">              <span class="attr">"query"</span>:    <span class="string">"brown fo"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种方法：映射mapping配置时，索引和搜索分析器配置不同的分析器。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/my_type/_mapping</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">        <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>:            <span class="string">"string"</span>,</span><br><span class="line">                <span class="attr">"index_analyzer"</span>:  <span class="string">"autocomplete"</span>,</span><br><span class="line">                <span class="attr">"search_analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Ngrams比match_phrase_prefix方式要高效的多，但n-grams有时会有延迟问，索引ES又创建了 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-suggesters-completion.html" target="_blank" rel="noopener">completion suggester</a></p>
<p>completion suggester:</p>
<blockquote>
<p>Elasticsearch 里的 completion suggester 采用与上面完全不同的方式，需要为搜索条件生成一个所有可能完成的词列表，然后将它们置入一个 有限状态机（finite state transducer） 内，这是个经优化的图结构。为了搜索建议提示，Elasticsearch 从图的开始处顺着匹配路径一个字符一个字符地进行匹配，一旦它处于用户输入的末尾，Elasticsearch 就会查找所有可能结束的当前路径，然后生成一个建议列表。<br>本数据结构存于内存中，能使前缀查找非常快，比任何一种基于词的查询都要快很多，这对名字或品牌的自动补全非常适用，因为这些词通常是以普通顺序组织的：用 “Johnny Rotten” 而不是 “Rotten Johnny” 。<br>当词序不是那么容易被预见时，边界 n-grams 比完成建议者（Completion Suggester）更合适。即使说不是所有猫都是一个花色，那这只猫的花色也是相当特殊的。</p>
</blockquote>
<h5 id="边界-n-grams-与邮编"><a href="#边界-n-grams-与邮编" class="headerlink" title="边界 n-grams 与邮编"></a>边界 n-grams 与邮编</h5><p>edge n-gram也可以用于结构化数据。使用keyword分词器来处理。</p>
<blockquote>
<p>keyword 分词器是一个非操作型分词器，这个分词器不做任何事情，它接收的任何字符串都会被原样发出，因此它可以用来处理 not_analyzed 的字段值，但这也需要其他的一些分析转换，如将字母转换成小写。</p>
</blockquote>
<p>下面示例使用 keyword 分词器将邮编转换成 token 流，这样就能使用边界 n-gram token 过滤器：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">            <span class="attr">"postcode_filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"type"</span>:     <span class="string">"edge_ngram"</span>,</span><br><span class="line">                <span class="attr">"min_gram"</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">"max_gram"</span>: <span class="number">8</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">            <span class="attr">"postcode_index"</span>: &#123;</span><br><span class="line">                <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">                <span class="attr">"filter"</span>:    [ <span class="string">"postcode_filter"</span> ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"postcode_search"</span>: &#123;</span><br><span class="line">                <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>postcode_index 分析器使用 postcode_filter 将邮编转换成边界 n-gram 形式。</li>
<li>postcode_search 分析器可以将搜索词看成 not_analyzed 未分析的。</li>
</ul>
<h3 id="Ngrams-在复合词的应用-Ngrams-for-Compound-Words"><a href="#Ngrams-在复合词的应用-Ngrams-for-Compound-Words" class="headerlink" title="Ngrams 在复合词的应用 (Ngrams for Compound Words)"></a>Ngrams 在复合词的应用 (Ngrams for Compound Words)</h3><p>两种方法：</p>
<ol>
<li>用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-compound-word-tokenfilter.html" target="_blank" rel="noopener">组合词 token 过滤器（compound word token filter）</a>将复合词拆分成各自部分，但这种方式的结果质量依赖于组合词字典的质量。</li>
<li>所有的词用 n-gram 进行处理，然后搜索任何匹配的片段——能匹配的片段越多，文档的相关度越大。再结合参数minimum_should_match和shingle使用。</li>
</ol>
<p>n-grams配置如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"trigrams_filter"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"ngram"</span>,</span><br><span class="line">                    <span class="attr">"min_gram"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">"max_gram"</span>: <span class="number">3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"trigrams"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:      <span class="string">"custom"</span>,</span><br><span class="line">                    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"filter"</span>:   [</span><br><span class="line">                        <span class="string">"lowercase"</span>,</span><br><span class="line">                        <span class="string">"trigrams_filter"</span></span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">            <span class="attr">"properties"</span>: &#123;</span><br><span class="line">                <span class="attr">"text"</span>: &#123;</span><br><span class="line">                    <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">                    <span class="attr">"analyzer"</span>: <span class="string">"trigrams"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=trigrams</span><br><span class="line">Weißkopfseeadler</span><br></pre></td></tr></table></figure>
<p>搜索语句：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"text"</span>: &#123;</span><br><span class="line">                <span class="attr">"query"</span>:                <span class="string">"Gesundheit"</span>,</span><br><span class="line">                <span class="attr">"minimum_should_match"</span>: <span class="string">"80%"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>18-深入搜索-控制相关度</title>
    <url>/2020/03/11/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/18-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E5%BA%A61/</url>
    <content><![CDATA[<h3 id="控制相关度简介"><a href="#控制相关度简介" class="headerlink" title="控制相关度简介"></a>控制相关度简介</h3><p>全文相关的公式或 相似算法（similarity algorithms） 会将多个因素合并起来，为每个文档生成一个相关度评分 <code>_score</code>。</p>
<p>当然，相关度不只与全文查询有关，也需要将结构化的数据考虑其中。</p>
<a id="more"></a>
<h3 id="相关度评分背后的理论-Theory-Behind-Relevance-Scoring"><a href="#相关度评分背后的理论-Theory-Behind-Relevance-Scoring" class="headerlink" title="相关度评分背后的理论(Theory Behind Relevance Scoring)"></a>相关度评分背后的理论(Theory Behind Relevance Scoring)</h3><ol>
<li>使用<a href="http://en.wikipedia.org/wiki/Standard_Boolean_model" target="_blank" rel="noopener">布尔模型(Boolean model)</a>查询文档</li>
<li>用<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/practical-scoring-function.html" target="_blank" rel="noopener">实用评分函数(practical scoring function)</a>的公式计算相关度。</li>
</ol>
<p>实用评分函数：</p>
<ol>
<li>借鉴 <a href="http://en.wikipedia.org/wiki/Tfidf" target="_blank" rel="noopener">词频/逆向文档频率（term frequency/inverse document frequency）</a> 和 <a href="http://en.wikipedia.org/wiki/Vector_space_model" target="_blank" rel="noopener">向量空间模型（vector space model)</a></li>
<li>现代新特性1: 协调因子（coordination factor）</li>
<li>现代新特性2: 字段长度归一化（field length normalization）</li>
<li>词或查询语句权重提升</li>
</ol>
<h5 id="词频-逆向文档频率-TF-IDF"><a href="#词频-逆向文档频率-TF-IDF" class="headerlink" title="词频/逆向文档频率(TF/IDF)"></a>词频/逆向文档频率(TF/IDF)</h5><p>一个文档的相关度部分取决于每个查询词在文档中的权重。<br>词权重由三个因素决定：词频(TF),反向文档频率(IDF),字段长度</p>
<h5 id="词频-Term-frequency"><a href="#词频-Term-frequency" class="headerlink" title="词频(Term frequency)"></a>词频(Term frequency)</h5><ul>
<li>词频:词在文档中出现的频度,频道越高，权重越高。</li>
<li>禁止使用词频，配置index_options为docs，</li>
<li>禁止词频后索引不会记录词频和词频位置，短语和近似查询也不可用</li>
<li>禁用词频配置：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"text"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:          <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"index_options"</span>: <span class="string">"docs"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="反向文档频率-Inverse-document-frequency"><a href="#反向文档频率-Inverse-document-frequency" class="headerlink" title="反向文档频率(Inverse document frequency)"></a>反向文档频率(Inverse document frequency)</h5><ul>
<li>反向文档频率： 包含词的文档在文档集合中出现的频率，频次越高，权重越低。</li>
<li>公式：idf(t) = 1 + log ( numDocs / (docFreq + 1))，<ul>
<li>idf(t) : 词t的逆向文档频率</li>
<li>numDocs ：索引中的文档数</li>
<li>docFreq ：包含词的文档数</li>
</ul>
</li>
</ul>
<h5 id="字段长度归一值-Field-length-norm"><a href="#字段长度归一值-Field-length-norm" class="headerlink" title="字段长度归一值 (Field-length norm)"></a>字段长度归一值 (Field-length norm)</h5><ul>
<li>字段(field)的长度是多少？字段越短，字段的权重 越高 。</li>
<li>字段长度的归一值对全文搜索非常重要</li>
<li>字段长度的归一值，索引中每个文档的每个 string 字段都大约占用 1 个 byte 的空间。</li>
<li>not_analyzed(keyword)字段归一值默认是禁用的，analyzed也可以修改映射禁止归一值</li>
<li>日志的应用场景只关心是否包含错误码或其他唯一标识，不关心字段长度，禁用归一值可以节省大量内存空间。</li>
</ul>
<p>公式(平方根的倒数)：<br>norm(d) = 1 / √numTerms</p>
<p>修改映射禁止归一值</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"text"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"norms"</span>: &#123; <span class="attr">"enabled"</span>: <span class="literal">false</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h5><p>以下三个因素：词频、逆向文档频率和字段长度归一值（field-length norm），词频和字段长度归一值在索引时计算并存储的。查询时把他们结合在一起计算单个词在特定文档中的 权重。</p>
<p>查看相关度评分因子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/doc/_search?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"fox"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="向量空间模型-vector-space-model"><a href="#向量空间模型-vector-space-model" class="headerlink" title="向量空间模型(vector space model)"></a>向量空间模型(vector space model)</h5><ul>
<li>向量空间模型(vector space model)提供了一种比较多词查询的方式，单个评分代表文档与查询的匹配程度。</li>
<li>向量值：每个词在查询语句中权重值</li>
<li>两类向量是：1. 全部查询词组成的一个向量 2. 每个匹配文档组成一个向量，包含的词在向量中为权重值，没包含的词在向量中为0。</li>
</ul>
<p>例如：<br>查询语句： “happy hippopotamus”,happy权重为2，hippopotamus权重为5。<br>文档如下：</p>
<ol>
<li>I am happy in summer 。</li>
<li>After Christmas I’m a hippopotamus 。</li>
<li>The happy hippopotamus helped Harry 。</li>
</ol>
<p>向量如下：<br>查询向量: happy hippopotamus — (2,5) – query[2,5]<br>文档1：(happy,             ) — (2,0) – doc1 [2,0]<br>文档2：(     , hippopotamus) — (0,5) – doc2 [0,5]<br>文档1：(happy, hippopotamus) — (2,5) – doc3 [2,5]</p>
<p>把4个向量都放入坐标系中，以(0,0)为起点做直线，计算doc1,doc2,doc3与query之间的夹角就可以得出相关度。夹角越小，相关度越高，夹角越大，相关度越低。</p>
<p>关于比较两个向量的更多信息可以参考 : <a href="http://en.wikipedia.org/wiki/Cosine_similarity" target="_blank" rel="noopener">余弦近似度（cosine similarity）</a>。</p>
<h3 id="Lucene-的实用评分函数"><a href="#Lucene-的实用评分函数" class="headerlink" title="Lucene 的实用评分函数"></a>Lucene 的实用评分函数</h3><p>对于多词查询， Lucene 使用 布尔模型（Boolean model） 、 TF/IDF 以及 向量空间模型（vector space model） ，然后将它们组合到单个高效的包里以收集匹配文档并进行评分计算。</p>
<p>一个多词查询最终转换为bool模型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"quick fox"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123;<span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">        &#123;<span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"fox"</span>   &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="实用评分函数（practical-scoring-function）"><a href="#实用评分函数（practical-scoring-function）" class="headerlink" title="实用评分函数（practical scoring function）"></a>实用评分函数（practical scoring function）</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">score(q,d)  &#x3D;                &#x2F;&#x2F; score(q,d) 是文档 d 与查询 q 的相关度评分。</span><br><span class="line">            queryNorm(q)     &#x2F;&#x2F; queryNorm(q) 是 查询归一化 因子。</span><br><span class="line">          · coord(q,d)       &#x2F;&#x2F; coord(q,d) 是 协调 因子。</span><br><span class="line">          · ∑ (              &#x2F;&#x2F; 查询 q 中每个词 t 对于文档 d 的权重和。</span><br><span class="line">                tf(t in d)   &#x2F;&#x2F; tf(t in d) 是词 t 在文档 d 中的 词频 。</span><br><span class="line">              · idf(t)²      &#x2F;&#x2F; idf(t) 是词 t 的 逆向文档频率 。</span><br><span class="line">              · t.getBoost() &#x2F;&#x2F; t.getBoost() 是查询中使用的 boost。</span><br><span class="line">              · norm(t,d)    &#x2F;&#x2F; norm(t,d)是字段长度归一值与索引时字段层boost（如果存在）的和。</span><br><span class="line">            ) (t in q)</span><br></pre></td></tr></table></figure>

<h5 id="查询归一因子-Query-Normalization-Factor"><a href="#查询归一因子-Query-Normalization-Factor" class="headerlink" title="查询归一因子(Query Normalization Factor)"></a>查询归一因子(Query Normalization Factor)</h5><p>查询归一因子(queryNorm)试图将查询归一化，这样两个不同的结果可以比较。</p>
<blockquote>
<p>尽管查询归一值的目的是为了使查询结果之间能够相互比较，但是它并不十分有效，因为相关度评分<br><code>_score</code> 的目的是为了将当前查询的结果进行排序，比较不同查询结果的相关度评分没有太大意义。</p>
</blockquote>
<blockquote>
<p>相同查询归一化因子会被应用到每个文档，不能被更改，总而言之，可以被忽略。</p>
</blockquote>
<h5 id="查询协调-Query-Coordination"><a href="#查询协调-Query-Coordination" class="headerlink" title="查询协调 (Query Coordination)"></a>查询协调 (Query Coordination)</h5><ul>
<li>协调因子(coord)可以为查询词包含度高的文档提供奖励，扩大化分值差距，使匹配度高的成为更好的匹配结果。</li>
<li>bool查询中should语句 默认会使用协调功能。</li>
<li>协调因子使用场景：bool查询中有多个match查询时，希望匹配越多排序越靠前。</li>
<li>协调因子禁用场景：不关心匹配多个查询词，例如：查找的是同义词时不关心文档中出现多少个同义词。</li>
<li>当使用同义词时Lucene会重写的查询会禁用同义词的协调功能。大多数禁用操作的应用场景是自动处理的，无须为此担心。</li>
</ul>
<p>添加协调因子例如：<br>| Header One              | 原评分 | 加协调因子       |<br>| :————-          | :—- | :—-           |<br>| 文档里有 fox             | 1.5 | 1.5 * 1 / 3 = 0.5 |<br>| 文档里有 quick fox       | 3.0 |3.0 * 2 / 3 = 2.0  |<br>| 文档里有 quick brown fox | 4.5 |4.5 * 3 / 3 = 4.5  |</p>
<p>禁用协调因子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"disable_coord"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"jump"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"hop"</span>  &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"leap"</span> &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="索引时字段层权重提升-Index-Time-Field-Level-Boosting"><a href="#索引时字段层权重提升-Index-Time-Field-Level-Boosting" class="headerlink" title="索引时字段层权重提升(Index-Time Field-Level Boosting)"></a>索引时字段层权重提升(Index-Time Field-Level Boosting)</h5><p>字段权重提升就是让某个字段比其他字段更重要,权重的提升会被应用到字段的每个词，而不是字段本身.</p>
<p>不建议在建立索引时对字段提升权重,原因如下：</p>
<ul>
<li>归一值精度丢失。将提升值与字段长度归一值合在单个字节中存储会丢失字段长度归一值的精度，这样会导致 Elasticsearch 不知如何区分包含三个词的字段和包含五个词的字段。</li>
<li>索引时提升值需要重构索引。要想改变索引时的提升值，就必须重新为所有文档建立索引，与此不同的是，查询时的提升值可以随着每次查询的不同而更改。</li>
<li>会导致权重急剧上升。如果一个索引时权重提升的字段有多个值，提升值会按照每个值来自乘，这会导致该字段的权重急剧上升。</li>
</ul>
<h3 id="查询时权重提升-Query-Time-Boosting"><a href="#查询时权重提升-Query-Time-Boosting" class="headerlink" title="查询时权重提升(Query-Time Boosting)"></a>查询时权重提升(Query-Time Boosting)</h3><ul>
<li>使用boost参数让一个查询语句比其他语句更重要。</li>
<li>boost默认值为 1。</li>
<li>boost 设置为 2 ，并不代表最终的评分 <code>_score</code> 是原值的两倍，因为权重值会经过归一化和一些其他内部优化过程。</li>
<li>无法通过简单公式得出某个权重提升值，只能不断尝试。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"should": [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>: <span class="string">"quick brown fox"</span>,</span><br><span class="line">        <span class="attr">"boost"</span>: <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"content"</span>: <span class="string">"quick brown fox"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="提升索引权重-Boosting-an-Index"><a href="#提升索引权重-Boosting-an-Index" class="headerlink" title="提升索引权重(Boosting an Index)"></a>提升索引权重(Boosting an Index)</h5><ul>
<li>在多个索引中搜索时，可以使用参数indices_boost来提升索引的权重。</li>
<li>没配置时默认值为 1</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /docs_2014_*/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"indices_boost"</span>: &#123;</span><br><span class="line">    <span class="attr">"docs_2014_10"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"docs_2014_09"</span>: <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: <span class="string">"quick brown fox"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="t-getBoost"><a href="#t-getBoost" class="headerlink" title="t.getBoost()"></a>t.getBoost()</h5><ul>
<li>在Lucene中通过t.getBoost()获得实用评分函数的提升权限。</li>
<li>权重提升不会被应用于它在查询表达式中出现的层，而是会被合并下转至每个词中。</li>
<li>t.getBoost() 始终返回当前词的权重或当前分析链上查询的权重。</li>
<li>explain中无法看boost值，因为权重值融入到queryNorm中并应用到每个词</li>
</ul>
<h3 id="使用查询结构修改相关度-Manipulating-Relevance-with-Query-Structure"><a href="#使用查询结构修改相关度-Manipulating-Relevance-with-Query-Structure" class="headerlink" title="使用查询结构修改相关度(Manipulating Relevance with Query Structure)"></a>使用查询结构修改相关度(Manipulating Relevance with Query Structure)</h3><p>通过调整查询语句的层次，可以改变其主要性。<br><code>quick OR brown OR red OR fox</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"red"</span>   &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"fox"</span>   &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>quick OR (brown OR red) OR fox</code><br>red 和 brown 处于相互竞争的层次， quick 、 fox 以及 red OR brown 则是处于顶层且相互竞争的词.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"fox"</span>   &#125;&#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"bool"</span>: &#123;</span><br><span class="line">            <span class="attr">"should"</span>: [</span><br><span class="line">              &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">              &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"red"</span>   &#125;&#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Not-Quite-Not"><a href="#Not-Quite-Not" class="headerlink" title="Not Quite Not"></a>Not Quite Not</h3><ul>
<li>将某些查询语句的权重降低而不是排除。</li>
<li>boost查询中 positive(正向提升) 和 negative(负向降低) 查询。</li>
<li>negative_boost的值必须小于 1.0。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"apple"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"must_not"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"pie tart fruit crumble tree"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>boost查询的positive和</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"boosting"</span>: &#123;</span><br><span class="line">      <span class="attr">"positive"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"apple"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"negative"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"pie tart fruit crumble tree"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"negative_boost"</span>: <span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="忽略-TF-IDF"><a href="#忽略-TF-IDF" class="headerlink" title="忽略 TF/IDF"></a>忽略 TF/IDF</h3><ul>
<li>如果只关心一个词是否在某个字段中出现过，那就忽略TF/IDF</li>
<li>查询语句中使用constant_score忽略TF/IDF</li>
<li>not_analyzed(keyword)字段每个词的IDF会使用，会禁用字段长度归一值（field-length norms)和禁用词频(index_options: docs)，</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"should"</span>: [</span><br><span class="line">        &#123; <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">          <span class="attr">"query"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"description"</span>: <span class="string">"wifi"</span> &#125;&#125;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">          <span class="attr">"query"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"description"</span>: <span class="string">"garden"</span> &#125;&#125;</span><br><span class="line">        &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">          <span class="attr">"boost"</span>:   <span class="number">2</span>,</span><br><span class="line">          <span class="attr">"query"</span>: &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"description"</span>: <span class="string">"pool"</span> &#125;&#125;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="function-score-查询"><a href="#function-score-查询" class="headerlink" title="function_score 查询"></a>function_score 查询</h3><p>过滤器无法计算评分。这样就需要寻求一种方式将过滤器和查询间的差异抹平。<br>function_score 查询不仅正好可以扮演这个角色，而且有更强大的功能。</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>19-深入搜索-控制相关度</title>
    <url>/2020/03/12/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/19-%E6%B7%B1%E5%85%A5%E6%90%9C%E7%B4%A2-%E6%8E%A7%E5%88%B6%E7%9B%B8%E5%85%B3%E5%BA%A62/</url>
    <content><![CDATA[<h3 id="function-score-查询"><a href="#function-score-查询" class="headerlink" title="function_score 查询"></a>function_score 查询</h3><ul>
<li>过滤器无法计算评分。这样就需要寻求一种方式将过滤器和查询间的差异抹平。function_score 查询不仅正好可以扮演这个角色，而且有更强大的功能。</li>
<li>function_score 查询允许每个与主查询匹配的文档应用一个函数，以达到改变甚至替换原始查询评分的目的。</li>
<li>function_score 可以使用过滤器，这样既可以高效评分，有能利用过滤器缓存</li>
<li>function_score可以将全文查询与最新发生的因子结合在一起评分，可以根据全文相关度进行排序，但也会同时考虑其他因子：新发布文档、流行文档、或接近用户希望价格的产品等。</li>
</ul>
<a id="more"></a>
<p>ES预定义的函数：</p>
<ul>
<li>weight : 为每个文档应用一个权重提升值，该值不会被归一化，当weight=2时，最终结果为 2 * <code>_score</code></li>
<li>field_value_factor : 使用这个值来修改 <code>_score</code> ，如将 popularity 或 votes （受欢迎或赞）作为考虑因素。</li>
<li>random_score : 为每个用户都使用一个不同的随机评分对结果排序，但对某一具体用户来说，看到的顺序始终是一致的。</li>
<li>衰减函数 —— linear、 exp、 gauss : 将浮动值结合到评分 <code>_score</code> 中，例如结合 publish_date 获得最近发布的文档，结合 geo_location 获得更接近某个具体经纬度（lat/lon）地点的文档，结合 price 获得更接近某个特定价格的文档。</li>
<li>script_score : 如果需求超出以上范围时，用自定义脚本可以完全控制评分计算，实现所需逻辑。</li>
</ul>
<h3 id="按受欢迎度提升权重-Boosting-by-Popularity"><a href="#按受欢迎度提升权重-Boosting-by-Popularity" class="headerlink" title="按受欢迎度提升权重(Boosting by Popularity)"></a>按受欢迎度提升权重(Boosting by Popularity)</h3><p>将 function_score 查询与 field_value_factor 结合使用，即将点赞数与全文相关度评分结合。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /blogposts/post/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">          <span class="attr">"query"</span>:    <span class="string">"popularity"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"content"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"field_value_factor"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>:    <span class="string">"votes"</span>,</span><br><span class="line">        <span class="attr">"modifier"</span>: <span class="string">"log1p"</span>,</span><br><span class="line">        <span class="attr">"factor"</span>:   <span class="number">0.1</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"boost_mode"</span>: <span class="string">"sum"</span>,</span><br><span class="line">      <span class="attr">"max_boost"</span>:  <span class="number">1.5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面配置后的公式： <code>new_score = old_score + log(1 + 0.1 * number_of_votes)</code><br>max_boost限制结果，无论 field_value_factor 函数的结果如何，最终结果都不会大于 1.5 。</p>
<p>参数说明：</p>
<ul>
<li>function_score 查询将主查询和函数包括在内。</li>
<li>主查询query优先执行。</li>
<li>field_value_factor 函数会被应用到每个与主 query 匹配的文档。</li>
<li>每个文档的 votes 字段都 必须 有值供 function_score 计算。如果 没有 文档的 votes 字段有值，那么就 必须 使用 missing 属性 提供的默认值来进行评分计算。</li>
<li>modifier调节器 取值：none(默认)，log,log1p,log2p,ln,ln1p,ln2p,square,sqrt,reciprocal；更多参考:  <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/query-dsl-function-score-query.html#function-field-value-factor" target="_blank" rel="noopener">field_value_factor 文档</a></li>
<li>factor : 协调因子，factor 值大于 1 会提升效果， factor 值小于 1 会降低效果。例如：new_score = old_score * log(1 + factor * number_of_votes)</li>
<li>max_boost : 限制一个函数的最大效果，max_boost 只对函数的结果进行限制，不会对最终评分<code>_score</code>产生直接影响。</li>
<li>boost_mode : 控制函数与查询评分(<code>_score</code>)合并后的结果。取值如下：<ul>
<li>multiply : 评分 <code>_score</code> 与函数值的积（默认）</li>
<li>sum : 评分 <code>_score</code>与函数值的和</li>
<li>min : 评分 <code>_score</code>与函数值间的较小值</li>
<li>max : 评分 <code>_score</code>与函数值间的较大值</li>
<li>replace : 函数值替代评分<code>_score</code></li>
</ul>
</li>
</ul>
<h3 id="过滤集提升权重"><a href="#过滤集提升权重" class="headerlink" title="过滤集提升权重"></a>过滤集提升权重</h3><p>查询city 字段中包含 Barcelona 的所有文档，不需要全文检索，用过滤比用查询表达更清晰。<br>使用filter(不是query)和weight提升权重，weight没有被归一化，而是直接被应用。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"function_score"</span>: &#123;  </span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"term"</span>: &#123; <span class="attr">"city"</span>: <span class="string">"Barcelona"</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"functions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"features"</span>: <span class="string">"wifi"</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"features"</span>: <span class="string">"garden"</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"features"</span>: <span class="string">"pool"</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"score_mode"</span>: <span class="string">"sum"</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>function_score 查询有个 filter 过滤器而不是 query 查询。</li>
<li>functions 关键字下存储着一个函数列表，每个函数都指定一个 filter 过滤器。</li>
<li>函数会被应用于filter过滤器匹配的文档。</li>
<li>score_mode 指定各个函数的值进行组合运算的方式。</li>
<li>function_score 取值： match_all(默认)，query，filter。</li>
<li>score_mode评分模式 ：将多个函数(filter)返回的结果缩减为单个值的方式。<ul>
<li>multiply : 函数结果求积（默认）。</li>
<li>sum : 函数结果求和。</li>
<li>avg : 函数结果的平均值。</li>
<li>max : 函数结果的最大值。</li>
<li>min : 函数结果的最小值。</li>
<li>first : 使用首个函数（可以有过滤器，也可能没有）的结果作为最终结果</li>
</ul>
</li>
<li>在本例中，将每个过滤器匹配结果的权重 weight 求和，并将其作为最终评分结果，所以会使用sum评分模式。</li>
<li>不与任何过滤器匹配的文档会保有其原始评分， <code>_score</code> 值的为 1 。</li>
</ul>
<h3 id="随机评分"><a href="#随机评分" class="headerlink" title="随机评分"></a>随机评分</h3><ul>
<li>一致随机评分（consistently random scoring）,当seed相同时产生的随机数始终一致。</li>
<li>使用场景：很多文档评分相同，使用每个文档都有均等相似的展现率</li>
<li>random_score 函数会输出一个 0 到 1 之间的数，当种子 seed 值相同时，生成的随机结果是一致的</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"term"</span>: &#123; <span class="attr">"city"</span>: <span class="string">"Barcelona"</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"functions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"features"</span>: <span class="string">"wifi"</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"features"</span>: <span class="string">"garden"</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"filter"</span>: &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"features"</span>: <span class="string">"pool"</span> &#125;&#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"random_score"</span>: &#123;</span><br><span class="line">            <span class="attr">"seed"</span>:  <span class="string">"the users session id"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">"score_mode"</span>: <span class="string">"sum"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>random_score 语句没有任何过滤器 filter ，所以会被应用到所有文档。</li>
<li>将用户的会话 ID 作为种子 seed ，让该用户的随机始终保持一致，相同的种子 seed 会产生相同的随机结果。</li>
</ul>
<h3 id="越近越好"><a href="#越近越好" class="headerlink" title="越近越好"></a>越近越好</h3><p>function_score提供一组 衰减函数(decay functions) ： linear(线性)、exp(指数)、gauss(高斯函数)；</p>
<p>三个函数都能接受的参数：</p>
<ul>
<li>origin : 中心点 或 字段可能的最佳值，落在原点 origin 上的文档评分 <code>_score</code> 为满分 1.0 。</li>
<li>scale : 衰减率，即一个文档从原点origin下落时评分<code>_score</code>改变的速度。(例如：每100元或 每100米)</li>
<li>decay : 从原点origin衰减到scale所得的评分<code>_score</code>,默认值是 0.5</li>
<li>offset : 以原点 origin 为中心点，为其设置一个非零的偏移量 offset 覆盖一个范围，而不只是单个原点。在范围 -offset &lt;= origin &lt;= +offset 内的所有评分 <code>_score</code> 都是 1.0 。</li>
</ul>
<p>三个函数之间的区别在于范围（ origin +/- (offset + scale) ）之外的曲线形状：</p>
<ul>
<li>linear 线性函数是条直线，一旦直线与横轴 0 相交，所有其他值的评分都是 0.0 。</li>
<li>exp 指数函数是先剧烈衰减然后变缓。</li>
<li>gauss 高斯函数是钟形的——它的衰减速率是先缓慢，然后变快，最后又放缓。</li>
</ul>
<p>以伦敦市中作为原点 origin 。<br>所有距原点 origin 2km 范围内的位置的评分是 1.0 。<br>距中心 5km （ offset + scale ）的位置的评分是 0.5 。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"functions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"gauss"</span>: &#123;</span><br><span class="line">            <span class="attr">"location"</span>: &#123;</span><br><span class="line">              <span class="attr">"origin"</span>: &#123; <span class="attr">"lat"</span>: <span class="number">51.5</span>, <span class="attr">"lon"</span>: <span class="number">0.12</span> &#125;,</span><br><span class="line">              <span class="attr">"offset"</span>: <span class="string">"2km"</span>,</span><br><span class="line">              <span class="attr">"scale"</span>:  <span class="string">"3km"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"gauss"</span>: &#123;</span><br><span class="line">            <span class="attr">"price"</span>: &#123;</span><br><span class="line">              <span class="attr">"origin"</span>: <span class="string">"50"</span>,</span><br><span class="line">              <span class="attr">"offset"</span>: <span class="string">"50"</span>,</span><br><span class="line">              <span class="attr">"scale"</span>:  <span class="string">"20"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"weight"</span>: <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="理解-price-价格语句"><a href="#理解-price-价格语句" class="headerlink" title="理解 price 价格语句"></a>理解 price 价格语句</h3><p>price小技巧: 用户希望选择100元以下的度假屋，把原点origin设置为50，偏移量offset设置为50，这样就能覆盖 0-100元的范围了。</p>
<h3 id="脚本评分"><a href="#脚本评分" class="headerlink" title="脚本评分"></a>脚本评分</h3><p>如果function_score无法满足应用场景，可以使用script_score 函数自行实现逻辑。</p>
<p>Elasticsearch 里使用 Groovy 作为默认的脚本语言，它与JavaScript很像，上面这个算法用 Groovy 脚本表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">price  &#x3D; doc[&#39;price&#39;].value</span><br><span class="line">margin &#x3D; doc[&#39;margin&#39;].value</span><br><span class="line"></span><br><span class="line">if (price &lt; threshold) &#123;</span><br><span class="line">  return price * margin &#x2F; target</span><br><span class="line">&#125;</span><br><span class="line">return price * (1 - discount) * margin &#x2F; target</span><br></pre></td></tr></table></figure>

<p>最终script_score函数与其他函数一起使用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"function_score"</span>: &#123;</span><br><span class="line">    <span class="attr">"functions"</span>: [</span><br><span class="line">      &#123; ... 上面的gauss函数 location clause ... &#125;,</span><br><span class="line">      &#123; ... 上面的gauss函数 price clause ... &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"script_score"</span>: &#123;</span><br><span class="line">          <span class="attr">"params"</span>: &#123;</span><br><span class="line">            <span class="attr">"threshold"</span>: <span class="number">80</span>,</span><br><span class="line">            <span class="attr">"discount"</span>: <span class="number">0.1</span>,</span><br><span class="line">            <span class="attr">"target"</span>: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"script"</span>: <span class="string">"price  = doc['price'].value; margin = doc['margin'].value;</span></span><br><span class="line"><span class="string">          if (price &lt; threshold) &#123; return price * margin / target &#125;;</span></span><br><span class="line"><span class="string">          return price * (1 - discount) * margin / target;"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>location 和 price 语句在 衰减函数 中解释过。</li>
<li>将这些变量作为参数 params 传递，我们可以查询时动态改变脚本无须重新编译。</li>
<li>JSON 不能接受内嵌的换行符，脚本中的换行符可以用 \n 或 ; 符号替代。</li>
<li>script_score 函数提供了巨大的灵活性，可以通过脚本访问文档里的所有字段、当前评分 <code>_score</code> 甚至词频、逆向文档频率和字段长度规范值这样的信息</li>
<li>如果脚本执行慢，有下面方法优化：<ul>
<li>尽可能多的提前计算各种信息并将结果存入每个文档中。</li>
<li>Groovy 很快，但没 Java 快。可以将脚本用原生的 Java 脚本重新实现。（参见 原生 Java 脚本）。</li>
<li>仅对那些最佳评分的文档应用脚本，使用 重新评分 中提到的 rescore 功能。</li>
</ul>
</li>
</ul>
<h3 id="可插拔的相似度算法-Pluggable-Similarity-Algorithms"><a href="#可插拔的相似度算法-Pluggable-Similarity-Algorithms" class="headerlink" title="可插拔的相似度算法(Pluggable Similarity Algorithms)"></a>可插拔的相似度算法(Pluggable Similarity Algorithms)</h3><p>Elasticsearch 将 实用评分算法 作为默认相似度算法，它也能够支持其他的一些算法，这些算法可以参考 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/index-modules-similarity.html#configuration" target="_blank" rel="noopener">相似度模块</a> 文档.</p>
<h5 id="Okapi-BM25"><a href="#Okapi-BM25" class="headerlink" title="Okapi BM25"></a>Okapi BM25</h5><p>能与 TF/IDF 和向量空间模型媲美的就是 Okapi BM25 ，它被认为是 当今最先进的 排序函数。 BM25 源自 概率相关模型（probabilistic relevance model） ，而不是向量空间模型，但这个算法也和 Lucene 的实用评分函数有很多共通之处。</p>
<p>BM25 同样使用词频、逆向文档频率以及字段长归一化，但是每个因子的定义都有细微区别。与其详细解释 BM25 公式，倒不如将关注点放在 BM25 所能带来的实际好处上。</p>
<p>参考 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/pluggable-similarites.html#bm25-saturation" target="_blank" rel="noopener">Okapi BM25</a></p>
<h5 id="词频饱和度-Term-frequency-saturation"><a href="#词频饱和度-Term-frequency-saturation" class="headerlink" title="词频饱和度(Term-frequency saturation)"></a>词频饱和度(Term-frequency saturation)</h5><p>BM25的非线性词频饱和度（nonlinear term-frequency saturation），达到某值后即使词频一直增加但对评分的影响很小。</p>
<p>参考 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/pluggable-similarites.html#bm25-saturation" target="_blank" rel="noopener">词频饱和度</a></p>
<h5 id="字段长度归一化-Field-length-normalization"><a href="#字段长度归一化-Field-length-normalization" class="headerlink" title="字段长度归一化(Field-length normalization)"></a>字段长度归一化(Field-length normalization)</h5><p>BM25会考虑字段的平均长度，这样能区分是短的title字段还是长的title字段。</p>
<h5 id="BM25-调优-Tuning-BM25"><a href="#BM25-调优-Tuning-BM25" class="headerlink" title="BM25 调优(Tuning BM25)"></a>BM25 调优(Tuning BM25)</h5><p>BM25有两个可调参数：</p>
<ul>
<li>k1 : 这个参数控制着词频结果在词频饱和度中的上升速度。默认值为 1.2 。值越小饱和度变化越快，值越大饱和度变化越慢。</li>
<li>b : 这个参数控制着字段长归一值所起的作用， 0.0 会禁用归一化， 1.0 会启用完全归一化。默认值为 0.75 。</li>
</ul>
<h3 id="更改相似度"><a href="#更改相似度" class="headerlink" title="更改相似度"></a>更改相似度</h3><ul>
<li>相似度算法可以在映射时指定到字段上</li>
<li>字段默认是 实用评分函数</li>
<li>ES不支持更改已有字段的相似度算法</li>
<li>自定义的相似度算法可以通过关闭索引，更新索引设置，开启索引这个过程进行更新。这样可以无须重建索引又能试验不同的相似度算法配置。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"similarity"</span>: <span class="string">"BM25"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"body"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"similarity"</span>: <span class="string">"default"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义相似度算法</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"similarity"</span>: &#123;</span><br><span class="line">      <span class="attr">"my_bm25"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"BM25"</span>,</span><br><span class="line">        <span class="attr">"b"</span>:    <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"doc"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"similarity"</span>: <span class="string">"my_bm25"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"body"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"similarity"</span>: <span class="string">"BM25"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个基于内置 BM25 ，名为 my_bm25 的自定义相似度算法。</li>
<li>“b”:0  禁用字段长度规范化（field-length normalization）。参见 调试 BM25 。</li>
<li>title 字段使用自定义相似度算法 my_bm25 。</li>
<li>字段 body 使用内置相似度算法 BM25</li>
</ul>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><h3 id="调试相关度是最后-10-要做的事情-Relevance-Tuning-Is-the-Last-10"><a href="#调试相关度是最后-10-要做的事情-Relevance-Tuning-Is-the-Last-10" class="headerlink" title="调试相关度是最后 10% 要做的事情(Relevance Tuning Is the Last 10%)"></a>调试相关度是最后 10% 要做的事情(Relevance Tuning Is the Last 10%)</h3><ul>
<li>本章介绍了 Lucene 是如何基于 TF/IDF 生成评分的</li>
<li>理解评分过程是非常重要的，这样就可以根据具体的业务对评分结果进行调试、调节、减弱和定制。</li>
<li>最佳实践：为了获得 具有成效 的搜索结果，就必须反复调试、调节、减弱和定制。</li>
<li>经过对策略字段或重要语句应用权重提升。</li>
<li>因为最相关 这个概念是一个难以触及的模糊目标，通常不同人对文档排序又有着不同的想法，容易使人陷入持续反复调整而没有明显进展的怪圈。不用陷入怪圈，要监控测量返回的结果，例如:监控顶端结果的点击次数，来回查看的频次。</li>
<li>要想物尽其用并将搜索结果提高到 极高的 水平，唯一途径就是需要具备能评价度量用户行为的强大能力</li>
</ul>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03-处理人类语言</title>
    <url>/2020/01/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/20-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E5%BC%80%E5%A7%8B%E5%A4%84%E7%90%86%E5%90%84%E7%A7%8D%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>参考：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/languages.html" target="_blank" rel="noopener">处理人类语言</a></p>
<ul>
<li>全文检索是一场查准率与查全率之间的较量。</li>
<li>查准率 即尽量返回较少的无关文档</li>
<li>查全率 则尽量返回较多的相关文档</li>
<li>我们希望去搜索那些和原文不是完全匹配但却相关的单词</li>
</ul>
<a id="more"></a>
<p>可优化的地方</p>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/token-normalization.html" target="_blank" rel="noopener">归一化词元</a></li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/stemming.html" target="_blank" rel="noopener">将单词还原为词干</a></li>
<li>清除常用词或停用词 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/stopwords.html" target="_blank" rel="noopener">停用词: 性能与精度</a></li>
<li>包含<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/synonyms.html" target="_blank" rel="noopener">同义词</a></li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/fuzzy-matching.html" target="_blank" rel="noopener">检查拼写错误</a></li>
</ul>
<h3 id="开始处理各种语言"><a href="#开始处理各种语言" class="headerlink" title="开始处理各种语言"></a>开始处理各种语言</h3><p>Elasticsearch 为很多世界流行语言提供良好的、简单的、开箱即用的语言分析器集合。</p>
<p>分析器主要功能：</p>
<ul>
<li>文本拆分为单词。The quick brown foxes → [ The, quick, brown, foxes]</li>
<li>大写转小写。 The → the</li>
<li>移除常用的 停用词。[ The, quick, brown, foxes] → [ quick, brown, foxes]</li>
<li>将变型词(复数词，过去式)转化为词根。foxes → fox</li>
<li>针对每种语言特有的功能。例如：法语去发音：l’église → eglis</li>
</ul>
<h3 id="使用语言分析器-Using-Language-Analyzers"><a href="#使用语言分析器-Using-Language-Analyzers" class="headerlink" title="使用语言分析器(Using Language Analyzers)"></a>使用语言分析器(Using Language Analyzers)</h3><ul>
<li>默认分析器 standrad, Elasticsearch 的内置分析器都是全局可用的，不需要提前配置</li>
<li>每个分析器各有所长，通过multiField设置多个字段指定多个分析器</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"blog"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"english"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用most_field搜索</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/blog/1</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"I'm happy for this fox"</span> &#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/blog/2</span><br><span class="line">&#123; <span class="attr">"title"</span>: <span class="string">"I'm not happy about my fox problem"</span> &#125;</span><br><span class="line"></span><br><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:     <span class="string">"most_fields"</span>,</span><br><span class="line">      <span class="attr">"query"</span>:    <span class="string">"not happy foxes"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"title.english"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置语言分析器-Configuring-Language-Analyzers"><a href="#配置语言分析器-Configuring-Language-Analyzers" class="headerlink" title="配置语言分析器(Configuring Language Analyzers)"></a>配置语言分析器(Configuring Language Analyzers)</h3><p>根据自己需要配置语言分析器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_english"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"english"</span>,</span><br><span class="line">          <span class="attr">"stem_exclusion"</span>: [ <span class="string">"organization"</span>, <span class="string">"organizations"</span> ],</span><br><span class="line">          <span class="attr">"stopwords"</span>: [</span><br><span class="line">            <span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"and"</span>, <span class="string">"are"</span>, <span class="string">"as"</span>, <span class="string">"at"</span>, <span class="string">"be"</span>, <span class="string">"but"</span>, <span class="string">"by"</span>, <span class="string">"for"</span>,</span><br><span class="line">            <span class="string">"if"</span>, <span class="string">"in"</span>, <span class="string">"into"</span>, <span class="string">"is"</span>, <span class="string">"it"</span>, <span class="string">"of"</span>, <span class="string">"on"</span>, <span class="string">"or"</span>, <span class="string">"such"</span>, <span class="string">"that"</span>,</span><br><span class="line">            <span class="string">"the"</span>, <span class="string">"their"</span>, <span class="string">"then"</span>, <span class="string">"there"</span>, <span class="string">"these"</span>, <span class="string">"they"</span>, <span class="string">"this"</span>, <span class="string">"to"</span>,</span><br><span class="line">            <span class="string">"was"</span>, <span class="string">"will"</span>, <span class="string">"with"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze?analyzer=my_english</span><br><span class="line">The World Health Organization does not sell organs.</span><br></pre></td></tr></table></figure>

<ul>
<li>防止 organization 和 organizations 被缩减为词干</li>
<li>指定一个自定义停用词列表</li>
<li>切词为 world 、 health 、 organization 、 does 、 not 、 sell 、 organ</li>
</ul>
<h3 id="混合语言的陷阱-Pitfalls-of-Mixing-Languages"><a href="#混合语言的陷阱-Pitfalls-of-Mixing-Languages" class="headerlink" title="混合语言的陷阱(Pitfalls of Mixing Languages)"></a>混合语言的陷阱(Pitfalls of Mixing Languages)</h3><p>多语言文档类型：</p>
<ul>
<li>每份document(文档)有自己的主语言，并包含一些其他语言的片断</li>
<li>每个field(域)有自己的主语言，并包含一些其他语言的片断</li>
<li>每个field(域)都是混合语言</li>
</ul>
<p>同一份倒排索引内混合多种语言可能造成一些问题</p>
<ul>
<li>不合理的词干提取，不同语言提取词干规则不同</li>
<li>不正确的倒排文档频率，例如 英文文章中一个德语单词权重会变高</li>
<li>在搜索时，需要指定特定的语言</li>
<li>语言识别，通过语言识别工具包识别是哪一种语言</li>
</ul>
<h3 id="每份文档一种语言-One-Language-per-Document"><a href="#每份文档一种语言-One-Language-per-Document" class="headerlink" title="每份文档一种语言(One Language per Document)"></a>每份文档一种语言(One Language per Document)</h3><ul>
<li>不同的索引存放不同的语言文档</li>
<li>使用multi_match和indices_boost查询，可以指定不同语言的权重</li>
</ul>
<p>多语言的索引配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /blogs-en</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"post"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"stemmed"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">PUT /blogs-fr</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"post"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"stemmed"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"french"</span></span><br><span class="line">            &#125;</span><br><span class="line">&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用multi_match和indices_boost查询，可以指定不同语言的权重</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /blogs-*/post/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:   <span class="string">"deja vu"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>:  [ <span class="string">"title"</span>, <span class="string">"title.stemmed"</span> ],</span><br><span class="line">            <span class="attr">"type"</span>:    <span class="string">"most_fields"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"indices_boost"</span>: &#123;</span><br><span class="line">        <span class="attr">"blogs-en"</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">"blogs-fr"</span>: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每个域一种语言-One-Language-per-Field"><a href="#每个域一种语言-One-Language-per-Field" class="headerlink" title="每个域一种语言(One Language per Field)"></a>每个域一种语言(One Language per Field)</h3><p>每个字段对应一个语言类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"title"</span>:     <span class="string">"Fight club"</span>,</span><br><span class="line">   <span class="attr">"title_br"</span>:  <span class="string">"Clube de Luta"</span>,</span><br><span class="line">   <span class="attr">"title_cz"</span>:  <span class="string">"Klub rváčů"</span>,</span><br><span class="line">   <span class="attr">"title_en"</span>:  <span class="string">"Fight club"</span>,</span><br><span class="line">   <span class="attr">"title_es"</span>:  <span class="string">"El club de la lucha"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /movies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"movie"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"title_br"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"brazilian"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"title_cz"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"czech"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"title_en"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"title_es"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">            <span class="attr">"analyzer"</span>: <span class="string">"spanish"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>field-per-language 可以维持干净的词频，不能像index-per-language 那样灵活地分开索引。</li>
<li>field-per-language 可以方便添加新的field，先关闭索引再使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/indices-update-settings.html" target="_blank" rel="noopener">update-setting API</a>,重新打开索引。</li>
</ul>
<p>查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /movies/movie/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"club de la lucha"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [ <span class="string">"title*"</span>, <span class="string">"title_es^2"</span> ],</span><br><span class="line">            <span class="attr">"type"</span>:     <span class="string">"most_fields"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合语言域-Mixed-Language-Fields"><a href="#混合语言域-Mixed-Language-Fields" class="headerlink" title="混合语言域(Mixed-Language Fields)"></a>混合语言域(Mixed-Language Fields)</h3><ul>
<li>词干提取器是由语言具体决定的，或 词干提取器是由语言和脚本所具体决定的</li>
</ul>
<p>假设你的混合语言使用的是一样的脚本，例如拉丁文，你有三个可用的选择：</p>
<ul>
<li>切分到不同的域(field),使用语言识别工具吧不同的语言存放到不同的字段中。</li>
<li>进行多次分析，主字段存储一种语言，<code>子字段</code>存储其他多个语言到.</li>
<li>使用 n-grams,通过将单词拆成 n-grams，你有很大的机会匹配到相似但不完全一样的单词,结合 analyze-multiple times （多次分析）方法.</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /movies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"de"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"german"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"en"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"english"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"fr"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"french"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"es"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"analyzer"</span>: <span class="string">"spanish"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>fields.general中使用n-grams</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /movies</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    "analysis": &#123;...&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "title": &#123;</span><br><span class="line">      "properties": &#123;</span><br><span class="line">        "title": &#123;</span><br><span class="line">          "type": "string",</span><br><span class="line">          "fields": &#123;</span><br><span class="line">            "de": &#123;</span><br><span class="line">              "type":     "string",</span><br><span class="line">              "analyzer": "german"</span><br><span class="line">            &#125;,</span><br><span class="line">            "en": &#123;</span><br><span class="line">              "type":     "string",</span><br><span class="line">              "analyzer": "english"</span><br><span class="line">            &#125;,</span><br><span class="line">            "fr": &#123;</span><br><span class="line">              "type":     "string",</span><br><span class="line">              "analyzer": "french"</span><br><span class="line">            &#125;,</span><br><span class="line">            "es": &#123;</span><br><span class="line">              "type":     "string",</span><br><span class="line">              "analyzer": "spanish"</span><br><span class="line">            &#125;,</span><br><span class="line">            "general": &#123;</span><br><span class="line">              "type":     "string",</span><br><span class="line">              "analyzer": "trigrams"</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /movies/movie/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"club de la lucha"</span>,</span><br><span class="line">            <span class="attr">"fields"</span>: [ <span class="string">"title*^1.5"</span>, <span class="string">"title.general"</span> ],</span><br><span class="line">            <span class="attr">"type"</span>:     <span class="string">"most_fields"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03-处理人类语言-词汇识别</title>
    <url>/2020/01/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/21-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E8%AF%8D%E6%B1%87%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h3 id="Identifying-words-介绍"><a href="#Identifying-words-介绍" class="headerlink" title="Identifying_words 介绍"></a>Identifying_words 介绍</h3><p>没有处理所有人类语言的万能分析器，Elasticsearch 为很多语言提供了专用的分析器， 其他特殊语言的分析器以插件的形式提供。</p>
<a id="more"></a>
<h3 id="标准分析器-standard-Analyzer"><a href="#标准分析器-standard-Analyzer" class="headerlink" title="标准分析器(standard Analyzer)"></a>标准分析器(standard Analyzer)</h3><p>标准分析器是字段(field)的默认分析器。</p>
<p>自定义分析器,tokenizer(标准分词器)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"type"</span>:      <span class="string">"custom"</span>,</span><br><span class="line">    <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">    <span class="attr">"filter"</span>:  [ <span class="string">"lowercase"</span>, <span class="string">"stop"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="标准分词器-standard-Tokenizer"><a href="#标准分词器-standard-Tokenizer" class="headerlink" title="标准分词器(standard Tokenizer)"></a>标准分词器(standard Tokenizer)</h3><p>分词器处理过程：</p>
<ol>
<li>接受一个字符串(string)作为输入</li>
<li>将字符串拆分成独立的词(words)或语汇单元(tokens),可能会丢失一些标点符号等字符</li>
<li>输出一个语汇单元流(token stream)</li>
</ol>
<p>有趣的词汇识别算法：</p>
<ol>
<li>whitespace tokenizer (空白字符 分词器), 按空白字符(空格、tabs、换行符等等)进行简单拆分</li>
<li>letter tokenizer(letter分词器) : 按照任何非字符进行拆分</li>
<li>standard tokenizer(标准分词器) : 标准分词器使用unicode 文本分割算法寻找单词之间的界限，并输出索引界限之间的内容。 Unicode 内含的知识使其可以成功的对包含混合语言的文本进行分词。</li>
<li>uax_url_email tokenizer : 它能识别 email 地址和 URLs 并输出为单个语汇单元,standard tokenizer则不能区别。</li>
</ol>
<h3 id="安装ICU插件"><a href="#安装ICU插件" class="headerlink" title="安装ICU插件"></a>安装ICU插件</h3><p>Elasticsearch的 ICU 分析器插件使用 International Components for Unicode (ICU) 函数库（详情查看 site.project.org ）提供丰富的处理 Unicode 工具。<br>这些包含对处理亚洲语言特别有用的 icu_分词器 ，还有大量对除英语外其他语言进行正确匹配和排序所必须的分词过滤器。</p>
<ol>
<li>icu 地址 <a href="https://github.com/elasticsearch/elasticsearch-analysis-icu" target="_blank" rel="noopener">https://github.com/elasticsearch/elasticsearch-analysis-icu</a>.</li>
<li>./bin/plugin -install elasticsearch/elasticsearch-analysis-icu/$VERSION</li>
<li>重启ES</li>
</ol>
<h3 id="ICU-分词器"><a href="#ICU-分词器" class="headerlink" title="ICU 分词器"></a>ICU 分词器</h3><p>icu_分词器 和 标准分词器 使用同样的 Unicode 文本分段算法， 只是为了更好的支持亚洲语，添加了泰语、老挝语、中文、日文、和韩文基于词典的词汇识别方法，并且可以使用自定义规则将缅甸语和柬埔寨语文本拆分成音节。</p>
<h3 id="整理输入文本-Tidying-Up-Input-Text"><a href="#整理输入文本-Tidying-Up-Input-Text" class="headerlink" title="整理输入文本(Tidying Up Input Text)"></a>整理输入文本(Tidying Up Input Text)</h3><p>很多文本不是有效文本,比如html源码。在分词之前需要使用字符过滤器(Character filters)整理文本提升输出质量。</p>
<h5 id="html分词-Tokenizing-HTML"><a href="#html分词-Tokenizing-HTML" class="headerlink" title="html分词 (Tokenizing HTML)"></a>html分词 (Tokenizing HTML)</h5><p>配置字符过滤器(Character filters)到分析器中，分词之前做预处理。<br>使用html_strip 字符过滤器移除HTML标签 并把html实体(&eacute;) 转为一致的Unicode字符。</p>
<p>测试</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_analyze?tokenizer=standard&amp;char_filters=html_strip</span><br><span class="line">&lt;p&gt;Some d&amp;eacute;j&amp;agrave; vu &lt;a href="http://somedomain.com&gt;"&gt;website&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<p>映射配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"settings"</span>: &#123;</span><br><span class="line">        <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">            <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">                <span class="attr">"my_html_analyzer"</span>: &#123;</span><br><span class="line">                    <span class="attr">"tokenizer"</span>:     <span class="string">"standard"</span>,</span><br><span class="line">                    <span class="attr">"char_filter"</span>: [ <span class="string">"html_strip"</span> ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_html_analyzer</span><br><span class="line">&lt;p&gt;Some d&amp;eacute;j&amp;agrave; vu &lt;a href="http://somedomain.com&gt;"&gt;website&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h5 id="整理标点符号-Tidying-Up-Punctuation"><a href="#整理标点符号-Tidying-Up-Punctuation" class="headerlink" title="整理标点符号(Tidying Up Punctuation)"></a>整理标点符号(Tidying Up Punctuation)</h5><p>以用 mapping 对这些混乱的字符进行分类， 该过滤器可以运行我们用另一个字符替换所有实例中的一个字符。这种情况下，我们可以简单的用 U+0027 替换所有的撇号变体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"quotes"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"mapping"</span>,</span><br><span class="line">          <span class="attr">"mappings"</span>: [</span><br><span class="line">            <span class="string">"\\u0091=&gt;\\u0027"</span>,</span><br><span class="line">            <span class="string">"\\u0092=&gt;\\u0027"</span>,</span><br><span class="line">            <span class="string">"\\u2018=&gt;\\u0027"</span>,</span><br><span class="line">            <span class="string">"\\u2019=&gt;\\u0027"</span>,</span><br><span class="line">            <span class="string">"\\u201B=&gt;\\u0027"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"quotes_analyzer"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>:     <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"char_filter"</span>: [ <span class="string">"quotes"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=quotes_analyzer</span><br><span class="line">You’re my ‘favorite’ M‛Coy</span><br></pre></td></tr></table></figure>

<ul>
<li>我们自定义了一个 char_filter （字符过滤器）叫做 quotes ，提供所有撇号变体到简单撇号的映射。</li>
<li>为了更清晰，我们使用每个字符的 JSON Unicode 转义语句，当然我们也可以使用他们本身字符表示： “‘=&gt;’” 。</li>
<li>我们用自定义的 quotes 字符过滤器创建一个新的分析器叫做 quotes_analyzer 。</li>
</ul>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03-处理人类语言-归一化词元</title>
    <url>/2020/03/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/22-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E5%BD%92%E4%B8%80%E5%8C%96%E8%AF%8D%E5%85%83/</url>
    <content><![CDATA[<h3 id="归一化词元-Normalizing-Tokens"><a href="#归一化词元-Normalizing-Tokens" class="headerlink" title="归一化词元(Normalizing Tokens)"></a>归一化词元(Normalizing Tokens)</h3><ul>
<li>归一化(normalization)目的：为了让词元(token)更容易搜索.</li>
<li>归一化(normalization)作用：归一化过程会去除同一个词元(token)的无意义或有意义的差别。例如：大小写，有声调的词</li>
<li>语汇单元过滤器(token filters)的工作 ：语汇单元过滤器(token filters)接受来自分词器(tokenizer)的词元(token)流，多个语汇单元过滤器会依次处理词元，每个过滤器都可以处理来自另一个过滤器输出的单词流。</li>
</ul>
<a id="more"></a>
<h3 id="举个例子-In-That-Case"><a href="#举个例子-In-That-Case" class="headerlink" title="举个例子 In That Case"></a>举个例子 In That Case</h3><p>lowercase过滤器是常用的 语汇单元过滤器(token filter),它把字母变小写。<br>例如：FOX转换为fox，存储到索引中，那FOX和fox在索引中对应的是同一个词元(token)</p>
<p>查看例子</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_analyze?tokenizer=standard&amp;filters=lowercase</span><br><span class="line">The QUICK Brown FOX!</span><br></pre></td></tr></table></figure>
<p>自定义分析器(analyzer)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_lowercaser"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"lowercase"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_lowercaser</span><br><span class="line">The QUICK Brown FOX!</span><br></pre></td></tr></table></figure>

<h3 id="Removing-diacritics-如果有口音-You-Have-an-Accent"><a href="#Removing-diacritics-如果有口音-You-Have-an-Accent" class="headerlink" title="Removing_diacritics 如果有口音(You Have an Accent)"></a>Removing_diacritics 如果有口音(You Have an Accent)</h3><p>asciifolding filter作用：去掉变音符合并把Unicode字符转化为ASCII。</p>
<p>定义</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"folding"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"lowercase"</span>, <span class="string">"asciifolding"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index?analyzer=folding</span><br><span class="line">My œsophagus caused a débâcle</span><br></pre></td></tr></table></figure>
<h5 id="保留原意-Retaining-Meaning"><a href="#保留原意-Retaining-Meaning" class="headerlink" title="保留原意(Retaining Meaning)"></a>保留原意(Retaining Meaning)</h5><p>使用多次索引，一次索引保留变音符，一次索引去除变音符。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"title"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:           <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"analyzer"</span>:       <span class="string">"standard"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"folded"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>:   <span class="string">"folding"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:     <span class="string">"most_fields"</span>,</span><br><span class="line">      <span class="attr">"query"</span>:    <span class="string">"esta loca"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"title.folded"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用validate-query API查看执行情况。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_validate/query?explain</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:     <span class="string">"most_fields"</span>,</span><br><span class="line">      <span class="attr">"query"</span>:    <span class="string">"está loca"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: [ <span class="string">"title"</span>, <span class="string">"title.folded"</span> ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unicode的世界-Living-in-a-Unicode-World"><a href="#Unicode的世界-Living-in-a-Unicode-World" class="headerlink" title="Unicode的世界(Living in a Unicode World)"></a>Unicode的世界(Living in a Unicode World)</h3><p>遇到的问题：相同的单词使用了不同的编码，ES的词元(token)比较是在字节(byte)级别进行比较，Unicode中相同的字符可以用不同的字节表示。<br>解决方法：使用Unicode 归一化(Unicode normalization), 把Unicode字符转换成对应标准格式，把所有的字符进行字节(byte)级别的比较。</p>
<p>4种Unicode归一化形式：nfc,nfd,nfkc,nfkd<br>组合模式：</p>
<ol>
<li>组合形式(composed forms) : <code>nfc</code>和<code>nfkc</code>,用尽可能少的字节(byte)来代表字符. 用 <code>é</code> 来代表单个字母 <code>é</code> 。  </li>
<li>分解模式(decomposed forms）: <code>nfd</code> and <code>nfkd</code>, 用字符的每一部分来代表字符。所以 <code>é</code> 分解为 <code>e</code> 和 <code>´</code>。</li>
<li>规范模式(canonical forms) ：<code>nfc</code>和<code>nfd</code>,把连字作为单个字符。</li>
<li>兼容模式(compatibility forms): <code>nfkc</code>和<code>nfkd</code>，将这些组合的字符分解成简单字符的等价物，例如：f+f+i 或o+e</li>
</ol>
<p>无论选择哪一种模式，只要你的文本只用一种模式，那你的同一词元就会由相同的字节组成。</p>
<p>你可以使用 icu_normalizer 语汇单元过滤器(token filters) 来保证你的所有词元(token)是相同模式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"nfkc_normalizer"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"icu_normalizer"</span>,</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"nfkc"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_normalizer"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"icu_tokenizer"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"nfkc_normalizer"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Unicode-大小写折叠-Unicode-Case-Folding"><a href="#Unicode-大小写折叠-Unicode-Case-Folding" class="headerlink" title="Unicode 大小写折叠(Unicode Case Folding)"></a>Unicode 大小写折叠(Unicode Case Folding)</h3><p>在unicode中大小写折叠 (Case folding) 把单词转换到一种(通常是小写)形式，是让写法不会影响单词的比较，所以拼写不需要完全正确.<br>Unicode 大小写折叠适合所有的语言，而lowercasing则不行。</p>
<p>例如：德语小写单词 ß -变大写-&gt; SS , ß–变小写-&gt;ss</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_lowercaser"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"icu_tokenizer"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"icu_normalizer"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>icu_normalizer 默认是 nfkc_cf 模式.</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /_analyze?analyzer=standard</span><br><span class="line">Weißkopfseeadler WEISSKOPFSEEADLER</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze?analyzer=my_lowercaser</span><br><span class="line">Weißkopfseeadler WEISSKOPFSEEADLER</span><br></pre></td></tr></table></figure>
<ul>
<li>得到的词元(token)是 weißkopfseeadler, weisskopfseeadler</li>
<li>得到的词元(token)是 weisskopfseeadler, weisskopfseeadler</li>
<li><code>standard</code>分析器得到了两个不同且不可比较的词元(token)，而我们定制化的分析器得到了两个相同但是不符合原意的词元(token)。</li>
</ul>
<h3 id="Unicode-字符折叠"><a href="#Unicode-字符折叠" class="headerlink" title="Unicode 字符折叠"></a>Unicode 字符折叠</h3><p>Unicode character-folding可以有效地处理世界各种语言。<br><code>icu_folding</code> token filters的功能和 <code>asciifolding</code> 过滤器一样，但是它扩展到了非ASCII编码的语言，它把这些语言都转换对应拉丁文字，甚至包含它们的各种各样的计数符号，象形符号和标点符号。例如：希腊语，希伯来语，汉语。<br><code>icu_folding</code> 语汇单元过滤器(token filters)自动使用 <code>nfkc_cf</code> 模式来进行大小写折叠和Unicode归一化(normalization)，所以不需要使用 <code>icu_normalizer</code> ：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_folder"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"icu_tokenizer"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"icu_folding"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>阿拉伯数字 ١٢٣٤٥ 被折叠成等价的拉丁数字: 12345.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_folder</span><br><span class="line">١٢٣٤٥</span><br></pre></td></tr></table></figure>

<p>指定那些unicode不被折叠，例如[^åäöÅÄÖ] (^ 表示 不包含)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"swedish_folding"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"icu_folding"</span>,</span><br><span class="line">          <span class="attr">"unicodeSetFilter"</span>: <span class="string">"[^åäöÅÄÖ]"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"swedish_analyzer"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"icu_tokenizer"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"swedish_folding"</span>, <span class="string">"lowercase"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="排序和整理-Sorting-and-Collations"><a href="#排序和整理-Sorting-and-Collations" class="headerlink" title="排序和整理(Sorting and Collations)"></a>排序和整理(Sorting and Collations)</h3><p>多语言排序会面临很多问题，语言之间的差别，每个语言排序不同。</p>
<h5 id="unicode-归类算法-Unicode-Collation-Algorithm"><a href="#unicode-归类算法-Unicode-Collation-Algorithm" class="headerlink" title="unicode 归类算法(Unicode Collation Algorithm)"></a>unicode 归类算法(Unicode Collation Algorithm)</h5><ul>
<li>Unicode归类将文本按照定义好顺序进行排序的过程。</li>
<li>Unicode归类算法(Unicode Collation Algorithm 简称UCA) ，UCA 定义了一种将字符串按照在归类单元表中定义的顺序排序的方法（通常称为排序规则）。</li>
<li>UCA 还定义了 默认 Unicode 排序规则元素表(Default Unicode Collation Element Table，简称 DUCET) 。</li>
<li>DUCET 为无论任何语言的所有 Unicode 字符定义了默认排序。每种语言都有自己的排序规则，大多时候用DUCET作为起点并添加一些自定义规则。</li>
</ul>
<p>icu_collation token filter默认使用DUCET排序规则。<br>定义unicode排序规则</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"ducet_sort"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"keyword"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [ <span class="string">"icu_collation"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用多字段进行多次索引</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/user</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"sort"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"ducet_sort"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询name.sort</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/user/_search?sort=name.sort</span><br></pre></td></tr></table></figure>

<h5 id="指定语言"><a href="#指定语言" class="headerlink" title="指定语言"></a>指定语言</h5><p>icu_collation指定语言<br>PUT /my_index<br>{<br>  “settings”: {<br>    “number_of_shards”: 1,<br>    “analysis”: {<br>      “filter”: {<br>        “german_phonebook”: {<br>          “type”:     “icu_collation”,<br>          “language”: “de”,<br>          “country”:  “DE”,<br>          “variant”:  “@collation=phonebook”<br>        }<br>      },<br>      “analyzer”: {<br>        “german_phonebook”: {<br>          “tokenizer”: “keyword”,<br>          “filter”:  [ “german_phonebook” ]<br>        }<br>      }<br>    }<br>  },<br>  “mappings”: {<br>    “user”: {<br>      “properties”: {<br>        “name”: {<br>          “type”: “string”,<br>          “fields”: {<br>            “sort”: {<br>              “type”:     “string”,<br>              “analyzer”: “german_phonebook”<br>            }<br>          }<br>        }<br>      }<br>    }<br>  }<br>}</p>
<h5 id="多排序规则"><a href="#多排序规则" class="headerlink" title="多排序规则"></a>多排序规则</h5><p>使用多字段进行多次索引，每个字段对应一个语言。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/_user</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"default"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"ducet"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"french"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"french"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"german"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"german_phonebook"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"swedish"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"swedish"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="自定义排序"><a href="#自定义排序" class="headerlink" title="自定义排序"></a>自定义排序</h5><p>icu_collation分词过滤器可以提供很多选项</p>
<ol>
<li>定制排序算法：language、country、varinat</li>
<li>忽略变音符号</li>
<li>顺序大写排先或排后，或忽略大小写</li>
<li>考虑或忽略标点符号和空白</li>
<li>将数字按照字符串或数字值排序</li>
<li>自定义现有归类或定义自己的归类</li>
</ol>
<p>###<br>参考地址：</p>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/token-normalization.html" target="_blank" rel="noopener">中文</a></li>
<li><a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/master/220_Token_normalization" target="_blank" rel="noopener">英文</a></li>
</ul>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03-处理人类语言-将单词还原为词根</title>
    <url>/2020/03/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/23-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E5%B0%86%E5%8D%95%E8%AF%8D%E8%BF%98%E5%8E%9F%E4%B8%BA%E8%AF%8D%E6%A0%B9/</url>
    <content><![CDATA[<h3 id="将单词还原为词根-Reducing-Words-to-Their-Root-Form"><a href="#将单词还原为词根-Reducing-Words-to-Their-Root-Form" class="headerlink" title="将单词还原为词根(Reducing Words to Their Root Form)"></a>将单词还原为词根(Reducing Words to Their Root Form)</h3><ul>
<li>大多数语言的单词都可以 词形变化。</li>
<li>词根提取(Stemming) ：试图移除单词的变化形式之间的差别，将每个单词都提取为它的词根形式。有的词根不是一个真的单词.</li>
<li>词根提取遇到的两个问题：词干弱提取(understemming)，词干过度提取(overstemming)</li>
<li>词干弱提取(understemming): 无法将同样意思的单词缩减为同一个词根。弱词干提取会导致搜索时无法返回相关文档。</li>
<li>词根过渡提取(overstemming):无法将不同含义的单词分开。词干过度提取会降低精准度：不相干的文档会在不需要他们返回的时候返回。</li>
<li>ES提供两个经典词干提取器：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/algorithmic-stemmers.html" target="_blank" rel="noopener">词干提取算法</a>,<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/dictionary-stemmers.html" target="_blank" rel="noopener">字典词干提取器</a></li>
<li>词形还原：</li>
</ul>
<a id="more"></a>
<p>词形变化：</p>
<ul>
<li>单复数变化(Number) ： fox 、foxes</li>
<li>时态变化(Tense) ： pay 、 paid 、 paying</li>
<li>性别变化(Gender) ： waiter 、 waitress</li>
<li>动词人称变化(Person) ： hear 、 hears</li>
<li>代词变化(Case) ： I 、 me 、 my</li>
<li>不规则变化(Aspect) ： ate 、 eaten</li>
<li>情景变化(Mood) ： so be it 、 were it so</li>
</ul>
<h3 id="词干提取算法-Algorithmic-Stemmers"><a href="#词干提取算法-Algorithmic-Stemmers" class="headerlink" title="词干提取算法(Algorithmic Stemmers)"></a>词干提取算法(Algorithmic Stemmers)</h3><p>词干提取器(stemmer) : 大部分词干提取器是基于算法的，提供一系列规则将词提取为词干。<br>基于算法的提取器<br>优点：作为插件使用，速度快，占用内存少，有规律的单词处理效果好。<br>缺点：没规律的单词效果不好</p>
<p>最早的英文词干提取器是 Porter stemmer. 现在仍然推荐。<br>kstem token filter 是一款合并了词干提取算法和内置词典的英语分词过滤器。<br>所有基于算法的词干提取器都暴露了用来接受 语言 参数的统一接口： stemmer token filter 。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"english_stop"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"stop"</span>,</span><br><span class="line">          <span class="attr">"stopwords"</span>:  <span class="string">"_english_"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"light_english_stemmer"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"stemmer"</span>,</span><br><span class="line">          <span class="attr">"language"</span>:   <span class="string">"light_english"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"english_possessive_stemmer"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"stemmer"</span>,</span><br><span class="line">          <span class="attr">"language"</span>:   <span class="string">"possessive_english"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"english"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>:  <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"english_possessive_stemmer"</span>,</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"english_stop"</span>,</span><br><span class="line">            <span class="string">"light_english_stemmer"</span>,</span><br><span class="line">            <span class="string">"asciifolding"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>english 分析器使用了两个词干提取器： possessive_english 词干提取器和 english 词干提取器。 所有格词干提取器会在任何词传递到 english_stop 、 english_keywords 和 english_stemmer 之前去除 ‘s 。</li>
<li>light_english 词干提取器: 非激进的 kstem 分词过滤器的映射</li>
<li>asciifolding 分词过滤器用以移除外语的附加符号。</li>
</ul>
<h3 id="字典词干提取器-Dictionary-Stemmers"><a href="#字典词干提取器-Dictionary-Stemmers" class="headerlink" title="字典词干提取器(Dictionary Stemmers)"></a>字典词干提取器(Dictionary Stemmers)</h3><ul>
<li>字典词干提取器只是简单地在字典里查找词</li>
<li>字典词干提取器可以：<ul>
<li>返回不规则形式如 feet 和 mice 的正确词干</li>
<li>区分出词形相似但词义不同的情形，比如 organ and organization</li>
</ul>
</li>
</ul>
<p>实践中一个好的算法化词干提取器一般优于一个字典词干提取器。<br>原因如下：</p>
<ol>
<li>字典质量。词的含义随时光变迁，字典需要保持最新，对于字典中不存在的词无能为力。</li>
<li>大小与性能。字典词干提取器需要加载所有词汇、前缀、后缀到内存中。</li>
</ol>
<h3 id="Hunspell词干提取器-Hunspell-Stemmer"><a href="#Hunspell词干提取器-Hunspell-Stemmer" class="headerlink" title="Hunspell词干提取器(Hunspell Stemmer)"></a>Hunspell词干提取器(Hunspell Stemmer)</h3><p>Hunspell词干提取器是基于词典的，众多其它开源项目都在使用的拼写检查器。地址：hunspell.github.io</p>
<p>Hunspell 词典由两个文件：</p>
<ul>
<li>.dic : 包含所有词根，采用字母顺序，再加上一个代表所有可能前缀和后缀的代码表 【集体称之为词缀( affixes 】</li>
<li>.aff : 包含实际 .dic 文件每一行代码表对应的前缀和后缀转换</li>
</ul>
<h5 id="安装一个字典"><a href="#安装一个字典" class="headerlink" title="安装一个字典"></a>安装一个字典</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">config/</span><br><span class="line">  └ hunspell/</span><br><span class="line">      └ en_US/</span><br><span class="line">          ├ en_US.dic</span><br><span class="line">          ├ en_US.aff</span><br><span class="line">          └ settings.yml</span><br></pre></td></tr></table></figure>

<h5 id="按语言设置"><a href="#按语言设置" class="headerlink" title="按语言设置"></a>按语言设置</h5><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">ignore_case</span>:          <span class="string">true //Hunspell 目录默认是区分大小写的</span></span><br><span class="line"><span class="attr">strict_affix_parsing</span>: <span class="string">true //strict_affix_parsing 为 false 来告诉 Lucene 忽略错误的规则</span></span><br></pre></td></tr></table></figure>

<p>添加自定义词典 custom.dic</p>
<h5 id="创建一个Humspell语汇单元过滤器"><a href="#创建一个Humspell语汇单元过滤器" class="headerlink" title="创建一个Humspell语汇单元过滤器"></a>创建一个Humspell语汇单元过滤器</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"en_US"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"hunspell"</span>,</span><br><span class="line">          <span class="attr">"language"</span>: <span class="string">"en_US"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"en_US"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>:  <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:   [ <span class="string">"lowercase"</span>, <span class="string">"en_US"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=en_US</span><br><span class="line">reorganizes</span><br><span class="line"></span><br><span class="line">GET /_analyze?analyzer=english</span><br><span class="line">reorganizes</span><br></pre></td></tr></table></figure>

<h5 id="Hunspell-词典格式"><a href="#Hunspell-词典格式" class="headerlink" title="Hunspell 词典格式"></a>Hunspell 词典格式</h5><h3 id="选择一个词干提取器"><a href="#选择一个词干提取器" class="headerlink" title="选择一个词干提取器"></a>选择一个词干提取器</h3><p>英语词干提取器：</p>
<ul>
<li>english: porter_stem​ 语汇单元过滤器（token filter）。</li>
<li>light_english : kstem 语汇单元过滤器（token filter）。</li>
<li>minimal_english : Lucene 里面的 EnglishMinimalStemmer ，用来移除复数。</li>
<li>lovins : 基于 Snowball 的 Lovins 提取器, 第一个词干提取器。</li>
<li>porter : 基于 Snowball 的 Porter 提取器。</li>
<li>porter2 : 基于 Snowball 的 Porter2 提取器。</li>
<li>possessive_english : Lucene 里面的 EnglishPossessiveFilter ，移除 ‘s</li>
<li>Hunspell : 基于词典的提取器</li>
</ul>
<p>词干提取问题：弱提取，过度提取</p>
<p>考虑词干提取器3个因素：</p>
<ul>
<li>性能：例如：算法提取器一般来说比 Hunspell 提取器快4到5倍。</li>
<li>质量：提取器各有优缺点，词典提取器取决于词典好坏，对词典中没有的词无法识别，可以精确识别不规则词语；算法提取器优点：性能好，可以识别新词，但无法精确识别不规则词语。</li>
<li>程度：不同的词干提取器会将词弱提取或过度提取到一定的程度。需要什么程度的提取要取决你的场景。比如：聚类算法需要提前力度更大点，匹配更广泛一点；面向最终用户，轻量提取会产生更好结果；文档大小，文档小力度大些，匹配的文档会多，反之文档大轻量的弱提取，匹配更准确。</li>
</ul>
<h3 id="控制词干提取"><a href="#控制词干提取" class="headerlink" title="控制词干提取"></a>控制词干提取</h3><ul>
<li>通过 keyword_marker和stemmer_override 自定义词干提取过程</li>
</ul>
<h5 id="阻止词干提取"><a href="#阻止词干提取" class="headerlink" title="阻止词干提取"></a>阻止词干提取</h5><p>两种方法：</p>
<ol>
<li>语言分析器中 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/configuring-language-analyzers.html#stem-exclusion" target="_blank" rel="noopener">stem_exclusion</a> 指定词语列表，让他们不被词干提取。</li>
<li>语言分析器使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-keyword-marker-tokenfilter.html" target="_blank" rel="noopener">keyword_marker 语汇单元过滤器</a> 来标记这些词语列表为 keywords ，用来阻止后续的词干提取过滤器来触碰这些词语。</li>
</ol>
<p>配置keyword_marker</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">UT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"no_stem"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"keyword_marker"</span>,</span><br><span class="line">          <span class="attr">"keywords"</span>: [ <span class="string">"skies"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_english"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"no_stem"</span>,</span><br><span class="line">            <span class="string">"porter_stem"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>keywords_path 参数允许我们将所有的关键字存在一个文件。 这个文件应该是每行一个字，并且存在于集群的每个节点。</p>
<p>使用 analyze API 来测试</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=my_english</span><br><span class="line">sky skies skiing skis</span><br></pre></td></tr></table></figure>

<h5 id="自定义提取"><a href="#自定义提取" class="headerlink" title="自定义提取"></a>自定义提取</h5><p>使用<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stemmer-override-tokenfilter.html" target="_blank" rel="noopener">stemmer_override</a> 语汇单元过滤器允许我们指定自定义的提取规则。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"custom_stem"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"stemmer_override"</span>,</span><br><span class="line">          <span class="attr">"rules"</span>: [</span><br><span class="line">            <span class="string">"skies=&gt;sky"</span>,</span><br><span class="line">            <span class="string">"mice=&gt;mouse"</span>,</span><br><span class="line">            <span class="string">"feet=&gt;foot"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_english"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"custom_stem"</span>,</span><br><span class="line">            <span class="string">"porter_stem"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze?analyzer=my_english</span><br><span class="line">The mice came down from the skies and ran over my feet</span><br></pre></td></tr></table></figure>
<ul>
<li>rules 规则来自 original=&gt;stem 。</li>
<li>custom_stem : stemmer_override 过滤器必须放置在词干提取器之前。</li>
<li>规则可以被存放在一个文件中，参数 rules_path来指定位置。</li>
</ul>
<h3 id="原形词干提取"><a href="#原形词干提取" class="headerlink" title="原形词干提取"></a>原形词干提取</h3><p>如何将已提取词干的词和原词索引到同一个字段中。</p>
<ol>
<li>使用keyword_repeat过滤器提去词干的原形词</li>
<li>使用unique 语汇单元过滤器 去除重复原形词</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"unique_stem"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"unique"</span>,</span><br><span class="line">          <span class="attr">"only_on_same_position"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"in_situ"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"keyword_repeat"</span>,</span><br><span class="line">            <span class="string">"porter_stem"</span>,</span><br><span class="line">            <span class="string">"unique_stem"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pos 1: (the)</span><br><span class="line">Pos 2: (quick)</span><br><span class="line">Pos 3: (foxes,fox)</span><br><span class="line">Pos 4: (jumped,jump)</span><br></pre></td></tr></table></figure>

<ul>
<li>设置 unique 类型语汇单元过滤器，是为了只有当重复语汇单元出现在相同位置时，移除它们。</li>
<li>语汇单元过滤器必须出现在词干提取器之前。</li>
<li>unique_stem 过滤器是在词干提取器完成之后移除重复词项。</li>
</ul>
<h5 id="原形词干提取是个好主意吗"><a href="#原形词干提取是个好主意吗" class="headerlink" title="原形词干提取是个好主意吗"></a>原形词干提取是个好主意吗</h5><p>答案：原形词干提取不是个好主意。原因有两个：</p>
<ol>
<li>无法区分精准匹配和非精准匹配。</li>
<li>与提取词干的形式相比，降低了的IDF值。</li>
</ol>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>230_Stemming<br><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/stemming.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/stemming.html</a><br><a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/master/230_Stemming" target="_blank" rel="noopener">https://github.com/elastic/elasticsearch-definitive-guide/tree/master/230_Stemming</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03-处理人类语言-同义词</title>
    <url>/2020/03/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/25-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E5%90%8C%E4%B9%89%E8%AF%8D/</url>
    <content><![CDATA[<h3 id="同义词-Synonyms"><a href="#同义词-Synonyms" class="headerlink" title="同义词(Synonyms)"></a>同义词(Synonyms)</h3><ul>
<li>词干提取是通过简化他们的词根形式来扩大搜索的范围，同义词 通过相关的观念和概念来扩大搜索范围。</li>
<li>同义词也应该只在必要的时候使用,大规模使用同义词会导致查询结果趋向于让人觉得是随机的.</li>
<li>同义词似乎是一个简单的概念，但是正确的使用它们却是非常困难的。</li>
<li>同义词的字段不应该被单独使用，而应该与一个针对主字段的查询操作一起使用，这个主字段应该包含纯净格式的原始文本。</li>
</ul>
<a id="more"></a>
<h3 id="使用同义词-Using-Synonyms"><a href="#使用同义词-Using-Synonyms" class="headerlink" title="使用同义词(Using Synonyms)"></a>使用同义词(Using Synonyms)</h3><ul>
<li>同义词替换 使用同义词过滤器<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-synonym-tokenfilter.html" target="_blank" rel="noopener">synonym token filter</a></li>
<li>同义词可以使用synonyms或synonyms_path 指定</li>
<li>在索引和搜索中使用相同的同义词语汇单元过滤器是多余的。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_synonym_filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"synonym"</span>,</span><br><span class="line">          <span class="attr">"synonyms"</span>: [</span><br><span class="line">            <span class="string">"british,english"</span>,</span><br><span class="line">            <span class="string">"queen,monarch"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_synonyms"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"my_synonym_filter"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用analyze API 来测试</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;my_index&#x2F;_analyze?analyzer&#x3D;my_synonyms</span><br><span class="line">Elizabeth is the English queen</span><br><span class="line"></span><br><span class="line">Pos 1: (elizabeth)</span><br><span class="line">Pos 2: (is)</span><br><span class="line">Pos 3: (the)</span><br><span class="line">Pos 4: (british,english)</span><br><span class="line">Pos 5: (queen,monarch)</span><br></pre></td></tr></table></figure>

<h3 id="同义词格式-Formatting-Synonyms"><a href="#同义词格式-Formatting-Synonyms" class="headerlink" title="同义词格式(Formatting Synonyms)"></a>同义词格式(Formatting Synonyms)</h3><p>同义词表达式两种形式：</p>
<ol>
<li>用逗号分割，例如：”jump,leap,hop”</li>
<li>用=&gt; 表示，例如： “u s a,united states,united states of america =&gt; usa”</li>
</ol>
<p>匹配规则：如果多个规则指定同一个同义词，它们将被合并在一起，且顺序无关，否则使用最长匹配。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;united states            &#x3D;&gt; usa&quot;,</span><br><span class="line">&quot;united states of america &#x3D;&gt; usa&quot;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果规则冲突 ，<code>united states of america</code>转换为<code>usa</code> <code>of</code> <code>america</code></li>
<li>如果规则不冲突，<code>united states of america</code>转换为<code>usa</code></li>
</ol>
<h3 id="扩展或收缩-Expand-or-contract"><a href="#扩展或收缩-Expand-or-contract" class="headerlink" title="扩展或收缩(Expand or contract)"></a>扩展或收缩(Expand or contract)</h3><p>通过 简单扩展 、 简单收缩 、或 类型扩展 来指明同义词规则.<br>本节对三者进行比较。</p>
<h5 id="简单扩展-Simple-Expansion"><a href="#简单扩展-Simple-Expansion" class="headerlink" title="简单扩展(Simple Expansion)"></a>简单扩展(Simple Expansion)</h5><ul>
<li>简单扩展: 把同义词列表中的任意一个词扩展成同义词列表</li>
<li>简单扩展可以应用在索引或查询阶段</li>
</ul>
<table>
<thead>
<tr>
<th align="left">特点</th>
<th align="left">索引</th>
<th align="left">查询</th>
</tr>
</thead>
<tbody><tr>
<td align="left">索引的大小</td>
<td align="left">⬇︎ 大索引。因为所有的同义词都会被索引，所以索引的大小相对会变大一些。</td>
<td align="left">正常大小</td>
</tr>
<tr>
<td align="left">关联</td>
<td align="left">⬇︎ 所有同义词都有相同的 IDF，这意味着通用的词和较常用的词都拥有着相同的权重。</td>
<td align="left">每个同义词 IDF 都和原来一样。</td>
</tr>
<tr>
<td align="left">性能</td>
<td align="left">查询只需要找到查询字符串中指定单个词项。</td>
<td align="left">⬇︎ 对一个词项的查询重写来查找所有的同义词，这样会降低性能。</td>
</tr>
<tr>
<td align="left">灵活性</td>
<td align="left">⬇︎ 同义词规则不能改变现有的文件。对于有影响的新规则，现有的文件都要重建</td>
<td align="left">⬆︎ 同义词规则可以更新不需要索引文件。</td>
</tr>
</tbody></table>
<h5 id="简单收缩"><a href="#简单收缩" class="headerlink" title="简单收缩"></a>简单收缩</h5><ul>
<li>简单收缩 ，把左边的多个同义词映射到了右边的一个词。</li>
<li>它必须同时应用于索引和查询阶段，以确保查询词项映射到索引中存在的同一个值。<br>例如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;leap,hop &#x3D;&gt; jump&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>优缺点：</p>
<ul>
<li>索引的大小 ： ⬆︎ 索引大小是正常的，因为只有单一词项被索引。</li>
<li>关联 ： ⬇︎ 所有词项的 IDF 是一样的，所以你不能区分比较常用的词、不常用的单词。</li>
<li>性能： ⬆︎ 查询只需要在索引中找到单词的出现。</li>
<li>灵活性 ：⬆︎ 新同义词可以添加到规则的左侧并在查询阶段使用。例如：添加’bound’后：<code>&quot;leap,hop,bound =&gt; jump&quot;</code>,修改一下兼容旧数据<code>&quot;leap,hop,bound =&gt; jump,bound&quot;</code>。你需要重建索引文件，恢复到上面的规则（leap,hop,bound =&gt; jump ）来获得查询单个词项的性能优势。</li>
</ul>
<h5 id="类型扩展"><a href="#类型扩展" class="headerlink" title="类型扩展"></a>类型扩展</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cat    &#x3D;&gt; cat,pet&quot;,</span><br><span class="line">&quot;kitten &#x3D;&gt; kitten,cat,pet&quot;,</span><br><span class="line">&quot;dog    &#x3D;&gt; dog,pet&quot;</span><br><span class="line">&quot;puppy  &#x3D;&gt; puppy,dog,pet&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>类型扩展：扩大了词的意义，使被拓展的词更为通用。</li>
<li>类型扩展在索引阶段使用，例如：查询一个 cat 会找到关于 kittens 和 cats 的文档。</li>
<li>类型扩展在查询阶段使用，例如：kitten 的查询结果就会被拓展成涉及到 kittens、cats、dogs。</li>
<li>索引阶段应用类型扩展，查询阶段不采用同义词。</li>
</ul>
<h3 id="同义词和分析链"><a href="#同义词和分析链" class="headerlink" title="同义词和分析链"></a>同义词和分析链</h3><p>分析链如下： standard tokenizer –&gt; lowercase token filter –&gt; synonym token filter<br>例如’U.S.A’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">original string（原始文本）                       → &quot;U.S.A.&quot;</span><br><span class="line">standard           tokenizer（分词器）            → (U),(S),(A)</span><br><span class="line">lowercase          token filter（语汇单元过滤器）  → (u),(s),(a)</span><br><span class="line">synonym            token filter（语汇单元过滤器）  → (usa)</span><br></pre></td></tr></table></figure>
<p>将同义词过滤器放置在词根过滤器之后更简洁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;leap &#x3D;&gt; jump&quot;</span><br></pre></td></tr></table></figure>

<h5 id="大小写敏感的同义词"><a href="#大小写敏感的同义词" class="headerlink" title="大小写敏感的同义词"></a>大小写敏感的同义词</h5><p>对应对大小写敏感的同义词，定义特定的同义词规则。<br>大小写敏感的规则：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">"CAT,CAT scan           =&gt; cat_scan"</span></span><br><span class="line"><span class="string">"PET,PET scan           =&gt; pet_scan"</span></span><br><span class="line"><span class="string">"Johnny Little,J Little =&gt; johnny_little"</span></span><br><span class="line"><span class="string">"Johnny Small,J Small   =&gt; johnny_small"</span></span><br></pre></td></tr></table></figure>
<p>大小写不敏感的规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;cat                    &#x3D;&gt; cat,pet&quot;</span><br><span class="line">&quot;dog                    &#x3D;&gt; dog,pet&quot;</span><br><span class="line">&quot;cat scan,cat_scan scan &#x3D;&gt; cat_scan&quot;</span><br><span class="line">&quot;pet scan,pet_scan scan &#x3D;&gt; pet_scan&quot;</span><br><span class="line">&quot;little,small&quot;</span><br></pre></td></tr></table></figure>

<h3 id="多词同义词和短语查询"><a href="#多词同义词和短语查询" class="headerlink" title="多词同义词和短语查询"></a>多词同义词和短语查询</h3><p>多词同义词会严重破坏词的位置信息，尤其当新增的同义词标记长度各不相同的时候。</p>
<h5 id="使用简单收缩进行短语查询"><a href="#使用简单收缩进行短语查询" class="headerlink" title="使用简单收缩进行短语查询"></a>使用简单收缩进行短语查询</h5><p>使用简单收缩，把多个同义词用单个词表示，查询时需要针对单个词查询</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_synonym_filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"synonym"</span>,</span><br><span class="line">          <span class="attr">"synonyms"</span>: [</span><br><span class="line">            <span class="string">"united states,u s a,united states of america=&gt;usa"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_synonyms"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"my_synonym_filter"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze?analyzer=my_synonyms</span><br><span class="line">The United States is wealthy</span><br></pre></td></tr></table></figure>
<h5 id="同义词与query-string查询"><a href="#同义词与query-string查询" class="headerlink" title="同义词与query_string查询"></a>同义词与query_string查询</h5><p>本书很少谈论到 query_string 查询，因为真心不推荐你用它。</p>
<h3 id="符号同义词"><a href="#符号同义词" class="headerlink" title="符号同义词"></a>符号同义词</h3><ul>
<li>符号同义词是用别名来表示这个符号，以防止它在分词过程中被误认为是不重要的标点符号而被移除。</li>
<li>怎么处理符号同义词？分词之前替换符号成单词。</li>
<li>映射mapping 字符过滤器是个非常有用的过滤器，它可以用来对一些已有的字词进行替换操作， 你如果想要采用更灵活的正则表达式去替换字词的话，那你可以使用 pattern_replace 字符过滤器。</li>
</ul>
<p>虽然绝大多数情况下，符号对于全文搜索而言都无关紧要，但是字符组合而成的表情，或许又会是很有意义的东西。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我很高兴能在星期天工作 :( （注：难过的表情）</span><br></pre></td></tr></table></figure>
<ol>
<li>先使用 映射字符过滤器</li>
<li>在文本被递交给分词器处理之前， 把字符表情替换成符号同义词 emoticon_happy 或者 emoticon_sad</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"char_filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"emoticons"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"mapping"</span>,</span><br><span class="line">          <span class="attr">"mappings"</span>: [</span><br><span class="line">            <span class="string">":)=&gt;emoticon_happy"</span>,</span><br><span class="line">            <span class="string">":(=&gt;emoticon_sad"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_emoticons"</span>: &#123;</span><br><span class="line">          <span class="attr">"char_filter"</span>: <span class="string">"emoticons"</span>,</span><br><span class="line">          <span class="attr">"tokenizer"</span>:   <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:    [ <span class="string">"lowercase"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">GET /my_index/_analyze?analyzer=my_emoticons</span><br><span class="line">I am :) not :(</span><br></pre></td></tr></table></figure>



<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>03-处理人类语言-停用词：性能与精度</title>
    <url>/2020/03/13/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/24-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E5%81%9C%E7%94%A8%E8%AF%8D-%E6%80%A7%E8%83%BD%E4%B8%8E%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<h3 id="停用词：性能与精度-Stopwords-Performance-Versus-Precision"><a href="#停用词：性能与精度-Stopwords-Performance-Versus-Precision" class="headerlink" title="停用词：性能与精度(Stopwords: Performance Versus Precision)"></a>停用词：性能与精度(Stopwords: Performance Versus Precision)</h3><p>两组被过滤的词：</p>
<ul>
<li>低频词(Low-frequency terms) : 在文档集合中相对出现较少的词，因为它们稀少，所以它们的权重值更高。</li>
<li>高频词(High-frequcncy terms) : 在索引下的文档集合中出现较多的常用词，例如 the、and、和<code>is</code>。 这些词的权重小，对相关度评分影响不大。</li>
</ul>
<a id="more"></a>
<p>英语中停用词通常在索引前就别过滤掉，对检索负面影响不大。</p>
<h3 id="停用词的优缺点"><a href="#停用词的优缺点" class="headerlink" title="停用词的优缺点"></a>停用词的优缺点</h3><p>优点：占用空间小，搜索性能高<br>缺点：降低搜索某些语句的能力</p>
<h3 id="使用停用词"><a href="#使用停用词" class="headerlink" title="使用停用词"></a>使用停用词</h3><ul>
<li>移除停用词的工作是由 stop 停用词过滤器完成的</li>
<li>可以通过创建自定义的分析器来使用它</li>
</ul>
<p>下面分析器内部预置了停用词过滤器：</p>
<ul>
<li>语言分析器 ： 每个语言分析器默认使用与该语言相适的停用词列表</li>
<li>standard 标准分析器：默认使用空的停用词列表：<code>_none_</code> ，实际上是禁用了停用词。</li>
<li>pattern 模式分析器:默认使用空的停用词列表：为 <code>_none_</code> ，与 standard 分析器类似。</li>
</ul>
<h5 id="停用词和标准分析器（Stopwords-and-the-Standard-Analyzer）"><a href="#停用词和标准分析器（Stopwords-and-the-Standard-Analyzer）" class="headerlink" title="停用词和标准分析器（Stopwords and the Standard Analyzer）"></a>停用词和标准分析器（Stopwords and the Standard Analyzer）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_analyzer"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"stopwords"</span>: [ <span class="string">"and"</span>, <span class="string">"the"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="保持位置（Maintaining-Positions）"><a href="#保持位置（Maintaining-Positions）" class="headerlink" title="保持位置（Maintaining Positions）"></a>保持位置（Maintaining Positions）</h5><p>保留停用词和移除停用词，对其他词汇单元的位置保持不变。</p>
<h5 id="指定停用词-Specifying-Stopwords"><a href="#指定停用词-Specifying-Stopwords" class="headerlink" title="指定停用词(Specifying Stopwords)"></a>指定停用词(Specifying Stopwords)</h5><p>使用stopwords指定停用词，可以指定停用词数组，也可以通过 <code>_lang_</code> 默认停用词。</p>
<p>语言相关停用词列表 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/analysis-stop-tokenfilter.html" target="_blank" rel="noopener">stop 停用词过滤器​</a></p>
<p>可以特殊列表 <code>_none_</code> 来禁用。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_english"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:      <span class="string">"english"</span>,</span><br><span class="line">          <span class="attr">"stopwords"</span>: <span class="string">"_none_"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 stopwords_path 参数设置停用词文件路径。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_english"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:           <span class="string">"english"</span>,</span><br><span class="line">          <span class="attr">"stopwords_path"</span>: <span class="string">"stopwords/english.txt"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用停用词过滤器（Using-the-stop-Token-Filter）"><a href="#使用停用词过滤器（Using-the-stop-Token-Filter）" class="headerlink" title="使用停用词过滤器（Using the stop Token Filter）"></a>使用停用词过滤器（Using the stop Token Filter）</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"spanish_stop"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:        <span class="string">"stop"</span>,</span><br><span class="line">          <span class="attr">"stopwords"</span>: [ <span class="string">"si"</span>, <span class="string">"esta"</span>, <span class="string">"el"</span>, <span class="string">"la"</span> ]  </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"light_spanish"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"stemmer"</span>,</span><br><span class="line">          <span class="attr">"language"</span>: <span class="string">"light_spanish"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"my_spanish"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"spanish"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>: [</span><br><span class="line">            <span class="string">"lowercase"</span>,</span><br><span class="line">            <span class="string">"asciifolding"</span>,</span><br><span class="line">            <span class="string">"spanish_stop"</span>,</span><br><span class="line">            <span class="string">"light_spanish"</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="更新停用词（Updating-Stopwords）"><a href="#更新停用词（Updating-Stopwords）" class="headerlink" title="更新停用词（Updating Stopwords）"></a>更新停用词（Updating Stopwords）</h5><p>更新停用词时机：</p>
<ul>
<li>分析器在创建索引时。</li>
<li>当集群节点重启时候。</li>
<li>关闭的索引重新打开的时候。</li>
</ul>
<ol>
<li>内联式 需要关闭索引，更新配置，再重新打开索引。stopwords 参数以内联方式指定停用词，只能通过关闭索引，更新分析器的配置，然后在重新打开索引才能更新停用词。</li>
<li>停用词文件，直接更新文件就可以。</li>
</ol>
<h3 id="停用词与性能-Stopwords-Performance-Versus-Precision"><a href="#停用词与性能-Stopwords-Performance-Versus-Precision" class="headerlink" title="停用词与性能(Stopwords: Performance Versus Precision)"></a>停用词与性能(Stopwords: Performance Versus Precision)</h3><p>保留停用词最大的缺点就是影响搜索性能。<br>问题分析：停用词出现频率高，搜索时包含停用词，返回的文档数量会很多。<br>减少文档数量的方法:</p>
<ol>
<li>and 操作符</li>
<li>最少匹配数(minimum_should_match)</li>
</ol>
<h5 id="and-操作符-and-Operator"><a href="#and-操作符-and-Operator" class="headerlink" title="and 操作符(and Operator)"></a>and 操作符(and Operator)</h5><p>减少待评分文档数量最简单的方法：match查询时使用and 操作符。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"text"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>:    <span class="string">"the quick brown fox"</span>,</span><br><span class="line">            <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">             &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重写为bool查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"must"</span>: [</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"the"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"fox"</span> &#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bool 查询会智能的根据较优的顺序依次执行每个 term 查询：它会从最低频的词开始。因为所有词项都必须匹配，只要包含低频词的文档才有可能匹配。使用 and 操作符可以大大提升多词查询的速度。</p>
<h5 id="最少匹配数-minimum-should-match"><a href="#最少匹配数-minimum-should-match" class="headerlink" title="最少匹配数(minimum_should_match)"></a>最少匹配数(minimum_should_match)</h5><p>使用最少匹配数(minimum_should_match)去掉结果中次相关的长尾。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">        <span class="attr">"text"</span>: &#123;</span><br><span class="line">            <span class="attr">"query"</span>: <span class="string">"the quick brown fox"</span>,</span><br><span class="line">            <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示例中四分之三的词都必须匹配，查询时考虑低频率的词，相比or操作，性能有巨大提升。</p>
<h3 id="词项的分别管理-Divide-and-Conquer"><a href="#词项的分别管理-Divide-and-Conquer" class="headerlink" title="词项的分别管理(Divide and Conquer)"></a>词项的分别管理(Divide and Conquer)</h3><ul>
<li>查询字符串中的词项(terms)可以分为： 更重要(低频词)，次重要(高频词)。低频词组成 bulk 大量查询条件，高频词只会用来评分，不参与匹配过程。</li>
<li>使用参数cutoff_frequency将词项分为 低频和高频，超过cutoff_frequency值的为高频词。</li>
<li>使用参数cutoff_frequency的好处：特定领域 使用的停用词不受约束，它根据词项的词频过滤文档不是stop过滤器中的停用词列表。</li>
<li>cutoff_frequency 配置可以指定为一个分数（ 0.01 = 1% ）或者一个正整数（ 5 ）。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"match"</span>: &#123;</span><br><span class="line">    <span class="attr">"text"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"Quick and the dead"</span>,</span><br><span class="line">      <span class="attr">"cutoff_frequency"</span>: <span class="number">0.01</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被重新为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span>: &#123;</span><br><span class="line">    <span class="attr">"must"</span>: &#123;</span><br><span class="line">      <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"dead"</span>  &#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"should"</span>: &#123;</span><br><span class="line">      <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"and"</span> &#125;&#125;,</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"the"</span> &#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="控制精度"><a href="#控制精度" class="headerlink" title="控制精度"></a>控制精度</h5><p>minimum_should_match 参数结合 cutoff_frequency 使用，可以控制精度。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"match"</span>: &#123;</span><br><span class="line">    <span class="attr">"text"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>: <span class="string">"Quick and the dead"</span>,</span><br><span class="line">      <span class="attr">"cutoff_frequency"</span>: <span class="number">0.01</span>,</span><br><span class="line">      <span class="attr">"minimum_should_match"</span>: <span class="string">"75%"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被重写为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span>: &#123;</span><br><span class="line">    <span class="attr">"must"</span>: &#123;</span><br><span class="line">      <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"quick"</span> &#125;&#125;,</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"dead"</span>  &#125;&#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"minimum_should_match"</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"should"</span>: &#123;</span><br><span class="line">      <span class="attr">"bool"</span>: &#123;</span><br><span class="line">        <span class="attr">"should"</span>: [</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"and"</span> &#125;&#125;,</span><br><span class="line">          &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"the"</span> &#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>minimum_should_match=1　因为只有两个词，原来的75%向下取整为 1 ，意思是：必须匹配低频词的两者之一。</li>
<li>should(and,the)　高频词仍可选的，并且仅用于评分使用。</li>
</ul>
<h5 id="高频次"><a href="#高频次" class="headerlink" title="高频次"></a>高频次</h5><p>如果想返回所有包含高频词的文档，使用must-or查询.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"bool"</span>: &#123;</span><br><span class="line">    <span class="attr">"must"</span>: [</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"to"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"be"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"or"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"not"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"to"</span> &#125;&#125;,</span><br><span class="line">      &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"text"</span>: <span class="string">"be"</span> &#125;&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对常用词使用更多控制-More-Control-with-Common-Terms"><a href="#对常用词使用更多控制-More-Control-with-Common-Terms" class="headerlink" title="对常用词使用更多控制(More Control with Common Terms)"></a>对常用词使用更多控制(More Control with Common Terms)</h5><p>使用更多参数进行控制(cutoff_frequency,low_freq_operator,low_freq,high_freq)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"common"</span>: &#123;</span><br><span class="line">    <span class="attr">"text"</span>: &#123;</span><br><span class="line">      <span class="attr">"query"</span>:                  <span class="string">"Quick and the dead"</span>,</span><br><span class="line">      <span class="attr">"cutoff_frequency"</span>:       <span class="number">0.01</span>,</span><br><span class="line">      <span class="attr">"low_freq_operator"</span>:      <span class="string">"and"</span>,</span><br><span class="line">      <span class="attr">"minimum_should_match"</span>: &#123;</span><br><span class="line">        <span class="attr">"high_freq"</span>:            <span class="string">"75%"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>“low_freq_operator”: “and”, 所有低频词都必须匹配</li>
<li>“high_freq”: “75%”，对超过 75% 的高频词文档进行评分</li>
</ol>
<p>更多配置项参见　<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/query-dsl-common-terms-query.html" target="_blank" rel="noopener">common terms query</a></p>
<h3 id="停用词和短语查询-Stopwords-and-Phrase-Queries"><a href="#停用词和短语查询-Stopwords-and-Phrase-Queries" class="headerlink" title="停用词和短语查询(Stopwords and Phrase Queries)"></a>停用词和短语查询(Stopwords and Phrase Queries)</h3><p>典型索引包含内容：</p>
<ul>
<li>词项字段(Terms dictionary): 索引中所有文档内所有词项的有序列表，以及包含该词的文档数量。</li>
<li>倒排表(Postings list): 包含每个词项的文档（ID）列表。</li>
<li>词频(Term frequency) : 每个词项在每个文档里出现的频率。</li>
<li>位置(Positions) : 每个词项在每个文档里出现的位置，供短语查询或近似查询使用。</li>
<li>偏移(Offsets): 每个词项在每个文档里开始与结束字符的偏移，供词语高亮使用，默认是禁用的。</li>
<li>规范因子（Norms）: 用来对字段长度进行规范化处理的因子，给较短字段予以更多权重。</li>
</ul>
<p>将停用词从索引中移除会节省 词项字典 和 倒排表 里的少量空间，但位置和偏移是另一码事。<br>位置和偏移数据很容易变成索引大小的两倍、三倍、甚至四倍。</p>
<h5 id="位置信息"><a href="#位置信息" class="headerlink" title="位置信息"></a>位置信息</h5><p>位置信息默认是开启的，词项出现越频繁位置信息所占空间就越多。</p>
<h5 id="索引选项"><a href="#索引选项" class="headerlink" title="索引选项"></a>索引选项</h5><p>是否真的需要使用短语查询或 近似查询？答案通常是 ：不需要。<br>使用index_options参数控制索引里每个字段的存储信息。<br>选项：</p>
<ul>
<li>docs：只存储文档及其包含词项的信息。这对 not_analyzed 字符串字段是默认的。</li>
<li>freqs: 存储docs信息和词频。如果只想知道：文档是否包含某词项，则不需使用它。</li>
<li>positions: 存储 docs 、 freqs 、 analyzed和每个词项的位置。nalyzed 字符串字段是默认的，但当不需使用短语或近似匹配时，可以将其禁用。</li>
<li>offsets : 存储docs 、 freqs 、 positions和原始字符串的偏移量。这个信息被用以高亮搜索结果，但它默认是禁用的。</li>
</ul>
<p>例如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"title"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:          <span class="string">"string"</span></span><br><span class="line">       &#125;,</span><br><span class="line">        <span class="attr">"content"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:          <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"index_options"</span>: <span class="string">"freqs"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="停用词"><a href="#停用词" class="headerlink" title="停用词"></a>停用词</h5><p>删除停用词可以节省空间提高查询性能，但也降低了搜索能力。<br>幸运的是可以通过common_grams 过滤器，让两者兼得。</p>
<h3 id="common-grams过滤器-common-grams-Token-Filter"><a href="#common-grams过滤器-common-grams-Token-Filter" class="headerlink" title="common_grams过滤器(common_grams Token Filter)"></a>common_grams过滤器(common_grams Token Filter)</h3><p>为使短语查询能更高效的使用停用词，设计了common_grams过滤器，与shingles过滤器类似，<br>query_mode ：false(为索引使用,默认), true (为搜索使用)。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"index_filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:         <span class="string">"common_grams"</span>,</span><br><span class="line">          <span class="attr">"common_words"</span>: <span class="string">"_english_"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"search_filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:         <span class="string">"common_grams"</span>,</span><br><span class="line">          <span class="attr">"common_words"</span>: <span class="string">"_english_"</span>,</span><br><span class="line">          <span class="attr">"query_mode"</span>:   <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"index_grams"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>:  <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:   [ <span class="string">"lowercase"</span>, <span class="string">"index_filter"</span> ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"search_grams"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:  [ <span class="string">"lowercase"</span>, <span class="string">"search_filter"</span> ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基于 common_grams 过滤器创建两个过滤器,index_filter 在索引时使用，search_filter 在查询时使用</li>
<li>common_words 接受<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/using-stopwords.html#specifying-stopwords" target="_blank" rel="noopener">指定停用词</a>,例如：none,<code>_english_</code></li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"text"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:            <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"analyzer"</span>:  <span class="string">"index_grams"</span>,</span><br><span class="line">      <span class="attr">"search_analyzer"</span>: <span class="string">"standard"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="索引时-At-Index-Time"><a href="#索引时-At-Index-Time" class="headerlink" title="索引时(At Index Time)"></a>索引时(At Index Time)</h5><p>索引时common_gram生成数据格式如下:<br><code>The quick and brown fox</code></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Pos 1: the, the_quick</span><br><span class="line">Pos 2: quick, quick_and</span><br><span class="line">Pos 3: and, and_brown</span><br><span class="line">Pos 4: brown</span><br><span class="line">Pos 5: fox</span><br></pre></td></tr></table></figure>
<ul>
<li>所有的词项都是unigrams 形式输出</li>
<li>如果一个词本身是常用词或者跟随着常用词时，以bigram形式输出：the_quick，quick_and，and_brown</li>
</ul>
<h5 id="单字查询-Unigram-Queries"><a href="#单字查询-Unigram-Queries" class="headerlink" title="单字查询(Unigram Queries)"></a>单字查询(Unigram Queries)</h5><p>单字查询可以正常使用</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>: <span class="string">"the quick and brown fox"</span>,</span><br><span class="line">        <span class="attr">"cutoff_frequency"</span>: <span class="number">0.01</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="二元语法短语查询-Bigram-Phrase-Queries"><a href="#二元语法短语查询-Bigram-Phrase-Queries" class="headerlink" title="二元语法短语查询(Bigram Phrase Queries)"></a>二元语法短语查询(Bigram Phrase Queries)</h5><p>进行短语查询时使用专门的search_grams分析器让过程变的更高效。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match_phrase"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:    <span class="string">"The quick and brown fox"</span>,</span><br><span class="line">        <span class="attr">"analyzer"</span>: <span class="string">"search_grams"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>search_grams 分析器会生成以下词项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pos 1: the_quick</span><br><span class="line">Pos 2: quick_and</span><br><span class="line">Pos 3: and_brown</span><br><span class="line">Pos 4: brown</span><br><span class="line">Pos 5: fox</span><br></pre></td></tr></table></figure>

<h5 id="两词短语（Two-Word-Phrases）"><a href="#两词短语（Two-Word-Phrases）" class="headerlink" title="两词短语（Two-Word Phrases）"></a>两词短语（Two-Word Phrases）</h5><h3 id="停用词与相关性-Stopwords-and-Relevance"><a href="#停用词与相关性-Stopwords-and-Relevance" class="headerlink" title="停用词与相关性(Stopwords and Relevance)"></a>停用词与相关性(Stopwords and Relevance)</h3><p>在索引中保留停用词会降低相关度计算的准确性，特别是当我们的文档非常长时。<br>如果一个长文档中停用很多，词频饱和度没有设置上限，则其他常用词的词频会降低。<br>考虑对包含停用词的较长字段使用使用Okapi BM25，设置词频饱和度。</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>26-处理人类语言-拼写错误</title>
    <url>/2020/03/15/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/26-%E5%A4%84%E7%90%86%E4%BA%BA%E7%B1%BB%E8%AF%AD%E8%A8%80-%E6%8B%BC%E5%86%99%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h3 id="拼写错误-Typoes-and-Mispelings"><a href="#拼写错误-Typoes-and-Mispelings" class="headerlink" title="拼写错误(Typoes and Mispelings)"></a>拼写错误(Typoes and Mispelings)</h3><p>Fuzzy matching 允许查询时匹配错误拼写的单词，<br>而语音语汇单元过滤器(phonetic token filters)可以在索引时用来进行 近似读音 匹配。</p>
<a id="more"></a>
<h3 id="模糊性"><a href="#模糊性" class="headerlink" title="模糊性"></a>模糊性</h3><p>3中操作：</p>
<ul>
<li><p>一个字符 替换 另一个字符： <code>_f_ox → _b_ox</code></p>
</li>
<li><p>插入 一个新的字符：<code>sic → sic_k_</code></p>
</li>
<li><p>删除 一个字符：<code>b_l_ack → back</code></p>
</li>
<li><p>编辑距离: 将一个单词转为另一个单词所需要的编辑次数 称为 编辑距离。</p>
</li>
<li><p>Damerau 发现 80% 的拼写错误编辑距离为 1 。换句话说， 80% 的拼写错误可以对原始字符串用 单次编辑 进行修正。</p>
</li>
<li><p>fuzziness 参数支持对最大编辑距离的配置，默认为 ２ 。</p>
</li>
<li><p>fuzziness 参数可以被设置为 AUTO</p>
<ul>
<li>字符串只有 1 到 2 个字符时是 0</li>
<li>字符串有 3 、 4 或者 5 个字符时是 1</li>
<li>字符串大于 5 个字符时是 2</li>
</ul>
</li>
</ul>
<h3 id="模糊查询-Fuzziness"><a href="#模糊查询-Fuzziness" class="headerlink" title="模糊查询(Fuzziness)"></a>模糊查询(Fuzziness)</h3><p>fuzzy查询(fuzzy query)是 term 查询的模糊等价。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /my_index/my_type/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">1</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"text"</span>: <span class="string">"Surprise me!"</span>&#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">2</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"text"</span>: <span class="string">"That was surprising."</span>&#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">3</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"text"</span>: <span class="string">"I wasn't surprised."</span>&#125;</span><br></pre></td></tr></table></figure>
<p>模糊查询，编辑距离设置为1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"fuzzy"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: &#123;</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"surprize"</span>,</span><br><span class="line">        <span class="attr">"fuzziness"</span>: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="提高性能"><a href="#提高性能" class="headerlink" title="提高性能"></a>提高性能</h5><ul>
<li>fuzzy查询工作原理：给定原始词项及构造一个编辑自动机(像表示所有原始字符串指定编辑距离的字符串的一个)大图表。然后模糊查询使用这个自动机依次高效遍历词典中的所有词项以确定是否匹配。 一旦收集了词典中存在的所有匹配项，就可以计算匹配文档列表。</li>
</ul>
<p>下面两个参数可以用来限制对性能的影响:</p>
<ul>
<li>profix_length :不能被 “模糊化” 的初始字符数。 大部分的拼写错误发生在词的结尾，而不是词的开始。 例如通过将 prefix_length 设置为 3 ，你可能够显著降低匹配的词项数量。</li>
<li>max_expansions : 如果一个模糊查询扩展了三个或四个模糊选项， 这些新的模糊选项也许是有意义的。如果它产生 1000 个模糊选项，那么就基本没有意义了。 设置 max_expansions 用来限制将产生的模糊选项的总数量。模糊查询将收集匹配词项直到达到 max_expansions 的限制。</li>
</ul>
<h3 id="模糊匹配查询"><a href="#模糊匹配查询" class="headerlink" title="模糊匹配查询"></a>模糊匹配查询</h3><ul>
<li>match 查询支持模糊匹配(fuzziness)</li>
<li>mutil_match查询也支持模糊查询(fuzziness),但只要类型是 best_fields或 most_fields。</li>
<li>match 和 multi_match 查询都支持 prefix_length 和 max_expansions 参数。</li>
<li>不能使用场景: 模糊性（Fuzziness）只能在 match and multi_match 查询中使用。不能使用在短语匹配、常用词项或 cross_fields 匹配。</li>
</ul>
<p>match 查询支持模糊匹配(fuzziness)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"text"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>:     <span class="string">"SURPRIZE ME!"</span>,</span><br><span class="line">        <span class="attr">"fuzziness"</span>: <span class="string">"AUTO"</span>,</span><br><span class="line">        <span class="attr">"operator"</span>:  <span class="string">"and"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mutil_match查询也支持模糊查询(fuzziness),但只要类型是 best_fields或 most_fields。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"multi_match"</span>: &#123;</span><br><span class="line">      <span class="attr">"fields"</span>:  [ <span class="string">"text"</span>, <span class="string">"title"</span> ],</span><br><span class="line">      <span class="attr">"query"</span>:     <span class="string">"SURPRIZE ME!"</span>,</span><br><span class="line">      <span class="attr">"fuzziness"</span>: <span class="string">"AUTO"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模糊性评分-Scoring-Fuzziness"><a href="#模糊性评分-Scoring-Fuzziness" class="headerlink" title="模糊性评分(Scoring Fuzziness)"></a>模糊性评分(Scoring Fuzziness)</h3><ul>
<li>虽然用户喜欢模糊查询，但实际效果平平。</li>
<li>模糊匹配不应用于参与评分—​只能在有拼写错误时扩大匹配项的范围。</li>
<li>默认情况下， match 查询给定所有的模糊匹配的恒定评分为1。</li>
<li>模糊查询常用与其他特性结合使用，比如：search-as-you-type(完成建议)，did-you-mean(短语建议)</li>
</ul>
<h3 id="语音匹配-Phonetic-Matching"><a href="#语音匹配-Phonetic-Matching" class="headerlink" title="语音匹配(Phonetic Matching)"></a>语音匹配(Phonetic Matching)</h3><ul>
<li>语音匹配就是搜索发音相似的词</li>
<li>语音算法：将词转换成语音标识的算法。 Soundex 是最早的算法,其他算法是Soundex的改进版， Metaphone，Double Metaphone， Caverphone ，Beider-Morse ，Kölner Phonetik</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"analysis"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"dbl_metaphone"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:    <span class="string">"phonetic"</span>,</span><br><span class="line">          <span class="attr">"encoder"</span>: <span class="string">"double_metaphone"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"analyzer"</span>: &#123;</span><br><span class="line">        <span class="attr">"dbl_metaphone"</span>: &#123;</span><br><span class="line">          <span class="attr">"tokenizer"</span>: <span class="string">"standard"</span>,</span><br><span class="line">          <span class="attr">"filter"</span>:    <span class="string">"dbl_metaphone"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>analyze API 测试</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /my_index/_analyze?analyzer=dbl_metaphone</span><br><span class="line">Smith Smythe</span><br></pre></td></tr></table></figure>

<p>设置mapping</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/my_type</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"fields"</span>: &#123;</span><br><span class="line">        <span class="attr">"phonetic"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:     <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"analyzer"</span>: <span class="string">"dbl_metaphone"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Smith"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/my_type/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Jonnie Smythe"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以使用 match 查询来进行搜索：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"name.phonetic"</span>: &#123;</span><br><span class="line">        <span class="attr">"query"</span>: <span class="string">"Jahnnie Smeeth"</span>,</span><br><span class="line">        <span class="attr">"operator"</span>: <span class="string">"and"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>用语音算法计算评分是没有价值的</li>
<li>语音匹配的目的不是为了提高精度，而是要提高召回率—​以扩展足够的范围来捕获可能匹配的文档</li>
<li>通常更有意义的使用语音算法是在检索到结果后，由另一台计算机进行消费和后续处理，而不是由人类用户直接使用。</li>
</ul>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>27-聚合-高阶概念</title>
    <url>/2020/03/16/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/27-%E8%81%9A%E5%90%88-%E9%AB%98%E9%98%B6%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h3 id="聚合简介"><a href="#聚合简介" class="headerlink" title="聚合简介"></a>聚合简介</h3><ul>
<li>聚合会得到一个数据的概览。</li>
<li>聚合是分析和总结全套的数据。</li>
<li>聚合可以回答更加细微的问题</li>
<li>聚合使用相同的数据结构，所以它的执行速度很快并且就像搜索一样几乎是实时的</li>
<li>聚合和搜索结合使用。</li>
</ul>
<a id="more"></a>
<h3 id="高阶概念-High-Level-Concepts"><a href="#高阶概念-High-Level-Concepts" class="headerlink" title="高阶概念(High-Level Concepts)"></a>高阶概念(High-Level Concepts)</h3><ul>
<li>两个主要概念:<ul>
<li>桶(Buckets): 满足特定条件文档的集合。</li>
<li>指标(Metrics): 对桶内的文档进行统计计算。</li>
</ul>
</li>
<li>聚合也是可混合的语法，每个聚合是一个或多个桶和指标的组合。学习很少基本概念可以无尽组合。</li>
</ul>
<h3 id="桶"><a href="#桶" class="headerlink" title="桶"></a>桶</h3><ul>
<li>桶：满足特定条件文档的集合。</li>
<li>过程：聚合开始执行，每个文档里面的值通过计算来决定符合哪个桶的条件。如果匹配到则将文档放入响应的桶，接着进行聚合操作。</li>
<li>桶可以嵌套其他桶。</li>
<li>很多类型的桶让你基于条件来划分文档。</li>
</ul>
<h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><ul>
<li>分桶是一种达到目的的手段：它提供了一种给文档分组的方法来让我们可以计算感兴趣的指标。</li>
<li>大多数 指标 是简单的数学运算(例如最小值、平均值、最大值，还有汇总),通过文档值来计算。</li>
</ul>
<h3 id="桶和指标的组合"><a href="#桶和指标的组合" class="headerlink" title="桶和指标的组合"></a>桶和指标的组合</h3><ul>
<li>聚合 是由桶和指标组成的。聚合可能只有一个桶，可能只有一个指标，或者可能两个都有。也有可能有一些桶嵌套在其他桶里面。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/aggs-high-level.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/eb0004640922da772be5ccb61060642a23b67e6b/301_Aggregation_Overview.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>28-聚合-尝试聚合</title>
    <url>/2020/03/16/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/28-%E8%81%9A%E5%90%88-%E5%B0%9D%E8%AF%95%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h3 id="尝试聚合"><a href="#尝试聚合" class="headerlink" title="尝试聚合"></a>尝试聚合</h3><p>聚合的桶操作和度量的完整用法可以在 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/search-aggregations.html" target="_blank" rel="noopener">Elasticsearch 参考</a> 中找到。</p>
<a id="more"></a>
<p>添加数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /cars/transactions/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">10000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"honda"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">20000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"honda"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-11-05"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">30000</span>, <span class="attr">"color"</span> : <span class="string">"green"</span>, <span class="attr">"make"</span> : <span class="string">"ford"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-05-18"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">15000</span>, <span class="attr">"color"</span> : <span class="string">"blue"</span>, <span class="attr">"make"</span> : <span class="string">"toyota"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-07-02"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">12000</span>, <span class="attr">"color"</span> : <span class="string">"green"</span>, <span class="attr">"make"</span> : <span class="string">"toyota"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-08-19"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">20000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"honda"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-11-05"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">80000</span>, <span class="attr">"color"</span> : <span class="string">"red"</span>, <span class="attr">"make"</span> : <span class="string">"bmw"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-01-01"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"price"</span> : <span class="number">25000</span>, <span class="attr">"color"</span> : <span class="string">"blue"</span>, <span class="attr">"make"</span> : <span class="string">"ford"</span>, <span class="attr">"sold"</span> : <span class="string">"2014-02-12"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>查询那种颜色的车销量最好。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span>:<span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"popular_colors"</span>:&#123;</span><br><span class="line">      <span class="attr">"terms"</span> : &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"color"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>聚合操作被置于顶层参数 aggs 之下,聚合是在特定搜索结果背景下执行的， 这也就是说它只是查询请求的另外一个顶层参数</li>
<li>‘popular_colors’ 为聚合指定一个我们想要名称.</li>
<li>定义单个桶的类型 terms</li>
<li>“size”:0, 将 size 设置成0，我们并不关心搜索结果的具体内容，所以将返回记录数设置为 0 来提高查询速度。</li>
</ul>
<p>返回结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   "hits": &#123;</span><br><span class="line">      "hits": []</span><br><span class="line">   &#125;,</span><br><span class="line">   "aggregations": &#123;</span><br><span class="line">      "popular_colors": &#123;</span><br><span class="line">         "buckets": [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>: <span class="string">"red"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">4</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>: <span class="string">"blue"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="attr">"key"</span>: <span class="string">"green"</span>,</span><br><span class="line">               <span class="attr">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>因为我们设置了 size 参数，所以不会有 hits 搜索结果返回。</li>
<li>popular_colors 聚合是作为 aggregations 字段的一部分被返回的。</li>
<li>响应包含多个桶，每个桶的 key 都与 color 字段里找到的唯一词对应。它总会包含 doc_count 字段，告诉我们包含该词项的文档数量。</li>
<li>每个桶的数量(doc_count)代表该颜色的文档数量。</li>
</ul>
<h3 id="添加度量指标-Adding-a-Metric-to-the-Mix"><a href="#添加度量指标-Adding-a-Metric-to-the-Mix" class="headerlink" title="添加度量指标(Adding a Metric to the Mix)"></a>添加度量指标(Adding a Metric to the Mix)</h3><p>度量(metrics)是基于桶内的文档进行数学统计的，所以需要将度量嵌套到桶内。<br>需要告诉ES对哪个字段，计算哪些度量。</p>
<p>统计汽车平均价格</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">      <span class="attr">"colors"</span>: &#123;</span><br><span class="line">         <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"color"</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">               <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                  <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新增的嵌套的度量层’aggs’; 度量名称为’avg_price’;度量本身是’avg’, 度量的字段是 ‘price’,</li>
<li>嵌套中的’aggs’为度量新增 aggs 层, 它将 avg 度量嵌套置于 terms 桶内。</li>
</ul>
<h3 id="嵌套桶-Buckets-Inside-Buckets"><a href="#嵌套桶-Buckets-Inside-Buckets" class="headerlink" title="嵌套桶(Buckets Inside Buckets)"></a>嵌套桶(Buckets Inside Buckets)</h3><p>嵌套桶才能发挥聚合的力量。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">      <span class="attr">"colors"</span>: &#123;</span><br><span class="line">         <span class="attr">"terms"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"color"</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">               <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                  <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"make"</span>: &#123;</span><br><span class="line">                <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                    <span class="attr">"field"</span>: <span class="string">"make"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>新增一个’make’聚合，嵌套在 colors 、 terms 桶内，与’avg_price’平级，相互独立。</li>
<li>‘make’聚合是 terms 桶，它会为每个汽车制造商生成唯一的桶。</li>
<li>一个聚合的每个曾经都可以有多个度量或桶。</li>
<li>聚合使我们能够用一次数据请求获得所有的这些信息。</li>
</ul>
<p>返回结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"took"</span>: <span class="number">89</span>,</span><br><span class="line">    <span class="attr">"timed_out"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"_shards"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"successful"</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">"skipped"</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">"failed"</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"hits"</span>: &#123;</span><br><span class="line">        <span class="attr">"total"</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="attr">"max_score"</span>: <span class="number">0.0</span>,</span><br><span class="line">        <span class="attr">"hits"</span>: []</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggregations"</span>: &#123;</span><br><span class="line">        <span class="attr">"colors"</span>: &#123;</span><br><span class="line">            <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"buckets"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"red"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">4</span>,</span><br><span class="line">                    <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">32500.0</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"make"</span>: &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"honda"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">3</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"bmw"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"blue"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">20000.0</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"make"</span>: &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"ford"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"toyota"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"key"</span>: <span class="string">"green"</span>,</span><br><span class="line">                    <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">                    <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"value"</span>: <span class="number">21000.0</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="attr">"make"</span>: &#123;</span><br><span class="line">                        <span class="attr">"doc_count_error_upper_bound"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"sum_other_doc_count"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"buckets"</span>: [</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"ford"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                            &#125;,</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="attr">"key"</span>: <span class="string">"toyota"</span>,</span><br><span class="line">                                <span class="attr">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后的修改"><a href="#最后的修改" class="headerlink" title="最后的修改"></a>最后的修改</h3><p>为每个汽车生成商计算最低和最高的价格：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"aggs"</span>: &#123;</span><br><span class="line">		<span class="attr">"colors"</span>: &#123;</span><br><span class="line">			<span class="attr">"terms"</span>: &#123;</span><br><span class="line">				<span class="attr">"field"</span>: <span class="string">"color"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"aggs"</span>: &#123;</span><br><span class="line">				<span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">					<span class="attr">"avg"</span>: &#123;</span><br><span class="line">						<span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="attr">"make"</span>: &#123;</span><br><span class="line">					<span class="attr">"terms"</span>: &#123;</span><br><span class="line">						<span class="attr">"field"</span>: <span class="string">"make"</span></span><br><span class="line">					&#125;,</span><br><span class="line">					<span class="attr">"aggs"</span>: &#123;</span><br><span class="line">						<span class="attr">"min_price"</span>: &#123; <span class="attr">"min"</span>: &#123;<span class="attr">"field"</span>: <span class="string">"price"</span>&#125; &#125;,</span><br><span class="line">						<span class="attr">"max_price"</span>: &#123; <span class="attr">"max"</span>: &#123;<span class="attr">"field"</span>: <span class="string">"price"</span>&#125; &#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###</p>
<p>###</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_aggregation_test_drive.html#_aggregation_test_drive" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/20_basic_example.asciidoc" target="_blank" rel="noopener">英文参考</a><br><a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/21_add_metric.asciidoc" target="_blank" rel="noopener">英文参考2</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>29-聚合-条形图</title>
    <url>/2020/03/17/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/29-%E8%81%9A%E5%90%88-%E6%9D%A1%E5%BD%A2%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="构建条形图-Building-Bar-Charts"><a href="#构建条形图-Building-Bar-Charts" class="headerlink" title="构建条形图(Building Bar Charts)"></a>构建条形图(Building Bar Charts)</h3><ul>
<li>聚合还有一个令人激动的特性就是能够十分容易地将它们转换成图表(charts)和图形(graphs)。</li>
<li>直方图(histogram) 特别有用,它本质是一个条形图(Bar Charts)</li>
<li>直方图(histogram) 需要指定一个区间，在区间内进行计算统计。</li>
<li>关键字：histogram-直方图， interval-区间间隔， extended_stats-统计count,min,max,avg,sum,sum_of_squares,variance,std_deviation,std_deviation_bounds<a id="more"></a>

</li>
</ul>
<p>以20000元为间隔设定分组的间隔范围(0-19999, 20000-39999, …])，统计(sum)区间内的总收入。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">"size"</span>: <span class="number">0</span>,</span><br><span class="line">	<span class="attr">"aggs"</span>: &#123;</span><br><span class="line">		<span class="attr">"price"</span>: &#123;</span><br><span class="line">			<span class="attr">"histogram"</span>: &#123;</span><br><span class="line">				<span class="attr">"field"</span>: <span class="string">"price"</span>,</span><br><span class="line">				<span class="attr">"interval"</span>: <span class="number">20000</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="attr">"aggs"</span>: &#123;</span><br><span class="line">				<span class="attr">"revenue"</span>: &#123;</span><br><span class="line">					<span class="attr">"sum"</span>: &#123;</span><br><span class="line">						<span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>histogram 桶要求两个参数：一个数值字段以及一个定义桶大小间隔。</li>
<li>sum 度量嵌套在每个售价区间内，用来显示每个区间内的总收入。</li>
</ul>
<p>使用extended_stats统计(count,min,max,avg,sum,sum_of_squares,variance,std_deviation,std_deviation_bounds)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"makes"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"make"</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="number">10</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"stats"</span>: &#123;</span><br><span class="line">          <span class="attr">"extended_stats"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_building_bar_charts.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>30-聚合-按时间统计</title>
    <url>/2020/03/17/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/30-%E8%81%9A%E5%90%88-%E6%8C%89%E6%97%B6%E9%97%B4%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="按时间统计-Looking-at-Time"><a href="#按时间统计-Looking-at-Time" class="headerlink" title="按时间统计(Looking at Time)"></a>按时间统计(Looking at Time)</h3><ul>
<li>使用 date_histogram 按时间统计，能自动识别时间数据，还可以处理时区。</li>
<li>date_histogram 经常为线装图以展示时间序列。</li>
<li>date_histogram 是以时间范围上构建buckets，每个bucket被定义为一特定的日期大小(比如： 1个月，3天)</li>
</ul>
<a id="more"></a>
<p>查询每月汽车销量</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">      <span class="attr">"sales"</span>: &#123;</span><br><span class="line">         <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"sold"</span>,</span><br><span class="line">            <span class="attr">"interval"</span>: <span class="string">"month"</span>,</span><br><span class="line">            <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd"</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每个月构建一个桶，统计汽车销量</li>
<li>‘format’: 在ES内部日期被表生成数据，format把日期格式化成为更易读的格式。</li>
</ul>
<h3 id="返回空Buckets-Returning-Empty-Buckets"><a href="#返回空Buckets-Returning-Empty-Buckets" class="headerlink" title="返回空Buckets(Returning Empty Buckets)"></a>返回空Buckets(Returning Empty Buckets)</h3><ul>
<li>min_doc_count 指定doc_count &gt;= min_doc_count 的文档返回</li>
<li>extended_bounds 指定日期边界(min,max)，边界内如果不存在文档，该参数会补齐文档，值为0.</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">      <span class="attr">"sales"</span>: &#123;</span><br><span class="line">         <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"sold"</span>,</span><br><span class="line">            <span class="attr">"interval"</span>: <span class="string">"month"</span>,</span><br><span class="line">            <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd"</span>,</span><br><span class="line">            <span class="attr">"min_doc_count"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"extended_bounds"</span> : &#123;</span><br><span class="line">                <span class="attr">"min"</span> : <span class="string">"2014-01-01"</span>,</span><br><span class="line">                <span class="attr">"max"</span> : <span class="string">"2014-12-31"</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>‘min_doc_count=0’ 强制返回空 buckets。</li>
<li>extended_bounds 返回2014整年</li>
</ul>
<h3 id="扩展例子-Extended-Example"><a href="#扩展例子-Extended-Example" class="headerlink" title="扩展例子(Extended Example)"></a>扩展例子(Extended Example)</h3><p>查询条件：</p>
<ol>
<li>按照季度展示汽车销量</li>
<li>每季度的每个汽车品牌销售总额</li>
<li>每季度的总销售额</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">      <span class="attr">"sales"</span>: &#123;</span><br><span class="line">         <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>: <span class="string">"sold"</span>,</span><br><span class="line">            <span class="attr">"interval"</span>: <span class="string">"quarter"</span>,</span><br><span class="line">            <span class="attr">"format"</span>: <span class="string">"yyyy-MM-dd"</span>,</span><br><span class="line">            <span class="attr">"min_doc_count"</span> : <span class="number">0</span>,</span><br><span class="line">            <span class="attr">"extended_bounds"</span> : &#123;</span><br><span class="line">                <span class="attr">"min"</span> : <span class="string">"2014-01-01"</span>,</span><br><span class="line">                <span class="attr">"max"</span> : <span class="string">"2014-12-31"</span></span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"per_make_sum"</span>: &#123;</span><br><span class="line">               <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                  <span class="attr">"field"</span>: <span class="string">"make"</span></span><br><span class="line">               &#125;,</span><br><span class="line">               <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                  <span class="attr">"sum_price"</span>: &#123;</span><br><span class="line">                     <span class="attr">"sum"</span>: &#123; <span class="attr">"field"</span>: <span class="string">"price"</span> &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"total_sum"</span>: &#123;</span><br><span class="line">               <span class="attr">"sum"</span>: &#123; <span class="attr">"field"</span>: <span class="string">"price"</span> &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="潜力无穷-The-Sky’s-the-Limit"><a href="#潜力无穷-The-Sky’s-the-Limit" class="headerlink" title="潜力无穷(The Sky’s the Limit)"></a>潜力无穷(The Sky’s the Limit)</h3><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_looking_at_time.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/35_date_histogram.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>31-聚合-范围限定的聚合</title>
    <url>/2020/03/17/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/31-%E8%81%9A%E5%90%88-%E8%8C%83%E5%9B%B4%E9%99%90%E5%AE%9A%E7%9A%84%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h3 id="范围限定的聚合-Scoping-Aggregations"><a href="#范围限定的聚合-Scoping-Aggregations" class="headerlink" title="范围限定的聚合(Scoping Aggregations)"></a>范围限定的聚合(Scoping Aggregations)</h3><ul>
<li>聚合与搜索同时执行时，聚合是基于查询匹配的文件集合进行计算的。</li>
<li>过滤器也可以进行范围限定</li>
<li>‘没有指定查询’ 和 ‘查询所有文档’ 是等价的。</li>
<li>聚合总是对查询范围内的结果进行操作的，所以一个单独的聚合实际上是在对 match_all 的结果范围操作，即所有的文档</li>
<li>利用查询来限定聚合的范围(scope)</li>
</ul>
<a id="more"></a>
<p>例如：福特汽车有多少中颜色</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"make"</span> : <span class="string">"ford"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="全局桶-Global-Bucket"><a href="#全局桶-Global-Bucket" class="headerlink" title="全局桶(Global Bucket)"></a>全局桶(Global Bucket)</h5><ul>
<li>使用全局桶脱离当前查询范围的限制，基于所有文档。</li>
<li>global 全局桶没有参数。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"make"</span> : <span class="string">"ford"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"single_avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"all"</span>: &#123;</span><br><span class="line">            <span class="attr">"global"</span> : &#123;&#125;,</span><br><span class="line">            <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_scoping_aggregations.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/40_scope.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>32-聚合-过滤和聚合</title>
    <url>/2020/03/17/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/32-%E8%81%9A%E5%90%88-%E8%BF%87%E6%BB%A4%E5%92%8C%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h3 id="过滤和聚合-Filtering-Queries-and-Aggregations"><a href="#过滤和聚合-Filtering-Queries-and-Aggregations" class="headerlink" title="过滤和聚合(Filtering Queries and Aggregations)"></a>过滤和聚合(Filtering Queries and Aggregations)</h3><ul>
<li>过滤器对查询范围做限定</li>
<li>过滤器对聚合结果进行过滤</li>
<li>任何可以适用于查询的过滤器也可以应用在聚合上。</li>
</ul>
<a id="more"></a>
<h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><ol>
<li>售价在 $10,000 美元之上的所有汽车</li>
<li>同时也为这些车计算平均售价</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"query"</span> : &#123;</span><br><span class="line">        <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">            <span class="attr">"filter"</span>: &#123;</span><br><span class="line">                <span class="attr">"range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"price"</span>: &#123;</span><br><span class="line">                        <span class="attr">"gte"</span>: <span class="number">10000</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"single_avg_price"</span>: &#123;</span><br><span class="line">            <span class="attr">"avg"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"price"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="过滤桶-Filter-Bucket"><a href="#过滤桶-Filter-Bucket" class="headerlink" title="过滤桶(Filter Bucket)"></a>过滤桶(Filter Bucket)</h3><ul>
<li>使用过滤桶(Filter Bucket)在查询范围基础上进行过滤，满足过滤条件时加入桶内</li>
<li>过滤桶(Filter Bucket)也可以嵌套</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">   <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">   <span class="attr">"query"</span>:&#123;</span><br><span class="line">      <span class="attr">"match"</span>: &#123;</span><br><span class="line">         <span class="attr">"make"</span>: <span class="string">"ford"</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"aggs"</span>:&#123;</span><br><span class="line">      <span class="attr">"recent_sales"</span>: &#123;</span><br><span class="line">         <span class="attr">"filter"</span>: &#123;</span><br><span class="line">            <span class="attr">"range"</span>: &#123;</span><br><span class="line">               <span class="attr">"sold"</span>: &#123;</span><br><span class="line">                  <span class="attr">"from"</span>: <span class="string">"now-1M"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"average_price"</span>:&#123;</span><br><span class="line">               <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                  <span class="attr">"field"</span>: <span class="string">"price"</span></span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 过滤 桶在 查询 范围基础上应用过滤器。</li>
<li>avg 度量只会对 ford 和上个月售出的文档计算平均售价。</li>
</ul>
<h3 id="后过滤器-Post-Filter"><a href="#后过滤器-Post-Filter" class="headerlink" title="后过滤器(Post Filter)"></a>后过滤器(Post Filter)</h3><p>4种过滤场景</p>
<ol>
<li>过滤搜索结果(query中使用filter，先执行过滤，再执行搜索)</li>
<li>过滤聚合结果(aggs中使用filter)</li>
<li>过滤部分聚合结果(嵌套的aggs中使用filter)</li>
<li>只过滤搜索结果，不过滤聚合结果，使用post_filter在查询之后执行过滤，对查询范围没影响。</li>
<li>post_filter 元素是 top-level，而且符合条件的文档加入桶中。</li>
<li>post_filter 的特性是在查询之后 执行，失去了过滤器的性能优势（比如缓存)。</li>
<li>在我们需要不同过滤时， post_filter 只与聚合一起使用。</li>
</ol>
<p>查询条件：1. 搜索绿色的福特汽车 2. 按照颜色对福特进行聚合</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"make"</span>: <span class="string">"ford"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"post_filter"</span>: &#123;    </span><br><span class="line">        <span class="attr">"term"</span> : &#123;</span><br><span class="line">            <span class="attr">"color"</span> : <span class="string">"green"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"all_colors"</span>: &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123; <span class="attr">"field"</span> : <span class="string">"color"</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>在 filter 过滤中的不评分(non-scoring)查询，同时影响搜索结果和聚合结果。</li>
<li>filter桶 影响聚合</li>
<li>post_filter 只影响搜索结果</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_filtering_queries_and_aggregations.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/45_filtering.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>33-聚合-多桶排序</title>
    <url>/2020/03/16/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/33-%E8%81%9A%E5%90%88-%E5%A4%9A%E6%A1%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="多桶排序-Sorting-Multivalue-Buckets"><a href="#多桶排序-Sorting-Multivalue-Buckets" class="headerlink" title="多桶排序(Sorting Multivalue Buckets)"></a>多桶排序(Sorting Multivalue Buckets)</h3><ul>
<li>多值桶（ terms 、 histogram 和 date_histogram ）动态生成很多桶。</li>
<li>默认情况，桶根据doc_count降序排列。</li>
</ul>
<a id="more"></a>
<h3 id="内置排序-Intrinsic-Sorts"><a href="#内置排序-Intrinsic-Sorts" class="headerlink" title="内置排序(Intrinsic Sorts)"></a>内置排序(Intrinsic Sorts)</h3><ul>
<li>内置排序(Intrinsic Sorts)：利用桶内置的属性进行排序，桶内置的属性是操作桶时产生的数据。</li>
<li>内置排序字段：<ul>
<li><code>_count</code> ：按文档数排序，默认：文档数降序。对terms、histogram、date_histogram有效</li>
<li><code>_term</code> ： 按词项的字符串值的字母顺序排序。只在terms内使用。</li>
<li><code>_key</code> :  按每个桶的键值数值排序(理论上与<code>_term</code>类似)。只在histogram和date_histogram内使用。</li>
</ul>
</li>
</ul>
<h3 id="按度量排序-Sorting-by-a-Metric"><a href="#按度量排序-Sorting-by-a-Metric" class="headerlink" title="按度量排序(Sorting by a Metric)"></a>按度量排序(Sorting by a Metric)</h3><p>基于度量计算的结果值进行排序.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span>,</span><br><span class="line">              <span class="attr">"order"</span>: &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span> : <span class="string">"asc"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"avg_price"</span>: &#123;</span><br><span class="line">                    <span class="attr">"avg"</span>: &#123;<span class="attr">"field"</span>: <span class="string">"price"</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="度量输出多值，如果进行排序？"><a href="#度量输出多值，如果进行排序？" class="headerlink" title="度量输出多值，如果进行排序？"></a>度量输出多值，如果进行排序？</h5><p>答案是 排序字段使用 度量点式路径。<br>例如 extended_stats 输出多值，排序字段 stats.variance</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span>,</span><br><span class="line">              <span class="attr">"order"</span>: &#123;</span><br><span class="line">                <span class="attr">"stats.variance"</span> : <span class="string">"asc"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"stats"</span>: &#123;</span><br><span class="line">                    <span class="attr">"extended_stats"</span>: &#123;<span class="attr">"field"</span>: <span class="string">"price"</span>&#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="基于’深度’度量排序-Sorting-Based-on-“Deep”-Metrics"><a href="#基于’深度’度量排序-Sorting-Based-on-“Deep”-Metrics" class="headerlink" title="基于’深度’度量排序(Sorting Based on “Deep” Metrics)"></a>基于’深度’度量排序(Sorting Based on “Deep” Metrics)</h3><ul>
<li>对’更深’的度量进行排序，将度量用尖括号(&gt;)嵌套起来表示。例如： red_green_cars&gt;stats.variance</li>
<li>嵌套路径上每个桶必须是单值。</li>
<li>多值桶（如：terms ）动态生成许多桶，无法通过指定一个确定路径来识别。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"histogram"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">              <span class="attr">"interval"</span>: <span class="number">20000</span>,</span><br><span class="line">              <span class="attr">"order"</span>: &#123;</span><br><span class="line">                <span class="attr">"red_green_cars&gt;stats.variance"</span> : <span class="string">"asc"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"red_green_cars"</span>: &#123;</span><br><span class="line">                    <span class="attr">"filter"</span>: &#123; <span class="attr">"terms"</span>: &#123;<span class="attr">"color"</span>: [<span class="string">"red"</span>, <span class="string">"green"</span>]&#125;&#125;,</span><br><span class="line">                    <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                        <span class="attr">"stats"</span>: &#123;<span class="attr">"extended_stats"</span>: &#123;<span class="attr">"field"</span> : <span class="string">"price"</span>&#125;&#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_sorting_multivalue_buckets.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/50_sorting_ordering.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>34-聚合-近似聚合</title>
    <url>/2020/03/17/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/34-%E8%81%9A%E5%90%88-%E8%BF%91%E4%BC%BC%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h3 id="近似聚合-Approximate-Aggregations"><a href="#近似聚合-Approximate-Aggregations" class="headerlink" title="近似聚合(Approximate Aggregations)"></a>近似聚合(Approximate Aggregations)</h3><p>在分布式环境中，有些算法可以精确计算，有些算法无法精确计算，各算法还需在性能、内存、实现性做出权衡。</p>
<a id="more"></a>
<p>三角因子模型：大数据、精确性和实时性。<br>选择其中两项：</p>
<ul>
<li>精确 + 实时 ：数据存入单台机器内存中，使用任何算法都会结果100%精确，响应会相对快速。</li>
<li>大数据 + 精确 ：传统的 Hadoop可以处理 PB 级的数据并且为提供精确答案，但响应不够及时。</li>
<li>大数据 + 实时 ：近似算法为我们提供准确但不精确的结果。</li>
</ul>
<p>Elasticsearch 目前支持两种近似算法：cardinality ， percentiles。<br>它们会提供准确但不是 100% 精确的结果。 以牺牲一点小小的估算错误为代价，这些算法可以为我们换来高速的执行效率和极小的内存消耗。</p>
<h2 id="近似算法：cardinality"><a href="#近似算法：cardinality" class="headerlink" title="近似算法：cardinality"></a>近似算法：cardinality</h2><h3 id="统计去重后的数量-Finding-Distinct-Counts"><a href="#统计去重后的数量-Finding-Distinct-Counts" class="headerlink" title="统计去重后的数量(Finding Distinct Counts)"></a>统计去重后的数量(Finding Distinct Counts)</h3><p>近似聚合 cardinality(基数）度量: 它提供一个字段的基数，即该字段的distinct或unique值的数目。<br>类似SQL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> color)</span><br><span class="line"><span class="keyword">FROM</span> cars</span><br></pre></td></tr></table></figure>
<p>去重</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"distinct_colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"cardinality"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">  "distinct_colors": &#123;</span><br><span class="line">     "value": 3</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每月有多少颜色的车被售出，将一个 cardinality 度量嵌入一个 date_histogram。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">      <span class="attr">"months"</span> : &#123;</span><br><span class="line">        <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">          <span class="attr">"field"</span>: <span class="string">"sold"</span>,</span><br><span class="line">          <span class="attr">"interval"</span>: <span class="string">"month"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">          <span class="attr">"distinct_colors"</span> : &#123;</span><br><span class="line">              <span class="attr">"cardinality"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"color"</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="学会权衡-Understanding-the-Trade-offs"><a href="#学会权衡-Understanding-the-Trade-offs" class="headerlink" title="学会权衡(Understanding the Trade-offs)"></a>学会权衡(Understanding the Trade-offs)</h5><p>cardinality 度量是一个近似算法。 它是基于 <a href="http://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf" target="_blank" rel="noopener">HyperLogLog++</a> （HLL）算法的。 HLL 会先对我们的输入作哈希运算，然后根据哈希运算的结果中的 bits 做概率估算从而得到基数。</p>
<p>这个算法的 特性 ：</p>
<ul>
<li>可配置的精度，用来控制内存的使用（更精确 ＝ 更多内存）。</li>
<li>小的数据集精度是非常高的。</li>
<li>我们可以通过配置参数，来设置去重需要的固定内存使用量。无论数千还是数十亿的唯一值，内存使用量只与你配置的精确度相关。</li>
</ul>
<p>通过 precision_threshold 参数来配置精度。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"distinct_colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"cardinality"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color"</span>,</span><br><span class="line">              <span class="attr">"precision_threshold"</span> : <span class="number">100</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>precision_threshold=100 表示100 以内时会得到非常准确的结果。</li>
<li>precision_threshold 接受 0–40,000 之间的数字，更大的值还是会被当作 40,000 来处理。</li>
<li>高于阈值的基数会节省内存而牺牲准确度，同时也会对度量结果带入误差。</li>
<li>在实际应用中， 100 的阈值可以在唯一值为百万的情况下仍然将误差维持 5% 以内。</li>
</ul>
<h5 id="速度优化-Optimizing-for-Speed"><a href="#速度优化-Optimizing-for-Speed" class="headerlink" title="速度优化(Optimizing for Speed)"></a>速度优化(Optimizing for Speed)</h5><ul>
<li>HyperLogLog 的速度已经很快了，它只是在统计时对数据做哈希以及一些位操作。如果做进一步优化，索引时预先计算好字段内容的哈希值，查询时跳过哈希计算然后将哈希值从fielddata直接加载。</li>
<li>预先计算哈希值只对内容很长或者基数很高的字段有用，计算这些字段的哈希值的消耗在查询时是无法忽略的。</li>
<li>预先计算并不能保证所有的字段都更快，它只对那些具有高基数和/或者内容很长的字符串字段有作用。</li>
</ul>
<p>创建索引时新增一个字段映射，该映射包括哈希值字段。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /cars/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"transactions"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"color"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"hash"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>: <span class="string">"murmur3"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多值字段的类型是 murmur3 ，这是一个哈希函数。</li>
<li>使用murmur3需要安装插件 map-murmur3 (执行命令 sudo bin/elasticsearch-plugin install mapper-murmur3)</li>
</ul>
<p>使用 color.hash 字段进行去重。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /cars/transactions/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"distinct_colors"</span> : &#123;</span><br><span class="line">            <span class="attr">"cardinality"</span> : &#123;</span><br><span class="line">              <span class="attr">"field"</span> : <span class="string">"color.hash"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="百分位数-计算-Calculating-Percentiles"><a href="#百分位数-计算-Calculating-Percentiles" class="headerlink" title="百分位数 计算(Calculating Percentiles)"></a>百分位数 计算(Calculating Percentiles)</h3><p>percentiles 百分位数 度量也是一个近似度量。<br>百分位数展现某以具体百分比下观察到的数值。例如，第95个百分位上的数值，是高于 95% 的数据总和。<br>百分位数通常用来找出异常。</p>
<p>新增测试数据,包含三个值：延时、数据中心的区域以及时间戳。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /website/logs/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">100</span>, <span class="attr">"zone"</span> : <span class="string">"US"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">80</span>, <span class="attr">"zone"</span> : <span class="string">"US"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-29"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">99</span>, <span class="attr">"zone"</span> : <span class="string">"US"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-29"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">102</span>, <span class="attr">"zone"</span> : <span class="string">"US"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">75</span>, <span class="attr">"zone"</span> : <span class="string">"US"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">82</span>, <span class="attr">"zone"</span> : <span class="string">"US"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-29"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">100</span>, <span class="attr">"zone"</span> : <span class="string">"EU"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">280</span>, <span class="attr">"zone"</span> : <span class="string">"EU"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-29"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">155</span>, <span class="attr">"zone"</span> : <span class="string">"EU"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-29"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">623</span>, <span class="attr">"zone"</span> : <span class="string">"EU"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">380</span>, <span class="attr">"zone"</span> : <span class="string">"EU"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-28"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123;&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"latency"</span> : <span class="number">319</span>, <span class="attr">"zone"</span> : <span class="string">"EU"</span>, <span class="attr">"timestamp"</span> : <span class="string">"2014-10-29"</span> &#125;</span><br></pre></td></tr></table></figure>

<p>查询百分位数</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/logs/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"load_times"</span> : &#123;</span><br><span class="line">            <span class="attr">"percentiles"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"latency"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"avg_load_time"</span> : &#123;</span><br><span class="line">            <span class="attr">"avg"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"latency"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>percentiles 度量会返回一组预定义的百分位数值： [1, 5, 25, 50, 75, 95, 99],它们表示了人们感兴趣的常用百分位数值，极端的百分位数在范围的两边，其他的一些处于中部。</li>
</ul>
<p>返回结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">  "zones": &#123;</span><br><span class="line">     "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">"key"</span>: <span class="string">"eu"</span>,</span><br><span class="line">           <span class="attr">"doc_count"</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">"load_times"</span>: &#123;</span><br><span class="line">              <span class="attr">"values"</span>: &#123;</span><br><span class="line">                 <span class="attr">"50.0"</span>: <span class="number">299.5</span>,</span><br><span class="line">                 <span class="attr">"95.0"</span>: <span class="number">562.25</span>,</span><br><span class="line">                 <span class="attr">"99.0"</span>: <span class="number">610.85</span></span><br><span class="line">              &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attr">"load_avg"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="number">309.5</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">"key"</span>: <span class="string">"us"</span>,</span><br><span class="line">           <span class="attr">"doc_count"</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">"load_times"</span>: &#123;</span><br><span class="line">              <span class="attr">"values"</span>: &#123;</span><br><span class="line">                 <span class="attr">"50.0"</span>: <span class="number">90.5</span>,</span><br><span class="line">                 <span class="attr">"95.0"</span>: <span class="number">101.5</span>,</span><br><span class="line">                 <span class="attr">"99.0"</span>: <span class="number">101.9</span></span><br><span class="line">              &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attr">"load_avg"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="number">89.66666666666667</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="百分位数-排行-Percentile-Ranks"><a href="#百分位数-排行-Percentile-Ranks" class="headerlink" title="百分位数 排行(Percentile Ranks)"></a>百分位数 排行(Percentile Ranks)</h5><ul>
<li>percentile_ranks : percentile_ranks度量告诉我们落在某个百分比一下的所有文档的最小值。</li>
<li>percentile_ranks 与 percentile 是双向关系，percentile给出百分比对应的数据，percentile_ranks给出数据对应的百分比。</li>
</ul>
<p>查询 200和800对应点百分位</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /website/logs/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"zones"</span> : &#123;</span><br><span class="line">            <span class="attr">"terms"</span> : &#123;</span><br><span class="line">                <span class="attr">"field"</span> : <span class="string">"zone"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">                <span class="attr">"load_times"</span> : &#123;</span><br><span class="line">                    <span class="attr">"percentile_ranks"</span> : &#123;</span><br><span class="line">                      <span class="attr">"field"</span> : <span class="string">"latency"</span>,</span><br><span class="line">                      <span class="attr">"values"</span> : [<span class="number">210</span>, <span class="number">800</span>]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">  "zones": &#123;</span><br><span class="line">     "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">"key"</span>: <span class="string">"eu"</span>,</span><br><span class="line">           <span class="attr">"doc_count"</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">"load_times"</span>: &#123;</span><br><span class="line">              <span class="attr">"values"</span>: &#123;</span><br><span class="line">                 <span class="attr">"210.0"</span>: <span class="number">31.944444444444443</span>,</span><br><span class="line">                 <span class="attr">"800.0"</span>: <span class="number">100</span></span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">"key"</span>: <span class="string">"us"</span>,</span><br><span class="line">           <span class="attr">"doc_count"</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">"load_times"</span>: &#123;</span><br><span class="line">              <span class="attr">"values"</span>: &#123;</span><br><span class="line">                 <span class="attr">"210.0"</span>: <span class="number">100</span>,</span><br><span class="line">                 <span class="attr">"800.0"</span>: <span class="number">100</span></span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“800”:100,表示800秒的要求所有请求都满足了</li>
<li>eu欧洲 小于210秒的只有31%。</li>
</ul>
<h5 id="学会平衡-Understanding-the-Trade-offs"><a href="#学会平衡-Understanding-the-Trade-offs" class="headerlink" title="学会平衡(Understanding the Trade-offs)"></a>学会平衡(Understanding the Trade-offs)</h5><ul>
<li>计算百分位需要一个近似算法。 朴素的 实现会维护一个所有值的有序列表， 但当我们有几十亿数据分布在几十个节点时，这几乎是不可能的。</li>
<li>percentiles 使用一个 TDigest 算法，（由 Ted Dunning 在 <a href="https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf" target="_blank" rel="noopener">Computing Extremely Accurate Quantiles Using T-Digests</a> 里面提出的）。</li>
<li>TDigest 算法特性：<ul>
<li>百分位的准确度与百分位的 极端程度 相关，也就是说 1 或 99 的百分位要比 50 百分位要准确。这只是数据结构内部机制的一种特性，但这是一个好的特性，因为多数人只关心极端的百分位。</li>
<li>对于数值集合较小的情况，百分位非常准确。如果数据集足够小，百分位可能 100% 精确。</li>
<li>随着桶里数值的增长，算法会开始对百分位进行估算。它能有效在准确度和内存节省之间做出权衡。 不准确的程度比较难以总结，因为它依赖于 聚合时数据的分布以及数据量的大小。</li>
</ul>
</li>
<li>percentiles中可以通过修改参数 compression 来控制内存与准确度之间的比值。</li>
<li>TDigest 算法用节点近似计算百分比：节点越多，准确度越高（同时内存消耗也越大），这都与数据量成正比。 compression 参数限制节点的最大数目为 20 * compression 。</li>
<li>压缩比值：默认的压缩比值是 100，通过增加压缩比值，可以以消耗更多内存为代价提高百分位数准确性。更大的压缩比值会使算法运行更慢，因为底层的树形数据结构的存储也会增长，也导致操作的代价更高。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_approximate_aggregations.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/55_approx_intro.asciidoc" target="_blank" rel="noopener">英文参考</a><br><a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/60_cardinality.asciidoc" target="_blank" rel="noopener">英文参考2</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>35-聚合-通过聚合发现异常指标</title>
    <url>/2020/03/18/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/35-%E8%81%9A%E5%90%88-%E9%80%9A%E8%BF%87%E8%81%9A%E5%90%88%E5%8F%91%E7%8E%B0%E5%BC%82%E5%B8%B8%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h3 id="Significant-Terms"><a href="#Significant-Terms" class="headerlink" title="(Significant Terms)"></a>(Significant Terms)</h3><ul>
<li>significant_terms （SigTerms）聚合分析统计你的数据并通过对比正常数据找到可能有异常频次的指标。</li>
<li>（SigTerms）聚合不同于其他聚合，它有着不同的工作机制，它不是简单的数学计算，有点像机器学习。</li>
</ul>
<a id="more"></a>
<p>应用场景：</p>
<ul>
<li>对于信用卡数据，我们可能会想找出信用卡欺诈。</li>
<li>对于电商数据，我们可能会想找出未被识别的人口信息，从而进行更高效的市场推广。</li>
<li>如果我们正在分析日志，我们可能会发现一个服务器会抛出比它本应抛出的更多异常。</li>
</ul>
<h3 id="significant-terms演示"><a href="#significant-terms演示" class="headerlink" title="significant_terms演示"></a>significant_terms演示</h3><p>无法下载demo数据。略过此节</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/significant-terms.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/70_sigterms_intro.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>36-聚合-Doc Values and Fielddata</title>
    <url>/2020/03/16/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/36-%E8%81%9A%E5%90%88-Doc%20Values%20and%20Fielddata/</url>
    <content><![CDATA[<h3 id="Doc-Values"><a href="#Doc-Values" class="headerlink" title="Doc Values"></a>Doc Values</h3><ul>
<li>Doc Values数据结构可以使用聚合更快、更高效并且内存友好。</li>
<li>倒排索引的优势是通过某个项(term)找文档，而相反操作并不高效，即：确定哪些项是否存在单个文档里，聚合需要这种次级的访问模式。</li>
<li>搜索使用倒排索引查找文档，聚合操作使用doc values数据进行收集和聚合。</li>
<li>Doc values 使用场景：1. 聚合 2. 排序 3. 访问字段值的脚本 4. 处理父子关系，任何需要查找某个文档包含的值的操作都必须使用它。</li>
</ul>
<a id="more"></a>
<p>倒排索引：<br>|Term   | Doc_1| Doc_2 | Doc_3|<br>| :—  |:—  | :—  |:—  |<br>|brown   |   X   |   X   | |<br>|dog     |   X   |       |   X|<br>|dogs    |       |   X   |   X|<br>|fox     |   X   |       |   X|<br>|foxes   |       |   X   |    |<br>|in      |       |   X   |    |<br>|jumped  |   X   |       |   X|<br>|lazy    |   X   |   X   |    |<br>|leap    |       |   X   |    |<br>|over    |   X   |   X   |   X|<br>|quick   |   X   |   X   |   X|<br>|summer  |       |   X   |    |<br>|the     |   X   |       |   X|</p>
<p>doc values 结构：<br>| doc | terms    |<br>| :— | :————- |<br>|Doc_1 | brown, dog, fox, jumped, lazy, over, quick, the      |<br>|Doc_2 | brown, dogs, foxes, in, lazy, leap, over, quick, summer  |<br>|Doc_3 | dog, dogs, fox, jumped, over, quick, the  |</p>
<p>查询语句：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"match"</span> : &#123;</span><br><span class="line">      <span class="attr">"body"</span> : <span class="string">"brown"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">    <span class="attr">"popular_terms"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span> : &#123;</span><br><span class="line">        <span class="attr">"field"</span> : <span class="string">"body"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤：</p>
<ol>
<li>查询部分：查询时在倒排索引的词项列表(已排序)中查找brown，找到brown后扫描所有列，找到包含brown的文档(Doc_1,Doc_2)。</li>
<li>聚合部分：利用doc Values数据结构，找到Doc_1,Doc_2，然后获取对应文档行，获取文档行中所有的词项，求两个集合的并集。</li>
</ol>
<h3 id="深入理解-Doc-Values"><a href="#深入理解-Doc-Values" class="headerlink" title="深入理解 Doc Values"></a>深入理解 Doc Values</h3><ul>
<li>Doc Values与倒排索引一样，是在索引时生成。</li>
<li>Doc Values与倒排索引一样，基于segement生成并且是不可变的。</li>
<li>Doc Values与倒排索引一样，会序列化到磁盘，对性能和扩展性很有帮助。</li>
<li>Doc Values通过序列化把数据持久到磁盘，它的好处是可以充分利用操作系统的内存，而不是JVM的heap。当Doc Valus很小时系统自动将它驻留内存，当Doc Valus 大于系统可用内存时，系统会根据需求从磁盘读取Doc Valus，然后选择性放到分页缓存中。</li>
<li>因为 Doc Values 不是由 JVM 来管理，所以 Elasticsearch 实例可以配置一个很小的 JVM Heap，这样给系统留出来更多的内存。同时更小的 Heap 可以让 JVM 更加快速和高效的回收。</li>
</ul>
<h5 id="列式存储的压缩-Column-store-compression"><a href="#列式存储的压缩-Column-store-compression" class="headerlink" title="列式存储的压缩(Column-store compression)"></a>列式存储的压缩(Column-store compression)</h5><ul>
<li>Doc Values本质上是一个序列化的列式存储。列式存储适用于 聚合、排序、脚本等操作。</li>
<li>列式存储也便于压缩，特别是数字类型。压缩后好处：减少磁盘空间，提高访问速度。</li>
</ul>
<p>Doc Values 在压缩过程中使用如下技巧。依次检测以下压缩模式:</p>
<ol>
<li>如果所有的数值各不相同（或缺失），设置一个标记并记录这些值</li>
<li>如果这些值小于 256，将使用一个简单的编码表</li>
<li>如果这些值大于 256，检测是否存在一个最大公约数</li>
<li>如果没有存在最大公约数，从最小的数值开始，统一计算偏移量进行编码</li>
</ol>
<h5 id="禁用Doc-Values"><a href="#禁用Doc-Values" class="headerlink" title="禁用Doc Values"></a>禁用Doc Values</h5><ul>
<li>Doc Values 默认对所有字段启用(除了 analyzed strings)。analyzed strings使用fielddata。</li>
<li>对不需要聚合、排序和脚本操作的字段禁用Doc Values，可以节省磁盘空间，提升索引的速度</li>
</ul>
<p>使用doc_values :false禁用Doc Values</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"my_type"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"session_id"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"index"</span>:      <span class="string">"not_analyzed"</span>,</span><br><span class="line">          <span class="attr">"doc_values"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以设置字段 doc_values: true 和 index: no ，该字段无法被搜索到，只能被用于聚合、排序、脚本操作。</p>
<h3 id="聚合与分析-Aggregations-and-Analysis"><a href="#聚合与分析-Aggregations-and-Analysis" class="headerlink" title="聚合与分析(Aggregations and Analysis)"></a>聚合与分析(Aggregations and Analysis)</h3><p>如果对analyzed字符串进行聚合，有两个原因会影响聚合：分析影响聚合中使用的 tokens ，并且 doc values 不能使用于 分析字符串。</p>
<h5 id="分析字符串和Fielddata-Analyzed-strings-and-Fielddata"><a href="#分析字符串和Fielddata-Analyzed-strings-and-Fielddata" class="headerlink" title="分析字符串和Fielddata(Analyzed strings and Fielddata)"></a>分析字符串和Fielddata(Analyzed strings and Fielddata)</h5><ul>
<li>Doc values 不支持 analyzed 字符串字段，因为它们不能很有效的表示多值字符串。Doc values 最有效的是，当每个文档都有一个或几个tokens时， 但不是无数的分析字符串（想象一个 PDF ，可能有几兆字节并有数以千计的独特 tokens）。</li>
<li>如果对分析字符串使用聚合？ 答案是：使用fielddata数据结构。</li>
<li>fielddata构建和管理100%在内存中，常驻于JVM内存堆。</li>
<li>从历史上看，fielddata 是 所有 字段的默认设置。但是 Elasticsearch 已迁移到 doc values 以减少 OOM 的几率。分析的字符串是仍然使用 fielddata 的最后一块阵地。 最终目标是建立一个序列化的数据结构类似于 doc values ，可以处理高维度的分析字符串，逐步淘汰 fielddata。</li>
</ul>
<h5 id="高基数内存的影响-High-Cardinality-Memory-Implications"><a href="#高基数内存的影响-High-Cardinality-Memory-Implications" class="headerlink" title="高基数内存的影响(High-Cardinality Memory Implications)"></a>高基数内存的影响(High-Cardinality Memory Implications)</h5><p>避免分析字段的另外一个原因就是：高基数字段在加载到 fielddata 时会消耗大量内存。<br>分析的过程会经常（尽管不总是这样）生成大量的 token，这些 token 大多都是唯一的。 这会增加字段的整体基数并且带来更大的内存压力。</p>
<p>因此，在聚合字符串字段之前，请评估情况：</p>
<ul>
<li>这是一个 not_analyzed 字段吗？如果是，可以通过 doc values 节省内存 。</li>
<li>否则，这是一个 analyzed 字段，它将使用 fielddata 并加载到内存中。这个字段因为 ngrams 有一个非常大的基数？如果是，这对于内存来说极度不友好。</li>
</ul>
<h3 id="circuit-breaker-fd-settings"><a href="#circuit-breaker-fd-settings" class="headerlink" title="circuit_breaker_fd_settings"></a>circuit_breaker_fd_settings</h3><h3 id="限制内存使用-Limiting-Memory-Usage"><a href="#限制内存使用-Limiting-Memory-Usage" class="headerlink" title="限制内存使用(Limiting Memory Usage)"></a>限制内存使用(Limiting Memory Usage)</h3><ul>
<li>Fielddata 是 延迟 加载。没聚合过分析字符串就不会加载fielddata到内存中。</li>
<li>fielddata 是基于字段加载的， 这意味着只有很活跃地使用字段才会增加 fielddata 的负担。</li>
<li>即是你查询少数几个文档，但fielddata 会加载索引中（针对该特定字段的）所有的文档。</li>
<li>fielddata 在查询运行时，动态填充。</li>
<li>fielddata使用的是JVM堆资源</li>
</ul>
<p>在设置 Elasticsearch 堆大小时需要通过 $ES_HEAP_SIZE 环境变量应用两个规则：</p>
<h5 id="选择堆大小（Choosing-a-Heap-Size）"><a href="#选择堆大小（Choosing-a-Heap-Size）" class="headerlink" title="选择堆大小（Choosing a Heap Size）"></a>选择堆大小（Choosing a Heap Size）</h5><ul>
<li>不要超过可用 RAM 的 50%。Lucene 能很好利用文件系统的缓存，它是通过系统内核管理的。如果没有足够的文件系统缓存空间，性能会受到影响。 此外，专用于堆的内存越多意味着其他所有使用 doc values 的字段内存越少。</li>
<li>不要超过 32 GB。 如果堆大小小于 32 GB，JVM 可以利用指针压缩，这可以大大降低内存的使用：每个指针 4 字节而不是 8 字节。</li>
</ul>
<h5 id="Fielddata的大小"><a href="#Fielddata的大小" class="headerlink" title="Fielddata的大小"></a>Fielddata的大小</h5><ul>
<li>indices.fielddata.cache.size 控制为 fielddata 分配的堆空间大小。</li>
<li>indices.fielddata.cache.size 默认情况下，设置都是 unbounded ，Elasticsearch 永远都不会从 fielddata 中回收数据。</li>
<li>一个有界的大小会强制数据结构回收数据。</li>
<li>一个使用场景：日志，每天使用新索引，只对最近几天数据感兴趣。</li>
</ul>
<blockquote>
<p>如果没有足够空间可以将 fielddata 保留在内存中，Elasticsearch 就会时刻从磁盘重载数据，并回收其他数据以获得更多空间。内存的回收机制会导致重度磁盘I/O，并且在内存中生成很多垃圾，这些垃圾必须在晚些时候被回收掉。</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以设置堆大小的百分比，也可以是某个值，例如： 5gb 。</span></span><br><span class="line"><span class="comment"># 最久未使用（LRU）的 fielddata 会被回收为新数据腾出空间。</span></span><br><span class="line"><span class="meta">indices.fielddata.cache.size</span>:  <span class="string">20%</span></span><br></pre></td></tr></table></figure>

<h5 id="监控fielddata-Monitoring-fielddata"><a href="#监控fielddata-Monitoring-fielddata" class="headerlink" title="监控fielddata(Monitoring fielddata)"></a>监控fielddata(Monitoring fielddata)</h5><p>监控fielddata的内存使用情况，监控数据被回收情况。</p>
<p>监控方法：</p>
<ul>
<li>按索引使用 <a href="http://www.elastic.co/guide/en/elasticsearch/reference/current/indices-stats.html" target="_blank" rel="noopener">indices-stats API</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_stats&#x2F;fielddata?fields&#x3D;*</span><br></pre></td></tr></table></figure></li>
<li>按节点使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/cluster-nodes-stats.html" target="_blank" rel="noopener">nodes-stats API</a> ：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_nodes&#x2F;stats&#x2F;indices&#x2F;fielddata?fields&#x3D;*</span><br></pre></td></tr></table></figure></li>
<li>按索引节点<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;_nodes&#x2F;stats&#x2F;indices&#x2F;fielddata?level&#x3D;indices&amp;fields&#x3D;*</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="断路器-Circuit-Breaker"><a href="#断路器-Circuit-Breaker" class="headerlink" title="断路器(Circuit Breaker)"></a>断路器(Circuit Breaker)</h5><p>面临的问题：fielddata大小设置是在数据加载之后才检查的，如果加载的数据大于内存，就会发生OutOfMemoryException。<br>解决方法：使用 fielddata 断路器(Circuit Breaker)。</p>
<p>断路器工作原理：断路器通过内部检查(字段类型，基数，大小等)来估算一个查询需要的内存大小，判断加载的数据是否超出配置比例，如果超出限制就会触发断路器，中止查询并返回异常。<br>断路器工作发生在加载之前，不会引起OutOfMemoryException。</p>
<p>可用的断路器（Available Circuit Breakers）,修改配置config/elasticsearch.yml</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># fielddata 断路器, 默认设置堆的 60% 作为 fielddata 大小的上限。</span></span><br><span class="line"><span class="meta">indices.breaker.fielddata.limit</span> : <span class="string">60%</span></span><br><span class="line"><span class="comment"># request 断路器, 估算需要完成其他请求部分的结构大小，例如创建一个聚合桶，默认限制是堆内存的 40%。</span></span><br><span class="line"><span class="meta">indices.breaker.request.limit</span> : <span class="string">40%</span></span><br><span class="line"><span class="comment"># total 结合 request 和 fielddata 断路器保证两者组合起来不会使用超过堆内存的 70%。</span></span><br><span class="line"><span class="meta">indices.breaker.total.limit</span> : <span class="string">70%</span></span><br></pre></td></tr></table></figure>

<p>也可以动态修改</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /_cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"persistent"</span> : &#123;</span><br><span class="line">    <span class="attr">"indices.breaker.fielddata.limit"</span> : <span class="string">"40%"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好为断路器设置一个相对保守点的值。</p>
<blockquote>
<p>记住 fielddata 需要与 request 断路器共享堆内存、索引缓冲内存和过滤器缓存。<br>Lucene 的数据被用来构造索引，以及各种其他临时的数据结构。 正因如此，它默认值非常保守，只有 60% 。过于乐观的设置可能会引起潜在的堆栈溢出（OOM）异常，这会使整个节点宕掉。<br>另一方面，过度保守的值只会返回查询异常，应用程序可以对异常做相应处理。异常比服务器崩溃要好。这些异常应该也能促进我们对查询进行重新评估：为什么单个查询需要超过堆内存的 60% 之多？</p>
</blockquote>
<p>断路器的限制 必须 要比缓存大小要高.</p>
<blockquote>
<p>在 Fielddata的大小 中，我们提过关于给 fielddata 的大小加一个限制，从而确保旧的无用 fielddata 被回收的方法。 indices.fielddata.cache.size 和 indices.breaker.fielddata.limit 之间的关系非常重要。 如果断路器的限制低于缓存大小，没有数据会被回收。为了能正常工作，断路器的限制 必须 要比缓存大小要高。</p>
</blockquote>
<h3 id="Fielddata-的过滤"><a href="#Fielddata-的过滤" class="headerlink" title="Fielddata 的过滤"></a>Fielddata 的过滤</h3><p>Fielddata过滤实际上是在忽略数据，避免大量的无用的长尾项，也可以节省内存。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /music/_mapping/song</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"tag"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">      <span class="attr">"fielddata"</span>: &#123;</span><br><span class="line">        <span class="attr">"filter"</span>: &#123;</span><br><span class="line">          <span class="attr">"frequency"</span>: &#123;</span><br><span class="line">            <span class="attr">"min"</span>:              <span class="number">0.01</span>,</span><br><span class="line">            <span class="attr">"min_segment_size"</span>: <span class="number">500</span>  </span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fielddata 关键字允许我们配置 fielddata 处理该字段的方式。</li>
<li>frequency 过滤器允许我们基于项频率过滤加载 fielddata。</li>
<li>min：0.01 只加载那些至少在本段文档中出现 1% 的项。</li>
<li>min_segment_size :500 忽略任何文档个数小于 500 的段。</li>
</ul>
<p>词频是按照段来计算的。这是实现的一个限制：fielddata 是按段来加载的，所以可见的词频只是该段内的频率。但是，这个限制也有些有趣的特性：它可以让受欢迎的新项迅速提升到顶部。</p>
<p>min_segment_size 参数要求 Elasticsearch 忽略某个大小以下的段。 如果一个段内只有少量文档，它的词频会非常粗略没有任何意义。 小的分段会很快被合并到更大的分段中，某一刻超过这个限制，将会被纳入计算。</p>
<blockquote>
<p>通过频次来过滤项并不是唯一的选择，我们也可以使用正则式来决定只加载那些匹配的项。例如，我们可以用 regex 过滤器 处理 twitte 上的消息只将以 # 号开始的标签加载到内存中。 这假设我们使用的分析器会保留标点符号，像 whitespace 分析器。</p>
</blockquote>
<h3 id="预加载fielddata"><a href="#预加载fielddata" class="headerlink" title="预加载fielddata"></a>预加载fielddata</h3><p>fielddata加载到内存，默认是 延迟 加载。<br>延迟加载：当ES第一次查询某个字段时，它将会完整加载这个字段所有segment中的倒排索引到内存中，以便于以后的查询能够获取更好的性能。</p>
<p>解决延时高峰三种方式:</p>
<ul>
<li>预加载fielddata</li>
<li>预加载全局序号</li>
<li>缓存预热<br>三种方式都基于同一概念：预加载fielddata</li>
</ul>
<h5 id="预加载fielddata-Eagerly-Loading-Fielddata"><a href="#预加载fielddata-Eagerly-Loading-Fielddata" class="headerlink" title="预加载fielddata(Eagerly Loading Fielddata)"></a>预加载fielddata(Eagerly Loading Fielddata)</h5><p>启动字段预加载就是对分段里的fielddata提取加载。<br>预加载是按字段启用的</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /music/_mapping/_song</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"tags"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"fielddata"</span>: &#123;</span><br><span class="line">      <span class="attr">"loading"</span> : <span class="string">"eager"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 fielddata.loading: eager 可以告诉 Elasticsearch 预先将此字段的内容载入内存中。</li>
<li>fielddata.loading 支持 lazy, eager 两种模式。</li>
</ul>
<h5 id="全局序号-Global-Ordinals"><a href="#全局序号-Global-Ordinals" class="headerlink" title="全局序号(Global Ordinals)"></a>全局序号(Global Ordinals)</h5><ul>
<li>有一种可以用来降低字符串fielddata内存使用的技术叫做 序号。</li>
<li>字段中包含的所有值用序号来一一对应，加载fielddata时使用序号代替原始值。序号的构建只被应用于字符串。</li>
<li>全局序号是一个构建在 fielddata 之上的数据结构，它只占用少量内存。</li>
<li>唯一值是 跨所有分段 识别的，然后将它们存入一个序号列表中。</li>
<li>terms 聚合可以对全局序号进行聚合操作，将序号转换成真实字符串值的过程只会在聚合结束时发生一次。这会将聚合（和排序）的性能提高三到四倍。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">Ordinal</th>
<th align="left">Term</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">status_deleted</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">status_pending</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">status_published</td>
</tr>
</tbody></table>
<h5 id="构建全局序号-Building-global-ordinals"><a href="#构建全局序号-Building-global-ordinals" class="headerlink" title="构建全局序号(Building global ordinals)"></a>构建全局序号(Building global ordinals)</h5><ul>
<li>全局序号分布在索引的所有段中，所以如果新增或删除一个分段时，需要对全局序号进行重建。</li>
<li>重建需要读取每个分段的每个唯一项，基数越高（即存在更多的唯一项）这个过程会越长。</li>
<li>全局序号默认也是延迟构建的。首次访问索引内 fielddata 的请求会促发全局序号的构建。</li>
<li>一旦全局序号发生重建，仍会使用旧的全局序号，直到索引中的分段产生变化：在刷新、写入或合并之后。</li>
</ul>
<h5 id="预构建全局序号-Eager-global-ordinals"><a href="#预构建全局序号-Eager-global-ordinals" class="headerlink" title="预构建全局序号(Eager global ordinals)"></a>预构建全局序号(Eager global ordinals)</h5><p>单个字符串字段 可以通过配置预先构建全局序号：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /music/_mapping/_song</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"song_title"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">    <span class="attr">"fielddata"</span>: &#123;</span><br><span class="line">      <span class="attr">"loading"</span> : <span class="string">"eager_global_ordinals"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>预建全局序号会对数据的 实时性 产生影响，构建一个高基数的全局序号会使一个刷新延时数秒。 选择在于是每次刷新时付出代价，还是在刷新后的第一次查询时。如果经常索引而查询较少，那么在查询时付出代价要比每次刷新时要好。如果写大于读，那么在选择在查询时重建全局序号将会是一个更好的选择。</p>
<blockquote>
<p>针对实际场景优化全局序号的重建频次。如果我们有高基数字段需要花数秒钟重建，增加 refresh_interval 的刷新的时间从而可以使我们的全局序号保留更长的有效期，这也会节省 CPU 资源，因为我们重建的频次下降了。</p>
</blockquote>
<h3 id="索引预热器-Index-Warmers"><a href="#索引预热器-Index-Warmers" class="headerlink" title="索引预热器(Index Warmers)"></a>索引预热器(Index Warmers)</h3><ul>
<li>预热器早于 fielddata 预加载和全局序号预加载之前出现，它们仍然有其存在的理由。</li>
<li>一个索引预热器允许我们指定一个查询和聚合须要在新分片对于搜索可见之前执行。 这个想法是通过预先填充或 预热缓存 让用户永远无法遇到延迟的波峰。</li>
<li>预热器是根据具体索引注册的， 每个预热器都有唯一的 ID ，因为每个索引可能有多个预热器。</li>
<li>预热器主要用来预建过滤器缓存，也可以用它来预加载 fielddata。</li>
<li>当新建一个分段时，Elasticsearch 将会执行注册在预热器中的查询。执行这些查询会强制加载缓存，只有在所有预热器执行完，这个分段才会对搜索可见。</li>
</ul>
<p>注册一个预热器然后解释发生了什么：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /music/_warmer/warmer_1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span> : &#123;</span><br><span class="line">    <span class="attr">"bool"</span> : &#123;</span><br><span class="line">      <span class="attr">"filter"</span> : &#123;</span><br><span class="line">        <span class="attr">"bool"</span>: &#123;</span><br><span class="line">          <span class="attr">"should"</span>: [</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"rock"</span>        &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"hiphop"</span>      &#125;&#125;,</span><br><span class="line">            &#123; <span class="attr">"term"</span>: &#123; <span class="attr">"tag"</span>: <span class="string">"electronics"</span> &#125;&#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">    <span class="attr">"price"</span> : &#123;</span><br><span class="line">      <span class="attr">"histogram"</span> : &#123;</span><br><span class="line">        <span class="attr">"field"</span> : <span class="string">"price"</span>,</span><br><span class="line">        <span class="attr">"interval"</span> : <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>预热器被关联到索引（ music ）上，使用接入口 <code>_warmer</code> 以及 ID （ warmer_1 ）。</li>
<li>should 为三种最受欢迎的曲风预建过滤器缓存。</li>
<li>字段 price 的 fielddata 和全局序号会被预加载。</li>
</ul>
<h3 id="优化聚合查询"><a href="#优化聚合查询" class="headerlink" title="优化聚合查询"></a>优化聚合查询</h3><h5 id="Preventing-Combinatorial-Explosions"><a href="#Preventing-Combinatorial-Explosions" class="headerlink" title="Preventing Combinatorial Explosions"></a>Preventing Combinatorial Explosions</h5><h5 id="深度优先与广度优先-Depth-First-Versus-Breadth-First"><a href="#深度优先与广度优先-Depth-First-Versus-Breadth-First" class="headerlink" title="深度优先与广度优先(Depth-First Versus Breadth-First)"></a>深度优先与广度优先(Depth-First Versus Breadth-First)</h5><ul>
<li>Elasticsearch默认集合模式(collection mode)是 深度优先，它先构建完整的树，然后修剪无用节点。</li>
<li>某些应用场景需要使用 广度优先，广度优先先执行第一层聚合，做修剪完后再继续下一层聚合。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">    <span class="attr">"actors"</span> : &#123;</span><br><span class="line">      <span class="attr">"terms"</span> : &#123;</span><br><span class="line">         <span class="attr">"field"</span> :        <span class="string">"actors"</span>,</span><br><span class="line">         <span class="attr">"size"</span> :         <span class="number">10</span>,</span><br><span class="line">         <span class="attr">"collect_mode"</span> : <span class="string">"breadth_first"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span> : &#123;</span><br><span class="line">        <span class="attr">"costars"</span> : &#123;</span><br><span class="line">          <span class="attr">"terms"</span> : &#123;</span><br><span class="line">            <span class="attr">"field"</span> : <span class="string">"actors"</span>,</span><br><span class="line">            <span class="attr">"size"</span> :  <span class="number">5</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>广度优先仅仅适用于每个组的聚合数量远远小于当前总组数的情况下，因为广度优先会在内存中缓存裁剪后的仅仅需要缓存的每个组的所有数据，以便于它的子聚合分组查询可以复用上级聚合的数据。</p>
<p>广度优先的内存使用情况与裁剪后的缓存分组数据量是成线性的。对于很多聚合来说，每个桶内的文档数量是相当大的。 想象一种按月分组的直方图，总组数肯定是固定的，因为每年只有12个月，这个时候每个月下的数据量可能非常大。这使广度优先不是一个好的选择，这也是为什么深度优先作为默认策略的原因。</p>
<p>针对上面演员的例子，如果数据量越大，那么默认的使用深度优先的聚合模式生成的总分组数就会非常多，但是预估二级的聚合字段分组后的数据量相比总的分组数会小很多所以这种情况下使用广度优先的模式能大大节省内存，从而通过优化聚合模式来大大提高了在某些特定场景下聚合查询的成功率。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>桶与度量的嵌套能力，</li>
<li>基数与百分位数的快速估算能力，定位信息中统计异常的能力</li>
<li>只有不分词的 string 类型的字段才能使用Doc Values</li>
</ul>
<p>内存的管理形式有多种形式，这取决于我们特定的应用场景：</p>
<ul>
<li>在规划时，组织好数据，使聚合运行在 not_analyzed 字符串而不是 analyzed 字符串，这样可以有效的利用 doc values 。</li>
<li>在测试时，验证分析链不会在之后的聚合计算中创建高基数字段。</li>
<li>在搜索时，合理利用近似聚合和数据过滤。</li>
<li>在节点层，设置硬内存大小以及动态的断熔限制。</li>
<li>在应用层，通过监控集群内存的使用情况和 Full GC 的发生频率，来调整是否需要给集群资源添加更多的机器节点</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/docvalues-and-fielddata.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/master/300_Aggregations/90_docvalues.asciidoc" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>37-聚合-总结</title>
    <url>/2020/03/16/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/37-%E8%81%9A%E5%90%88-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="">中文参考</a>，<a href="">英文参考</a><br>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
<p>###</p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>38-地理位置-地理坐标点</title>
    <url>/2020/03/19/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/38-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE-%E5%9C%B0%E7%90%86%E5%9D%90%E6%A0%87%E7%82%B9/</url>
    <content><![CDATA[<h3 id="地理位置-Geolocation"><a href="#地理位置-Geolocation" class="headerlink" title="地理位置 (Geolocation)"></a>地理位置 (Geolocation)</h3><p>Elasticsearch 可以把地理位置、全文搜索、结构化搜索和分析结合到一起。</p>
<a id="more"></a>
<p>Elasticsearch两种表示地理位置的方式：</p>
<ol>
<li>geo_point : 用经度-纬度表示坐标点，计算两点间距离来排序或相关性打分、或聚合到地图上一个网格。</li>
<li>geo_shape : 以GeoJSON格式定义复杂的地理形状。 Geo-shapes纯粹是用来过滤，可以用来判断两形状是否重合或包含关系。</li>
</ol>
<h3 id="地理坐标点-Geo-Points"><a href="#地理坐标点-Geo-Points" class="headerlink" title="地理坐标点(Geo Points)"></a>地理坐标点(Geo Points)</h3><ul>
<li>地理坐标点 是指地球表面可以用经纬度描述的一个点</li>
<li>地理坐标点可以用来计算两个坐标间的距离</li>
<li>地理坐标点可以判断一个坐标是否在一个区域中，或在聚合中.</li>
<li>地理坐标点不能被动态映射（dynamic mapping）自动检测,需要显示声明类型为geo-point</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"restaurant"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"location"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"geo_point"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="经纬度坐标格式"><a href="#经纬度坐标格式" class="headerlink" title="经纬度坐标格式"></a>经纬度坐标格式</h3><p>添加数据：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions/restaurant/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:     <span class="string">"Chipotle Mexican Grill"</span>,</span><br><span class="line">  <span class="attr">"location"</span>: <span class="string">"40.715, -74.011"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /attractions/restaurant/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:     <span class="string">"Pala Pizza"</span>,</span><br><span class="line">  <span class="attr">"location"</span>: &#123;</span><br><span class="line">    <span class="attr">"lat"</span>:     <span class="number">40.722</span>,</span><br><span class="line">    <span class="attr">"lon"</span>:    <span class="number">-73.989</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /attractions/restaurant/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:     <span class="string">"Mini Munchies Pizza"</span>,</span><br><span class="line">  <span class="attr">"location"</span>: [ <span class="number">-73.983</span>, <span class="number">40.719</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串形式以半角逗号分割，如 “lat,lon” 。</li>
<li>对象形式显式命名为 lat 和 lon 。</li>
<li>数组形式表示为 [lon,lat] 。</li>
</ul>
<p>注意顺序：<br><code>地理坐标点用字符串形式表示时是纬度在前，经度在后（ &quot;latitude,longitude&quot; ）</code><br><code>数组形式表示时是经度在前，纬度在后（ [longitude,latitude] ）</code></p>
<blockquote>
<p> Elasticesearch 内部，不管字符串形式还是数组形式，都是经度在前，纬度在后。不过早期为了适配 GeoJSON 的格式规范，调整了数组形式的表示方式。</p>
</blockquote>
<h3 id="通过地理坐标点过滤"><a href="#通过地理坐标点过滤" class="headerlink" title="通过地理坐标点过滤"></a>通过地理坐标点过滤</h3><p>有四种地理坐标点过滤器：</p>
<ul>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geo-bounding-box.html" target="_blank" rel="noopener">geo_bounding_box</a> 找出落在指定矩形框中的点。</li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geo-distance.html" target="_blank" rel="noopener">geo_distance</a> 找出与指定位置在给定距离内的点。(圆形内的点)</li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geo-distance.html#geo-distance-range" target="_blank" rel="noopener">geo_distance_range</a> 找出与指定点距离在给定最小距离和最大距离之间的点。(圆环形内的点)</li>
<li><a href="">geo_polygon</a> 找出落在多边形中的点。 这个过滤器使用代价很大 。当你觉得自己需要使用它，最好先看看 geo-shapes 。</li>
</ul>
<p>过程：指定的区域被转换成一系列以quad/geohash为前缀的tokens，并被用来在倒排索引中搜索拥有相同tokens的文档。</p>
<blockquote>
<p>地理坐标过滤器使用代价昂贵 — 所以最好在文档集合尽可能少的场景下使用。你可以先使用那些简单快捷的过滤器，比如 term 或 range ，来过滤掉尽可能多的文档，最后才交给地理坐标过滤器处理。<br>布尔型过滤器 bool filter 会自动帮你做这件事。它会优先让那些基于“bitset”的简单过滤器(见 关于缓存 )来过滤掉尽可能多的文档，然后依次才是更昂贵的地理坐标过滤器或者脚本类的过滤器。</p>
</blockquote>
<h3 id="地理坐标盒模型过滤器-Geo-Bounding-Box-Filter"><a href="#地理坐标盒模型过滤器-Geo-Bounding-Box-Filter" class="headerlink" title="地理坐标盒模型过滤器(Geo Bounding Box Filter)"></a>地理坐标盒模型过滤器(Geo Bounding Box Filter)</h3><p>Geo Bounding Box Filter目前为止最有效的地理坐标过滤器了，因为它计算起来非常简单。<br>你指定一个矩形的 顶部, 底部, 左边界和右边界 ，然后过滤器只需判断坐标的经度是否在左右边界之间，纬度是否在上下边界之间。</p>
<p>原因： 过滤查询(filtered)已被弃用，并在ES 5.0中删除。<br>解决： 使用bool / must / filter查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.8</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-74.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"bottom_right"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.7</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-73.0</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这些坐标也可以用 bottom_left 和 top_right 来表示。</li>
</ul>
<h5 id="优化盒模型-Optimizing-Bounding-Boxes"><a href="#优化盒模型-Optimizing-Bounding-Boxes" class="headerlink" title="优化盒模型(Optimizing Bounding Boxes)"></a>优化盒模型(Optimizing Bounding Boxes)</h5><p>地理坐标盒模型过滤器 不需要把所有坐标点都加载到内存里。 因为它要做的 只是简单判断 lat 和 lon 坐标数值是否在给定的范围内，可以用倒排索引做一个 range 过滤来实现目标。</p>
<p>要使用这种优化方式，需要把 geo_point 字段 用 lat 和 lon 的方式分别映射到索引中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"restaurant"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"location"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:    <span class="string">"geo_point"</span>,</span><br><span class="line">          <span class="attr">"lat_lon"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>设置 type 参数为 indexed （替代默认值 memory ）来明确告诉 Elasticsearch 对这个过滤器使用倒排索引。</li>
<li>geo_point 类型的字段可以包含多个地理坐标点，但是针对经度纬度分别索引的这种优化方式只对包含单个坐标点的字段有效。</li>
</ul>
<h3 id="地理距离过滤器-Geo-Distance-Filter"><a href="#地理距离过滤器-Geo-Distance-Filter" class="headerlink" title="地理距离过滤器(Geo Distance Filter)"></a>地理距离过滤器(Geo Distance Filter)</h3><p>地理距离过滤器(geo_distance)以给定位置为圆心画一个圆，找出坐标在圆内的文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"filtered"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_distance"</span>: &#123;</span><br><span class="line">          <span class="attr">"distance"</span>: <span class="string">"1km"</span>,</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"lat"</span>:  <span class="number">40.715</span>,</span><br><span class="line">            <span class="attr">"lon"</span>: <span class="number">-73.988</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>找出所有与指定点距离在 1km 内的 location 字段。访问 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/common-options.html#distance-units" target="_blank" rel="noopener">Distance Units</a> 查看所支持的距离表示单位。</li>
<li>中心点可以表示为字符串，数组或对象。详见 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/lat-lon-formats.html" target="_blank" rel="noopener">经纬度坐标格式</a>。</li>
</ul>
<p>geo_distance处理方式：</p>
<blockquote>
<p>地理距离过滤器计算代价昂贵。Elasticsearch 先画一个矩形框来围住整个圆形，然后只在盒模型内的点用地理距离计算方式处理。</p>
</blockquote>
<p>疑问：是否需要如此精确的使用圆模型来做距离过滤？<br>通常使用矩形模型 bounding box 是比地理距离更高效的方式，并且往往也能满足应用需求。</p>
<h5 id="更快的地理距离计算"><a href="#更快的地理距离计算" class="headerlink" title="更快的地理距离计算"></a>更快的地理距离计算</h5><p>两点间距离有多种算法，这些算法都是以牺牲性能换取精度。<br>算法列表：</p>
<ul>
<li>arc : 球体。最慢但最精确的是 arc 计算方式，这种方式把世界当作球体来处理。不过这种方式的精度有限，因为这个世界并不是完全的球体。</li>
<li>plane : 平面。plane 计算方式把地球当成是平坦的，这种方式快一些但是精度略逊。在赤道附近的位置精度最好，而靠近两极则变差。</li>
<li>sloppy_arc : 默认的计算方式。如此命名，是因为它使用了 Lucene 的 SloppyMath 类。这是一种用精度换取速度的计算方式， 它使用 <a href="http://en.wikipedia.org/wiki/Haversine_formula" target="_blank" rel="noopener">Haversine formula</a> 来计算距离。它比 arc 计算方式快 4 到 5 倍，并且距离精度达 99.9%。</li>
</ul>
<p>指定不同的计算方式：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"filtered"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_distance"</span>: &#123;</span><br><span class="line">          <span class="attr">"distance"</span>:      <span class="string">"1km"</span>,</span><br><span class="line">          <span class="attr">"distance_type"</span>: <span class="string">"plane"</span>,</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"lat"</span>:  <span class="number">40.715</span>,</span><br><span class="line">            <span class="attr">"lon"</span>: <span class="number">-73.988</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="地理距离区间过滤器-geo-distance-range-Filter"><a href="#地理距离区间过滤器-geo-distance-range-Filter" class="headerlink" title="地理距离区间过滤器(geo_distance_range Filter)"></a>地理距离区间过滤器(geo_distance_range Filter)</h5><p>geo_distance 是一个圆形，geo_distance_range 过滤器是一个圆环状。</p>
<p>指定一个最小距离（使用gt或者gte）和最大距离（使用lt和lte），就像使用 range 过滤器一样.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"filtered"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_distance_range"</span>: &#123;</span><br><span class="line">          <span class="attr">"gte"</span>:    <span class="string">"1km"</span>,</span><br><span class="line">          <span class="attr">"lt"</span>:     <span class="string">"2km"</span>,</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"lat"</span>:  <span class="number">40.715</span>,</span><br><span class="line">            <span class="attr">"lon"</span>: <span class="number">-73.988</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="按距离排序-Sorting-by-Distance"><a href="#按距离排序-Sorting-by-Distance" class="headerlink" title="按距离排序(Sorting by Distance)"></a>按距离排序(Sorting by Distance)</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"filtered"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:       <span class="string">"indexed"</span>,</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.8</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-74.0</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"bottom_right"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.4</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-73.0</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"_geo_distance"</span>: &#123;</span><br><span class="line">        <span class="attr">"location"</span>: &#123;</span><br><span class="line">          <span class="attr">"lat"</span>:  <span class="number">40.715</span>,</span><br><span class="line">          <span class="attr">"lon"</span>: <span class="number">-73.998</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"order"</span>:         <span class="string">"asc"</span>,</span><br><span class="line">        <span class="attr">"unit"</span>:          <span class="string">"km"</span>,</span><br><span class="line">        <span class="attr">"distance_type"</span>: <span class="string">"plane"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_geo_distance.location</code> 计算每个文档中 location 字段与指定的 lat/lon 点间的距离。</li>
<li>将距离以 km 为单位写入到每个返回结果的 sort 键中。</li>
<li>“distance_type”: “plane” 使用快速但精度略差的 plane 计算方式。</li>
</ul>
<blockquote>
<p>地理距离排序可以对多个坐标点来使用，不管（这些坐标点）是在文档中还是排序参数中。使用 sort_mode 来指定是否需要使用位置集合的 最小 （ min ） 最大 （ max ）或者 平均 （ avg ）距离。 如此就可以返回 “离我的工作地和家最近的朋友” 这样的结果了。</p>
</blockquote>
<h5 id="按照距离打分-Scoring-by-Distance"><a href="#按照距离打分-Scoring-by-Distance" class="headerlink" title="按照距离打分(Scoring by Distance)"></a>按照距离打分(Scoring by Distance)</h5><ul>
<li>常见场景是全文检索匹配度、流行程度或者价格一起决定排序结果。</li>
<li>综合排序时你需要在 <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/function-score-query.html" target="_blank" rel="noopener">功能评分查询</a> 中指定方式让我们把这些因子处理后得到一个综合分。</li>
<li><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/decay-functions.html" target="_blank" rel="noopener">越近越好</a> 中有个一个例子就是介绍地理距离影响排序得分的。</li>
<li>按距离排序还有个缺点就是性能：需要对每一个匹配到的文档都进行距离计算。而 function_score 查询，在 rescore 语句 中可以限制只对前 n 个结果进行计算。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geoloc.html" target="_blank" rel="noopener">中文参考1</a><br><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geopoints.html" target="_blank" rel="noopener">中文参考2</a><br><a href="https://github.com/elastic/elasticsearch-definitive-guide/blob/eb0004640922da772be5ccb61060642a23b67e6b/04_Geolocation.asciidoc" target="_blank" rel="noopener">英文参考1</a><br><a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/eb0004640922da772be5ccb61060642a23b67e6b/310_Geopoints" target="_blank" rel="noopener">英文参考2</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>39-地理位置-Geohashes</title>
    <url>/2020/03/19/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/39-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE-Geohashes/</url>
    <content><![CDATA[<h3 id="Geohashes"><a href="#Geohashes" class="headerlink" title="Geohashes"></a>Geohashes</h3><p><a href="http://en.wikipedia.org/wiki/Geohash" target="_blank" rel="noopener">Geohashes</a>是一种将经纬度坐标(lat/lon)编码成字符串的方式。<br>这么做的初衷只是为了让地理位置在 url 上呈现的形式更加友好，但现在 geohashes 已经变成一种在数据库中有效索引地理坐标点和地理形状的方式。</p>
<a id="more"></a>
<p>Geohashes原理：<br>Geohashes把整个世界分成4行8列的32个单元格(每格用字母和数字表示),每个格子可以再分32格，依次不断重复分下去，geohash 的长度越长，它的精度就越高。共同前缀表示他们挨得很近，共同前缀越长距离就越近。两个刚好相邻的位置，可能会有完全不同的 geohash 。</p>
<p>例如：gc 这个单元覆盖了爱尔兰和英格兰， gcp 覆盖了伦敦的大部分和部分南英格兰， gcpuuz94k 是白金汉宫的入口，精确到约 5 米。</p>
<p>地理坐标点可以自动索引相关的 geohashes ，更重要的是，他们也可以索引所有的 geohashes 前缀 。<br>geohash单元 过滤器 可以使用这些 geohash 前缀来找出与指定坐标点（ lat/lon ）相邻的位置。</p>
<h3 id="Geohashes-映射-Mapping-Geohashes"><a href="#Geohashes-映射-Mapping-Geohashes" class="headerlink" title="Geohashes 映射(Mapping Geohashes)"></a>Geohashes 映射(Mapping Geohashes)</h3><p>配置Geohashes 映射</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"restaurant"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"location"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:               <span class="string">"geo_point"</span>,</span><br><span class="line">          <span class="attr">"geohash_prefix"</span>:     <span class="literal">true</span>,</span><br><span class="line">          <span class="attr">"geohash_precision"</span>:  <span class="string">"1km"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将 geohash_prefix 设为 true 来告诉 Elasticsearch 使用指定精度来索引 geohash 的前缀。</li>
<li>精度可以是一个具体的数字，代表的 geohash 的长度，也可以是一个距离。 1km 的精度对应的 geohash 的长度是 7 。</li>
</ul>
<h3 id="Geohashes-单元查询-Geohash-Cell-Query"><a href="#Geohashes-单元查询-Geohash-Cell-Query" class="headerlink" title="Geohashes 单元查询(Geohash Cell Query)"></a>Geohashes 单元查询(Geohash Cell Query)</h3><p>geohash_cell 把经纬度坐标位置转成一个geohash,然后查找所有包含这个geohash的位置。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geohash_cell"</span>: &#123;</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"lat"</span>:  <span class="number">40.718</span>,</span><br><span class="line">            <span class="attr">"lon"</span>: <span class="number">-73.983</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"precision"</span>: <span class="string">"2km"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geohashes.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/eb0004640922da772be5ccb61060642a23b67e6b/340_Geoshapes" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>41-地理位置-地理形状</title>
    <url>/2020/03/19/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/41-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE-%E5%9C%B0%E7%90%86%E5%BD%A2%E7%8A%B6/</url>
    <content><![CDATA[<h3 id="地理形状"><a href="#地理形状" class="headerlink" title="地理形状"></a>地理形状</h3><p>geo-shapes 有一下作用：判断 查询形状 与 索引形状的关系。<br>Geo-shapes 不能用于计算距离、排序、打分以及聚合。</p>
<a id="more"></a>
<p>3种关系：</p>
<ul>
<li>inersects : 相交，查询形状 与 索引形状 有重叠。默认值</li>
<li>disjoint : 不相交，查询形状 与 索引形状 完全不重叠。</li>
<li>within : 索引形状 完全被包含在 查询形状 中。</li>
</ul>
<p>你需要考虑修改两个非常重要的设置： 精度 和 距离误差 。</p>
<h3 id="精度-precision"><a href="#精度-precision" class="headerlink" title="精度(precision)"></a>精度(precision)</h3><ul>
<li>精度 （ precision ）参数 用来控制生成的 geohash 的最大长度。默认精度为 9 ，等同于尺寸在 5m x 5m 的geohash 。</li>
<li>精度越低，需要索引的单元就越少，检索时也会更快。当然，精度越低，地理形状的准确性就越差。你需要考虑自己的地理形状所需要的精度——即使减少1-2个等级的精度也能带来明显的消耗缩减收益。</li>
</ul>
<h3 id="距离误差-distance-error-pct"><a href="#距离误差-distance-error-pct" class="headerlink" title="距离误差(distance_error_pct)"></a>距离误差(distance_error_pct)</h3><p>距离误差 指定地理形状可以接受的最大错误率。它的默认值是 0.025 ， 即 2.5% 。<br>错误率越大，地理形状索引的单元越少。</p>
<blockquote>
<p>索引一个多边形时，中间连续区域很容易用一个短 geohash 来表示。麻烦的是边缘部分，这些地方需要使用更精细的 geohashes 才能表示。<br>当你在索引一个小地标时，你会希望它的边界比较精确。让这些纪念碑一个叠着一个可不好。当索引整个国家时，你就不需要这么高的精度了。误差个50米左右也不可能引发战争。</p>
</blockquote>
<h3 id="索引地理形状-Indexing-Geo-Shapes"><a href="#索引地理形状-Indexing-Geo-Shapes" class="headerlink" title="索引地理形状(Indexing Geo Shapes)"></a>索引地理形状(Indexing Geo Shapes)</h3><ul>
<li>地理形状通过<a href="http://geojson.org/" target="_blank" rel="noopener">GeoJSON</a>表示，这是一种开放的使用JSON实现的二维形状编码方式。</li>
<li>形状类型有： point,line,polygon,envelope，一个或多个经纬度点集合的数组。</li>
<li>在 GeoJSON 里，经纬度表示方式通常是 纬度 在前， 经度 在后。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions/landmark/dam_square</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span> : <span class="string">"Dam Square, Amsterdam"</span>,</span><br><span class="line">    <span class="attr">"location"</span> : &#123;</span><br><span class="line">        <span class="attr">"type"</span> : <span class="string">"polygon"</span>,</span><br><span class="line">        <span class="attr">"coordinates"</span> : [[</span><br><span class="line">          [ <span class="number">4.89218</span>, <span class="number">52.37356</span> ],</span><br><span class="line">          [ <span class="number">4.89205</span>, <span class="number">52.37276</span> ],</span><br><span class="line">          [ <span class="number">4.89301</span>, <span class="number">52.37274</span> ],</span><br><span class="line">          [ <span class="number">4.89392</span>, <span class="number">52.37250</span> ],</span><br><span class="line">          [ <span class="number">4.89431</span>, <span class="number">52.37287</span> ],</span><br><span class="line">          [ <span class="number">4.89331</span>, <span class="number">52.37346</span> ],</span><br><span class="line">          [ <span class="number">4.89305</span>, <span class="number">52.37326</span> ],</span><br><span class="line">          [ <span class="number">4.89218</span>, <span class="number">52.37356</span> ]</span><br><span class="line">        ]]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GeoJSON语法：</p>
<ul>
<li>[lon,lat] 用数组表示 经纬度 坐标点。</li>
<li>[[lon,lat],[lon,lat], … ] 一组坐标点放到一个数组来表示一个多边形</li>
<li>一个多边形(polygon)形状包含多个多边形；第一表示多边形的外轮廓，后续多边形表示内部空间<br>[<br>[[lon,lat],[lon,lat], … ],  # main polygon<br>[[lon,lat],[lon,lat], … ],  # hole in main polygon<br>…<br>]</li>
</ul>
<h3 id="查询地理形状-Querying-Geo-Shapes"><a href="#查询地理形状-Querying-Geo-Shapes" class="headerlink" title="查询地理形状(Querying Geo Shapes)"></a>查询地理形状(Querying Geo Shapes)</h3><p>geo_shape查询允许使用形状来做查询，而不仅仅是坐标点。</p>
<p>查询出方圆 1km 内的所有地标：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/landmark/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_shape"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"shape"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:   <span class="string">"circle"</span>,</span><br><span class="line">          <span class="attr">"radius"</span>: <span class="string">"1km"</span>,</span><br><span class="line">          <span class="attr">"coordinates"</span>: [</span><br><span class="line">            <span class="number">4.89994</span>,</span><br><span class="line">            <span class="number">52.37815</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>举个例子，我们可以查找阿姆斯特丹中心区域所有的地标：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_shape"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"relation"</span>: <span class="string">"within"</span>,</span><br><span class="line">        <span class="attr">"shape"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"polygon"</span>,</span><br><span class="line">          <span class="attr">"coordinates"</span>: [[</span><br><span class="line">              [<span class="number">4.88330</span>,<span class="number">52.38617</span>],</span><br><span class="line">              [<span class="number">4.87463</span>,<span class="number">52.37254</span>],</span><br><span class="line">              [<span class="number">4.87875</span>,<span class="number">52.36369</span>],</span><br><span class="line">              [<span class="number">4.88939</span>,<span class="number">52.35850</span>],</span><br><span class="line">              [<span class="number">4.89840</span>,<span class="number">52.35755</span>],</span><br><span class="line">              [<span class="number">4.91909</span>,<span class="number">52.36217</span>],</span><br><span class="line">              [<span class="number">4.92656</span>,<span class="number">52.36594</span>],</span><br><span class="line">              [<span class="number">4.93368</span>,<span class="number">52.36615</span>],</span><br><span class="line">              [<span class="number">4.93342</span>,<span class="number">52.37275</span>],</span><br><span class="line">              [<span class="number">4.92690</span>,<span class="number">52.37632</span>],</span><br><span class="line">              [<span class="number">4.88330</span>,<span class="number">52.38617</span>]</span><br><span class="line">            ]]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>把 relation 字段设置为 disjoint 来查找与指定形状不相交的部分，或者设置为 within 来查找完全落在查询形状中的。</li>
</ul>
<h3 id="在查询中使用已索引的形状-Querying-with-Indexed-Shapes"><a href="#在查询中使用已索引的形状-Querying-with-Indexed-Shapes" class="headerlink" title="在查询中使用已索引的形状(Querying with Indexed Shapes)"></a>在查询中使用已索引的形状(Querying with Indexed Shapes)</h3><p>对于那些经常会在查询中使用的形状，可以把它们索引起来以便在查询中可以方便地直接引用名字。</p>
<p>把形状存储起来<br>映射字段:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions/_mapping/neighborhood</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"name"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"location"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"geo_shape"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储形状</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /attractions/neighborhood/central_amsterdam</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Central Amsterdam"</span>,</span><br><span class="line">  <span class="attr">"location"</span> : &#123;</span><br><span class="line">      <span class="attr">"type"</span> : <span class="string">"polygon"</span>,</span><br><span class="line">      <span class="attr">"coordinates"</span> : [[</span><br><span class="line">        [<span class="number">4.88330</span>,<span class="number">52.38617</span>],</span><br><span class="line">        [<span class="number">4.87463</span>,<span class="number">52.37254</span>],</span><br><span class="line">        [<span class="number">4.87875</span>,<span class="number">52.36369</span>],</span><br><span class="line">        [<span class="number">4.88939</span>,<span class="number">52.35850</span>],</span><br><span class="line">        [<span class="number">4.89840</span>,<span class="number">52.35755</span>],</span><br><span class="line">        [<span class="number">4.91909</span>,<span class="number">52.36217</span>],</span><br><span class="line">        [<span class="number">4.92656</span>,<span class="number">52.36594</span>],</span><br><span class="line">        [<span class="number">4.93368</span>,<span class="number">52.36615</span>],</span><br><span class="line">        [<span class="number">4.93342</span>,<span class="number">52.37275</span>],</span><br><span class="line">        [<span class="number">4.92690</span>,<span class="number">52.37632</span>],</span><br><span class="line">        [<span class="number">4.88330</span>,<span class="number">52.38617</span>]</span><br><span class="line">      ]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询形状</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/landmark/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_shape"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"relation"</span>: <span class="string">"within"</span>,</span><br><span class="line">        <span class="attr">"indexed_shape"</span>: &#123;</span><br><span class="line">          <span class="attr">"index"</span>: <span class="string">"attractions"</span>,</span><br><span class="line">          <span class="attr">"type"</span>:  <span class="string">"neighborhood"</span>,</span><br><span class="line">          <span class="attr">"id"</span>:    <span class="string">"central_amsterdam"</span>,</span><br><span class="line">          <span class="attr">"path"</span>:  <span class="string">"location"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指定 indexed_shape 而不是 shape ，Elasticesearch 就知道需要从指定的文档和 path 检索出对应的形状了。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/neighborhood/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_shape"</span>: &#123;</span><br><span class="line">      <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"indexed_shape"</span>: &#123;</span><br><span class="line">          <span class="attr">"index"</span>: <span class="string">"attractions"</span>,</span><br><span class="line">          <span class="attr">"type"</span>:  <span class="string">"landmark"</span>,</span><br><span class="line">          <span class="attr">"id"</span>:    <span class="string">"dam_square"</span>,</span><br><span class="line">          <span class="attr">"path"</span>:  <span class="string">"location"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geo-shapes.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/eb0004640922da772be5ccb61060642a23b67e6b/340_Geoshapes" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>40-地理位置-地理位置聚合</title>
    <url>/2020/03/19/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/40-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE-%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E8%81%9A%E5%90%88/</url>
    <content><![CDATA[<h3 id="地理位置聚合-Geo-Aggregations"><a href="#地理位置聚合-Geo-Aggregations" class="headerlink" title="地理位置聚合(Geo Aggregations)"></a>地理位置聚合(Geo Aggregations)</h3><p>地理位置聚合就是将地理坐标聚集到更容易管理的bucket是中。<br>处理geo_point类型字段的三种聚合:</p>
<ul>
<li>地理位置距离(geo_distance) : 将文档按照距离围绕一个中心点来分组。</li>
<li>geohash网格(geohash_grid) : 将文档按照geohash范围来分组，用来显示在地图上。</li>
<li>地理位置边界(geo_bounds) : 返回一个包含所有地理位置坐标点的边界的经纬度坐标，这对显示地图时缩放比例的选择非常有用。</li>
</ul>
<a id="more"></a>
<h3 id="地理位置距离-geo-distance"><a href="#地理位置距离-geo-distance" class="headerlink" title="地理位置距离(geo_distance)"></a>地理位置距离(geo_distance)</h3><p>geo_distance 聚合 对一些搜索非常有用.</p>
<p>例如： 找到所有距离我 1km 以内的披萨店。<br>搜索结果应该也的确被限制在用户指定 1km 范围内，但是我们可以添加在 2km 范围内找到的其他结果：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"pizza"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.8</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-74.1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"bottom_right"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.4</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-73.7</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"per_ring"</span>: &#123;</span><br><span class="line">      <span class="attr">"geo_distance"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>:    <span class="string">"location"</span>,</span><br><span class="line">        <span class="attr">"unit"</span>:     <span class="string">"km"</span>,</span><br><span class="line">        <span class="attr">"origin"</span>: &#123;</span><br><span class="line">          <span class="attr">"lat"</span>:    <span class="number">40.712</span>,</span><br><span class="line">          <span class="attr">"lon"</span>:   <span class="number">-73.988</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"ranges"</span>: [</span><br><span class="line">          &#123; <span class="attr">"from"</span>: <span class="number">0</span>, <span class="attr">"to"</span>: <span class="number">1</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">"from"</span>: <span class="number">1</span>, <span class="attr">"to"</span>: <span class="number">2</span> &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"post_filter"</span>: &#123;</span><br><span class="line">    <span class="attr">"geo_distance"</span>: &#123;</span><br><span class="line">      <span class="attr">"distance"</span>:   <span class="string">"1km"</span>,</span><br><span class="line">      <span class="attr">"location"</span>: &#123;</span><br><span class="line">        <span class="attr">"lat"</span>:      <span class="number">40.712</span>,</span><br><span class="line">        <span class="attr">"lon"</span>:     <span class="number">-73.988</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>主查询查找名称中含有 pizza 的饭店。</li>
<li>geo_bounding_box 筛选那些只在纽约区域的结果。</li>
<li>per_ring.geo_distance 聚合统计距离用户 1km 以内，1km 到 2km 的结果的数量。</li>
<li>最后，post_filter 将结果缩小至那些在用户 1km 范围内的饭店</li>
</ul>
<h3 id="geohash网格-geohash-grid"><a href="#geohash网格-geohash-grid" class="headerlink" title="geohash网格(geohash_grid)"></a>geohash网格(geohash_grid)</h3><p>geohash_grid按照指定精度将附近的位置聚合成一个网格。<br>聚合是稀疏的—它 仅返回那些含有文档的单元。<br>如果 geohashes 太精确，将产生太多的 buckets，它将默认返回那些包含了大量文档、最密集的10000个单元。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.8</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-74.1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"bottom_right"</span>: &#123;</span><br><span class="line">              <span class="attr">"lat"</span>:  <span class="number">40.4</span>,</span><br><span class="line">              <span class="attr">"lon"</span>: <span class="number">-73.7</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"new_york"</span>: &#123;</span><br><span class="line">      <span class="attr">"geohash_grid"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>:     <span class="string">"location"</span>,</span><br><span class="line">        <span class="attr">"precision"</span>: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>geo_bounding_box 边界框将搜索限制在大纽约区的范围</li>
<li>Geohashes 精度为 5 大约是 5km x 5km。</li>
</ul>
<p>如果绘制到地图上需要一个将 geohash 转换成同等边界框或中心点的库</p>
<h3 id="地理位置边界-geo-bounds"><a href="#地理位置边界-geo-bounds" class="headerlink" title="地理位置边界(geo_bounds)"></a>地理位置边界(geo_bounds)</h3><p>geo_bounds 计算封装所有地理日志点需要的最小边界框。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">              "lat":  40,8,</span><br><span class="line">              "lon": -74.1</span><br><span class="line">            &#125;,</span><br><span class="line">            "bottom_right": &#123;</span><br><span class="line">              "lat":  40.4,</span><br><span class="line">              "lon": -73.9</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "new_york": &#123;</span><br><span class="line">      "geohash_grid": &#123;</span><br><span class="line">        "field":     "location",</span><br><span class="line">        "precision": 5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "map_zoom": &#123;</span><br><span class="line">      "geo_bounds": &#123;</span><br><span class="line">        "field":     "location"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果即为结果集的最小边界框。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">"aggregations": &#123;</span><br><span class="line">  "map_zoom": &#123;</span><br><span class="line">     "bounds": &#123;</span><br><span class="line">        "top_left": &#123;</span><br><span class="line">           "lat":  40.722,</span><br><span class="line">           "lon": -74.011</span><br><span class="line">        &#125;,</span><br><span class="line">        "bottom_right": &#123;</span><br><span class="line">           "lat":  40.715,</span><br><span class="line">           "lon": -73.983</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在每一个geohash 单元内部使用geo_bounds聚合， 以免一个单元内的地理位置点仅集中在单元的一部分上：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /attractions/restaurant/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"constant_score"</span>: &#123;</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"geo_bounding_box"</span>: &#123;</span><br><span class="line">          <span class="attr">"location"</span>: &#123;</span><br><span class="line">            <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">              "lat":  40,8,</span><br><span class="line">              "lon": -74.1</span><br><span class="line">            &#125;,</span><br><span class="line">            "bottom_right": &#123;</span><br><span class="line">              "lat":  40.4,</span><br><span class="line">              "lon": -73.9</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "new_york": &#123;</span><br><span class="line">      "geohash_grid": &#123;</span><br><span class="line">        "field":     "location",</span><br><span class="line">        "precision": 5</span><br><span class="line">      &#125;,</span><br><span class="line">      "aggs": &#123;</span><br><span class="line">        "cell": &#123;</span><br><span class="line">          "geo_bounds": &#123;</span><br><span class="line">            "field": "location"</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>cell_bounds 子聚合会为每个 geohash 单元计算边界框。<br>结果如下：<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"aggregations": &#123;</span><br><span class="line">  "new_york": &#123;</span><br><span class="line">     "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">"key"</span>: <span class="string">"dr5rs"</span>,</span><br><span class="line">           <span class="attr">"doc_count"</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="attr">"cell"</span>: &#123;</span><br><span class="line">              <span class="attr">"bounds"</span>: &#123;</span><br><span class="line">                 <span class="attr">"top_left"</span>: &#123;</span><br><span class="line">                    <span class="attr">"lat"</span>:  <span class="number">40.722</span>,</span><br><span class="line">                    <span class="attr">"lon"</span>: <span class="number">-73.989</span></span><br><span class="line">                 &#125;,</span><br><span class="line">                 <span class="attr">"bottom_right"</span>: &#123;</span><br><span class="line">                    <span class="attr">"lat"</span>:  <span class="number">40.719</span>,</span><br><span class="line">                    <span class="attr">"lon"</span>: <span class="number">-73.983</span></span><br><span class="line">                 &#125;</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/geo-aggs.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/eb0004640922da772be5ccb61060642a23b67e6b/330_Geo_aggs" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>42-数据建模</title>
    <url>/2020/03/20/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/42-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h3 id="数据建模-modling-your-data"><a href="#数据建模-modling-your-data" class="headerlink" title="数据建模(modling your data)"></a>数据建模(modling your data)</h3><p>Elasticsearch不同于关系型数据库，它没有范式，对于处理实体间的关系它没有直接给出方法。</p>
<p>三种方式：</p>
<ul>
<li>关联关系处理</li>
<li>嵌套对象</li>
<li>父-子关系文档</li>
</ul>
<p>扩容设计：根据你的模型制定不同的扩容设计。</p>
<a id="more"></a>

<h3 id="关联关系处理"><a href="#关联关系处理" class="headerlink" title="关联关系处理"></a>关联关系处理</h3><p>现实世界有很多重要的关联关系，关系型数据可以很好地解决关联关系，但存在以下问题：</p>
<ul>
<li>对全文检索有限的支持能力</li>
<li>实体关联查询时间消耗很昂贵，关联越多消耗就越昂贵。</li>
<li>特别是跨服务器进行实体关联时成本极其昂贵，基本不可用，单个的服务器上又存在数据量的限制。</li>
</ul>
<p>Elasticsearch与大多数NoSql数据库类似，是扁平化的。<br>扁平化优势</p>
<ul>
<li>索引过程是快速和无锁的</li>
<li>搜索过程是快速和无锁的</li>
<li>因为每个文档都是相互独立的，大规模数据可以在多个节点上进行分布。</li>
</ul>
<p>事务：</p>
<ul>
<li>大多数关系数据库支持跨多个实体的 ACID 事务。</li>
<li>Elasticsearch 中单个文档的数据变更是ACID，而设计多个文档的事务则不是。</li>
</ul>
<p>Elasticsearch中处理关系型数据管理的四种方法：</p>
<ul>
<li>Application-side joins (应用层联接)</li>
<li>Data denormalization (数据非规范化)</li>
<li>Nested objects (嵌套对象)</li>
<li>Parent/child relationships (父子关系)</li>
</ul>
<h3 id="应用层连接-Application-side-Joins"><a href="#应用层连接-Application-side-Joins" class="headerlink" title="应用层连接(Application-side Joins)"></a>应用层连接(Application-side Joins)</h3><p>应用层连接就是模拟关系型数据库。<br>应用层联结</p>
<ul>
<li>主要优点：可以对数据进行标准化处理。</li>
<li>主要缺点：为了搜索时联接文档，必须运行额外的查询。</li>
</ul>
<p>适用场景：第一个实体(例子中user)只有少量的文档记录的情况，并且最好它们很少改变。这样可以将结果缓存，并避免经常运行第一次查询。</p>
<h3 id="非规范化你的数据-Denormalizing-Your-Data"><a href="#非规范化你的数据-Denormalizing-Your-Data" class="headerlink" title="非规范化你的数据(Denormalizing Your Data)"></a>非规范化你的数据(Denormalizing Your Data)</h3><p>保证一定数量的冗余副本可以在需要访问时避免进行关联。</p>
<p>数据非规范化优点： 速度快，因为每个文档都包含所需的所有信息，查询匹配时不需要进行昂贵的联接操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/user/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:     <span class="string">"John Smith"</span>,</span><br><span class="line">  <span class="attr">"email"</span>:    <span class="string">"john@smith.com"</span>,</span><br><span class="line">  <span class="attr">"dob"</span>:      <span class="string">"1970/10/24"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/blogpost/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>:    <span class="string">"Relationships"</span>,</span><br><span class="line">  <span class="attr">"body"</span>:     <span class="string">"It's complicated..."</span>,</span><br><span class="line">  <span class="attr">"user"</span>:     &#123;</span><br><span class="line">    <span class="attr">"id"</span>:       <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>:     <span class="string">"John Smith"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单词查询就能通过relationships找到用户John的博客文章</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/blogpost/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>:     <span class="string">"relationships"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"user.name"</span>: <span class="string">"John"</span>          &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字段折叠-Field-Collapsing"><a href="#字段折叠-Field-Collapsing" class="headerlink" title="字段折叠(Field Collapsing)"></a>字段折叠(Field Collapsing)</h3><p>通过特定字段进行分组.</p>
<p>例如： 查询5个用户的评分最高的博客</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/_mapping/blogpost</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"properties"</span>: &#123;</span><br><span class="line">    <span class="attr">"user"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"name"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"fields"</span>: &#123;</span><br><span class="line">            <span class="attr">"raw"</span>: &#123;</span><br><span class="line">              <span class="attr">"type"</span>:  <span class="string">"string"</span>,</span><br><span class="line">              <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/user/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Smith"</span>,</span><br><span class="line">  <span class="attr">"email"</span>: <span class="string">"john@smith.com"</span>,</span><br><span class="line">  <span class="attr">"dob"</span>: <span class="string">"1970/10/24"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/blogpost/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Relationships"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: <span class="string">"It's complicated..."</span>,</span><br><span class="line">  <span class="attr">"user"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"John Smith"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/user/3</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"Alice John"</span>,</span><br><span class="line">  <span class="attr">"email"</span>: <span class="string">"alice@john.com"</span>,</span><br><span class="line">  <span class="attr">"dob"</span>: <span class="string">"1979/01/04"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /my_index/blogpost/4</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Relationships are cool"</span>,</span><br><span class="line">  <span class="attr">"body"</span>: <span class="string">"It's not complicated at all..."</span>,</span><br><span class="line">  <span class="attr">"user"</span>: &#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Alice John"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始查询</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/blogpost/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"title"</span>:     <span class="string">"relationships"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"user.name"</span>: <span class="string">"John"</span>          &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"users"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>:   <span class="string">"user.name.raw"</span>,      </span><br><span class="line">        <span class="attr">"order"</span>: &#123; <span class="attr">"top_score"</span>: <span class="string">"desc"</span> &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"top_score"</span>: &#123; <span class="attr">"max"</span>:      &#123; <span class="attr">"script"</span>:  <span class="string">"_score"</span>           &#125;&#125;,</span><br><span class="line">        <span class="attr">"blogposts"</span>: &#123; <span class="attr">"top_hits"</span>: &#123; <span class="attr">"_source"</span>: <span class="string">"title"</span>, <span class="attr">"size"</span>: <span class="number">5</span> &#125;&#125;  </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>query 返回通过 relationships 查找名称为 John 的用户的博客文章。</li>
<li>terms 聚合为每一个 user.name.raw 创建一个桶。</li>
<li>top_score 聚合对通过 users 聚合得到的每一个桶按照文档评分对词项进行排序。</li>
<li>top_hits 聚合仅为每个用户返回五个最相关的博客文章的 title 字段。</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">"hits": &#123;</span><br><span class="line">  "total":     2,</span><br><span class="line">  "max_score": 0,</span><br><span class="line">  "hits":      []</span><br><span class="line">&#125;,</span><br><span class="line">"aggregations": &#123;</span><br><span class="line">  "users": &#123;</span><br><span class="line">     "buckets": [</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="attr">"key"</span>:       <span class="string">"John Smith"</span>,</span><br><span class="line">           <span class="attr">"doc_count"</span>: <span class="number">1</span>,</span><br><span class="line">           <span class="attr">"blogposts"</span>: &#123;</span><br><span class="line">              <span class="attr">"hits"</span>: &#123;</span><br><span class="line">                 <span class="attr">"total"</span>:     <span class="number">1</span>,</span><br><span class="line">                 <span class="attr">"max_score"</span>: <span class="number">0.35258877</span>,</span><br><span class="line">                 <span class="attr">"hits"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                       <span class="attr">"_index"</span>: <span class="string">"my_index"</span>,</span><br><span class="line">                       <span class="attr">"_type"</span>:  <span class="string">"blogpost"</span>,</span><br><span class="line">                       <span class="attr">"_id"</span>:    <span class="string">"2"</span>,</span><br><span class="line">                       <span class="attr">"_score"</span>: <span class="number">0.35258877</span>,</span><br><span class="line">                       <span class="attr">"_source"</span>: &#123;</span><br><span class="line">                          <span class="attr">"title"</span>: <span class="string">"Relationships"</span></span><br><span class="line">                       &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                 ]</span><br><span class="line">              &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="attr">"top_score"</span>: &#123;</span><br><span class="line">              <span class="attr">"value"</span>: <span class="number">0.3525887727737427</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在顶层查询结果中出现的每一个用户都会有一个对应的桶。</li>
<li>在每个用户桶下面都会有一个 blogposts.hits 数组包含针对这个用户的顶层查询结果。</li>
<li>用户桶按照每个用户最相关的博客文章进行排序。</li>
</ul>
<blockquote>
<p>使用 top_hits 聚合等效执行一个查询返回这些用户的名字和他们最相关的博客文章，然后为每一个用户执行相同的查询，以获得最好的博客。但前者的效率要好很多。<br>每一个桶返回的顶层查询命中结果是基于最初主查询进行的一个轻量 迷你查询 结果集。这个迷你查询提供了一些你期望的常用特性，例如高亮显示以及分页功能。</p>
</blockquote>
<h3 id="非规范化和并发-Denormalization-and-Concurrency"><a href="#非规范化和并发-Denormalization-and-Concurrency" class="headerlink" title="非规范化和并发(Denormalization and Concurrency)"></a>非规范化和并发(Denormalization and Concurrency)</h3><p>非规范化缺点：</p>
<ul>
<li>字段更多，索引更大，占用更多的磁盘空间</li>
<li>如果被嵌套的数据修改，相关的引用的索引都需要修改。</li>
<li>大量数据修改会引发并发问题。</li>
</ul>
<p>批量修改数据需要使用 scroll 来检索所有的文件， 以及 bulk API 来更新它们。这个过程不是原子的，但是所有的文件将会迅速转移到他们的新存放位置。</p>
<h3 id="解决并发问题-Solving-Concurrency-Issues"><a href="#解决并发问题-Solving-Concurrency-Issues" class="headerlink" title="解决并发问题(Solving Concurrency Issues)"></a>解决并发问题(Solving Concurrency Issues)</h3><p>当许多人同时修改同一数据时就会发生并发问题。</p>
<p>批量修改时会出现两种情况:</p>
<ul>
<li>你决定使用 version （版本）号进行数据修改时版本号产生冲突时，你的批量重命名操作将会失败。</li>
<li>你没有使用版本控制，你的变更将覆盖其他用户的变更。</li>
</ul>
<p>问题的原因是 Elasticsearch 不支持 ACID 事务。 对单个文件的变更是 ACIDic 的，但包含多个文档的变更不支持。</p>
<p>并发问题需要在 Elasticsearch 的事务水准进行处理。<br>以下是三个切实可行的使用 Elasticsearch 的解决方案，它们都涉及某种形式的锁：</p>
<ul>
<li>全局锁 ：通过在任何时间只允许一个进程来进行变更动作，我们可以完全避免并发问题。</li>
<li>文档锁</li>
<li>树锁</li>
</ul>
<h5 id="全局锁-Global-Locking"><a href="#全局锁-Global-Locking" class="headerlink" title="全局锁(Global Locking)"></a>全局锁(Global Locking)</h5><p>通过在任何时间只允许一个进程来进行变更动作，我们可以完全避免并发问题。</p>
<p>在 Elasticsearch 文档级别的变更支持 ACIDic，我们可以使用一个文档是否存在的状态作为一个全局锁。<br>create 全局锁文档,</p>
<ul>
<li>如果请求因冲突异常而失败，说明另一个进程已被授予全局锁，我们将不得不稍后再试。</li>
<li>如果请求成功了，我们自豪的成为全局锁的主人，然后可以继续完成我们的变更。</li>
<li>拿到锁后一旦完成变更，我们就必须通过删除全局锁文档来释放锁</li>
<li>create 全局锁文档：<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /fs/lock/global/_create</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
DELETE 释放锁<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /fs/lock/global</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>根据变更的频繁程度以及时间消耗，一个全局锁能对系统造成大幅度的性能限制。 我们可以通过让我们的锁更细粒度的方式来增加并行度。</p>
<h5 id="文档锁-Document-Locking"><a href="#文档锁-Document-Locking" class="headerlink" title="文档锁(Document Locking)"></a>文档锁(Document Locking)</h5><p>我们以相同的方法技术来锁定个体文档，而不是锁定整个文件系统。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /fs/lock/_bulk</span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"process_id"</span>: <span class="number">123</span>    &#125;</span><br><span class="line">&#123; <span class="attr">"create"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"process_id"</span>: <span class="number">123</span>    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lock 文档的 ID 将与应被锁定的文件的 ID 相同。</li>
<li>process_id 代表要执行变更进程的唯一 ID。</li>
</ul>
<p>update 加锁</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /fs/lock/1/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"upsert"</span>: &#123; <span class="attr">"process_id"</span>: <span class="number">123</span> &#125;,</span><br><span class="line">  <span class="attr">"script"</span>: <span class="string">"if ( ctx._source.process_id != process_id )</span></span><br><span class="line"><span class="string">  &#123; assert false &#125;; ctx.op = 'noop';"</span>,</span><br><span class="line">  <span class="attr">"params"</span>: &#123;</span><br><span class="line">    <span class="attr">"process_id"</span>: <span class="number">123</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>释放所有的锁–通过检索所有的锁文档并进行批量删除，可以完成锁的释放</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /fs/_refresh</span><br><span class="line"></span><br><span class="line">GET /fs/lock/_search?scroll=1m</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"sort"</span> : [<span class="string">"_doc"</span>],</span><br><span class="line">    <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span> : &#123;</span><br><span class="line">            <span class="attr">"process_id"</span> : <span class="number">123</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /fs/lock/_bulk</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">1</span>&#125;&#125;</span><br><span class="line">&#123; <span class="attr">"delete"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>refresh 调用确保所有 lock 文档对搜索请求可见。</li>
<li>当你需要在单次搜索请求返回大量的检索结果集时，你可以使用 scroll 查询。</li>
</ul>
<p>文档级锁可以实现细粒度的访问控制，但是为数百万文档创建锁文件开销也很大。<br>在某些情况下，你可以用少得多的工作量实现细粒度的锁定，如以下目录树场景中所示。</p>
<h5 id="树锁-Tree-Locking"><a href="#树锁-Tree-Locking" class="headerlink" title="树锁(Tree Locking)"></a>树锁(Tree Locking)</h5><ul>
<li>树锁 可以锁定的一部分，而不是锁定每一个涉及的文档.</li>
<li>树锁用最小的代价提供了细粒度的并发控制。当然，它不适用于所有的情况—​数据模型必须有类似于目录树的顺序访问路径才能使用。</li>
<li>当非规范化成为很多项目的一个很好的选择，采用锁方案的需求会带来复杂的实现逻辑。 作为替代方案，Elasticsearch 提供两个模型帮助我们处理相关联的实体： 嵌套的对象 和 父子关系 。</li>
</ul>
<p>独占锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;lock_type&quot;: &quot;exclusive&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>共享锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;lock_type&quot;:  &quot;shared&quot;,</span><br><span class="line">  &quot;lock_count&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lock_count 记录持有共享锁进程的数量。</li>
</ul>
<p>完整的更新请求如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /fs/lock/%2Fclinton/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"upsert"</span>: &#123;</span><br><span class="line">    <span class="attr">"lock_type"</span>:  <span class="string">"shared"</span>,</span><br><span class="line">    <span class="attr">"lock_count"</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"script"</span>: <span class="string">"if (ctx._source.lock_type == 'exclusive')</span></span><br><span class="line"><span class="string">  &#123; assert false &#125;; ctx._source.lock_count++"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>文档的 ID 是 /clinton ，经过URL编码后成为 %2fclinton 。</li>
<li>upsert 文档如果不存在，则会被插入。</li>
</ul>
<p>一旦我们成功地在所有的父目录中获得一个共享锁，我们尝试在文件本身 create 一个独占锁：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /fs/lock/%2Fclinton%2fprojects%2felasticsearch%2fREADME.txt/_create</span><br><span class="line">&#123; <span class="attr">"lock_type"</span>: <span class="string">"exclusive"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>现在，如果有其他人想要重新命名 /clinton 目录，他们将不得不在这条路径上获得一个独占锁：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /fs/lock/%2Fclinton/_create</span><br><span class="line">&#123; <span class="attr">"lock_type"</span>: <span class="string">"exclusive"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这个请求将失败，因为一个具有相同 ID 的 lock 文档已经存在。 另一个用户将不得不等待我们的操作完成以及释放我们的锁。独占锁只能这样被删除：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">DELETE /fs/lock/%2Fclinton%2fprojects%2felasticsearch%2fREADME.txt</span><br></pre></td></tr></table></figure>
<p>共享锁需要另一个脚本对 lock_count 递减，如果计数下降到零，删除 lock 文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (--ctx._source.lock_count &#x3D;&#x3D; 0) &#123;</span><br><span class="line">  ctx.op &#x3D; &#39;delete&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一旦 lock_count 达到0， ctx.op 会从 update 被修改成 delete 。</li>
</ul>
<p>此更新请求将为每级父目录由下至上的执行，从最长路径到最短路径：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /fs/lock/%2Fclinton%2fprojects%2felasticsearch/_update</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>: <span class="string">"if (--ctx._source.lock_count == 0) &#123; ctx.op = 'delete' &#125; "</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/modeling-your-data.html" target="_blank" rel="noopener">中文参考</a>，<a href="">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>43-数据建模-嵌套对象</title>
    <url>/2020/03/20/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/43-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E5%B5%8C%E5%A5%97%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="嵌套对象-Nested-Objects"><a href="#嵌套对象-Nested-Objects" class="headerlink" title="嵌套对象(Nested Objects)"></a>嵌套对象(Nested Objects)</h3><ul>
<li>设置嵌套对象 字段类型 type: nested</li>
<li>将相关试题数据都存储在同一个文档中。例如：订单和明细，博客和评论。</li>
<li>在独立索引每一个嵌套对象后,对象中每个字段的相关性得以保留。</li>
<li>由于嵌套文档直接存储在文档内部,查询时嵌套文档和根文档联合成本很低,速度和单独存储几乎一样。</li>
<li>嵌套文档是隐藏存储的,我们不能直接获取。</li>
</ul>
<a id="more"></a>
<p>添加数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index/blogpost/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"Nest eggs"</span>,</span><br><span class="line">  <span class="attr">"body"</span>:  <span class="string">"Making your money work..."</span>,</span><br><span class="line">  <span class="attr">"tags"</span>:  [ <span class="string">"cash"</span>, <span class="string">"shares"</span> ],</span><br><span class="line">  <span class="attr">"comments"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">      <span class="attr">"comment"</span>: <span class="string">"Great article"</span>,</span><br><span class="line">      <span class="attr">"age"</span>:     <span class="number">28</span>,</span><br><span class="line">      <span class="attr">"stars"</span>:   <span class="number">4</span>,</span><br><span class="line">      <span class="attr">"date"</span>:    <span class="string">"2014-09-01"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>:    <span class="string">"Alice White"</span>,</span><br><span class="line">      <span class="attr">"comment"</span>: <span class="string">"More like this please"</span>,</span><br><span class="line">      <span class="attr">"age"</span>:     <span class="number">31</span>,</span><br><span class="line">      <span class="attr">"stars"</span>:   <span class="number">5</span>,</span><br><span class="line">      <span class="attr">"date"</span>:    <span class="string">"2014-10-22"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果我们依赖字段自动映射,那么 comments 字段会自动映射为 object 类型。</li>
</ul>
<p>查询：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"Alice"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="attr">"match"</span>: &#123; <span class="attr">"age"</span>:  <span class="number">28</span>      &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JSON 格式的文档被处理成如下的扁平式键值对的结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:            [ eggs, nest ],</span><br><span class="line">  &quot;body&quot;:             [ making, money, work, your ],</span><br><span class="line">  &quot;tags&quot;:             [ cash, shares ],</span><br><span class="line">  &quot;comments.name&quot;:    [ alice, john, smith, white ],</span><br><span class="line">  &quot;comments.comment&quot;: [ article, great, like, more, please, this ],</span><br><span class="line">  &quot;comments.age&quot;:     [ 28, 31 ],</span><br><span class="line">  &quot;comments.stars&quot;:   [ 4, 5 ],</span><br><span class="line">  &quot;comments.date&quot;:    [ 2014-09-01, 2014-10-22 ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Alice 和 31 、 John 和 2014-09-01 之间的相关性信息不再存在。</li>
<li>虽然 object 类型 (参见 内部对象) 在存储 单一对象 时非常有用,但对于对象数组的搜索而言,毫无用处。</li>
</ul>
<p>嵌套对象(nested objects) 就是来解决这个问题的。将 comments 字段类型设置为 nested 而不是 object 后,每一个嵌套对象都会被索引为一个 隐藏的独立文档 ,举例如下:</p>
<p>字段类型设置为nested(而不是object)后,每一个嵌套对象都会被索引为一个隐藏的独立文档。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;comments.name&quot;:    [ john, smith ],</span><br><span class="line">  &quot;comments.comment&quot;: [ article, great ],</span><br><span class="line">  &quot;comments.age&quot;:     [ 28 ],</span><br><span class="line">  &quot;comments.stars&quot;:   [ 4 ],</span><br><span class="line">  &quot;comments.date&quot;:    [ 2014-09-01 ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;comments.name&quot;:    [ alice, white ],</span><br><span class="line">  &quot;comments.comment&quot;: [ like, more, please, this ],</span><br><span class="line">  &quot;comments.age&quot;:     [ 31 ],</span><br><span class="line">  &quot;comments.stars&quot;:   [ 5 ],</span><br><span class="line">  &quot;comments.date&quot;:    [ 2014-10-22 ]</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;title&quot;:            [ eggs, nest ],</span><br><span class="line">  &quot;body&quot;:             [ making, money, work, your ],</span><br><span class="line">  &quot;tags&quot;:             [ cash, shares ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="嵌套对象映射-Nested-Object-Mapping"><a href="#嵌套对象映射-Nested-Object-Mapping" class="headerlink" title="嵌套对象映射(Nested Object Mapping)"></a>嵌套对象映射(Nested Object Mapping)</h3><ul>
<li>字段类型设置为nested.</li>
<li>nested 字段可以包含其他的 nested 字段。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /my_index</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"blogpost"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"comments"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"nested"</span>,</span><br><span class="line">          <span class="attr">"properties"</span>: &#123;</span><br><span class="line">            <span class="attr">"name"</span>:    &#123; <span class="attr">"type"</span>: <span class="string">"string"</span>  &#125;,</span><br><span class="line">            <span class="attr">"comment"</span>: &#123; <span class="attr">"type"</span>: <span class="string">"string"</span>  &#125;,</span><br><span class="line">            <span class="attr">"age"</span>:     &#123; <span class="attr">"type"</span>: <span class="string">"short"</span>   &#125;,</span><br><span class="line">            <span class="attr">"stars"</span>:   &#123; <span class="attr">"type"</span>: <span class="string">"short"</span>   &#125;,</span><br><span class="line">            <span class="attr">"date"</span>:    &#123; <span class="attr">"type"</span>: <span class="string">"date"</span>    &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套对象查询-Querying-a-Nested-Object"><a href="#嵌套对象查询-Querying-a-Nested-Object" class="headerlink" title="嵌套对象查询(Querying a Nested Object)"></a>嵌套对象查询(Querying a Nested Object)</h3><ul>
<li>嵌套对象需要使用nested 查询(nested query),因为嵌套对象被索引在独立隐藏的文档中，无法直接查询。</li>
<li>nested 字段可以包含其他的 nested 字段。同样地，nested 查询也可以包含其他的 nested 查询。而嵌套的层次会按照你所期待的被应用。</li>
<li>nested 查询匹配到的多个嵌套文档，他们的得分汇总一个分数可供根文档使用。</li>
<li>默认情况下，根文档的分数是这些嵌套文档分数的平均值。可以通过设置 score_mode 参数来控制这个得分策略，相关策略有 avg (平均值), max (最大值), sum (加和) 和 none (直接返回 1.0 常数值分数)。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/blogpost/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"match"</span>: &#123;</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"eggs"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"nested"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"comments"</span>,</span><br><span class="line">            <span class="attr">"score_mode"</span>: <span class="string">"max"</span>,</span><br><span class="line">            <span class="attr">"query"</span>: &#123;</span><br><span class="line">              <span class="attr">"bool"</span>: &#123;</span><br><span class="line">                <span class="attr">"must"</span>: [</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="attr">"match"</span>: &#123;</span><br><span class="line">                      <span class="attr">"comments.name"</span>: <span class="string">"john"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;,</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="attr">"match"</span>: &#123;</span><br><span class="line">                      <span class="attr">"comments.age"</span>: <span class="number">28</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“title”: “eggs”, title 子句是查询根文档的。</li>
<li>“path”: “comments”, nested 子句作用于嵌套字段 comments 。在此查询中，既不能查询根文档字段，也不能查询其他嵌套文档。</li>
<li>comments.name 和 comments.age 子句操作在同一个嵌套文档中。</li>
<li>“score_mode”: “max”, 设置 score_mode 参数来控制这个得分策略，相关策略有 avg (平均值), max (最大值), sum (加和) 和 none (直接返回 1.0 常数值分数)。</li>
</ul>
<blockquote>
<p>如果 nested 查询放在一个布尔查询的 filter 子句中，其表现就像一个 nested 查询，只是 score_mode 参数不再生效。因为它被用于不打分的查询中 — 只是符合或不符合条件，不必打分 — 那么 score_mode 就没有任何意义，因为根本就没有要打分的地方。</p>
</blockquote>
<h3 id="使用嵌套字段排序-Sorting-by-Nested-Fields"><a href="#使用嵌套字段排序-Sorting-by-Nested-Fields" class="headerlink" title="使用嵌套字段排序(Sorting by Nested Fields)"></a>使用嵌套字段排序(Sorting by Nested Fields)</h3><p>假如我们想要查询在10月份收到评论的博客文章，并且按照 stars 数的最小值来由小到大排序，那么查询语句如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"nested"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"comments"</span>,</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">          <span class="attr">"comments.date"</span>: &#123;</span><br><span class="line">            <span class="attr">"gte"</span>: <span class="string">"2014-10-01"</span>,</span><br><span class="line">            <span class="attr">"lt"</span>:  <span class="string">"2014-11-01"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: &#123;</span><br><span class="line">    <span class="attr">"comments.stars"</span>: &#123;</span><br><span class="line">      <span class="attr">"order"</span>: <span class="string">"asc"</span>,   </span><br><span class="line">      <span class="attr">"mode"</span>:  <span class="string">"min"</span>,   </span><br><span class="line">      <span class="attr">"nested_path"</span>: <span class="string">"comments"</span>,</span><br><span class="line">      <span class="attr">"nested_filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">          <span class="attr">"comments.date"</span>: &#123;</span><br><span class="line">            <span class="attr">"gte"</span>: <span class="string">"2014-10-01"</span>,</span><br><span class="line">            <span class="attr">"lt"</span>:  <span class="string">"2014-11-01"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“nested” 此处的 nested 查询将结果限定为在10月份收到过评论的博客文章。</li>
<li>“sort” 结果按照匹配的评论中 comment.stars 字段的最小值 (min) 来由小到大 (asc) 排序。</li>
</ul>
<blockquote>
<p>我们为什么要用 nested_path 和 nested_filter 重复查询条件呢？原因在于，排序发生在查询执行之后。 查询条件限定了在10月份收到评论的博客文档，但返回的是博客文档。如果我们不在排序子句中加入 nested_filter ， 那么我们对博客文档的排序将基于博客文档的所有评论，而不是仅仅在10月份接收到的评论。</p>
</blockquote>
<h3 id="嵌套聚合-Nested-Aggregations"><a href="#嵌套聚合-Nested-Aggregations" class="headerlink" title="嵌套聚合(Nested Aggregations)"></a>嵌套聚合(Nested Aggregations)</h3><p>nested 聚合允许我们对嵌套对象里的字段进行聚合操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/blogpost/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"comments"</span>: &#123;</span><br><span class="line">      <span class="attr">"nested"</span>: &#123;</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"comments"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"by_month"</span>: &#123;</span><br><span class="line">          <span class="attr">"date_histogram"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>:    <span class="string">"comments.date"</span>,</span><br><span class="line">            <span class="attr">"interval"</span>: <span class="string">"month"</span>,</span><br><span class="line">            <span class="attr">"format"</span>:   <span class="string">"yyyy-MM"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"avg_stars"</span>: &#123;</span><br><span class="line">              <span class="attr">"avg"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"comments.stars"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="逆向嵌套聚合-reverse-nested-Aggregation"><a href="#逆向嵌套聚合-reverse-nested-Aggregation" class="headerlink" title="逆向嵌套聚合(reverse_nested Aggregation)"></a>逆向嵌套聚合(reverse_nested Aggregation)</h5><p>nested聚合只能对嵌套文档的字段进行操作，通过reverse_nested聚合可以操作父级文档进行操作。<br>例如，我们要基于评论者的年龄找出评论者感兴趣 tags 的分布。 comment.age 是一个嵌套字段，但 tags 在根文档中：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /my_index/blogpost/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"comments"</span>: &#123;</span><br><span class="line">      <span class="attr">"nested"</span>: &#123;</span><br><span class="line">        <span class="attr">"path"</span>: <span class="string">"comments"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"age_group"</span>: &#123;</span><br><span class="line">          <span class="attr">"histogram"</span>: &#123;</span><br><span class="line">            <span class="attr">"field"</span>:    <span class="string">"comments.age"</span>,</span><br><span class="line">            <span class="attr">"interval"</span>: <span class="number">10</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"blogposts"</span>: &#123;</span><br><span class="line">              <span class="attr">"reverse_nested"</span>: &#123;&#125;,</span><br><span class="line">              <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">                <span class="attr">"tags"</span>: &#123;</span><br><span class="line">                  <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                    <span class="attr">"field"</span>: <span class="string">"tags"</span></span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>nested 聚合进入 comments 对象。</li>
<li>histogram 聚合基于 comments.age 做分组，每10年一个分组。</li>
<li>reverse_nested 聚合退回根文档。</li>
<li>terms 聚合计算每个分组年龄段的评论者最常用的标签词。</li>
</ul>
<h5 id="嵌套对象的使用时机"><a href="#嵌套对象的使用时机" class="headerlink" title="嵌套对象的使用时机"></a>嵌套对象的使用时机</h5><p>嵌套对象 在只有一个主要实体时非常有用，这个主要实体包含有限个紧密关联但又不是很重要的实体。<br>例如：主要实体 blogpost，blogpost包含评论对象，在基于评论的内容查找博客文章时， nested 查询有很大的用处，并且可以提供更快的查询效率。</p>
<p>嵌套模型的缺点：</p>
<ul>
<li>当对嵌套文档做增加、修改或删除时，整个文档都要重新被索引。嵌套文档越多成本就越大。</li>
<li>查询结果返回的是整个文档，而不仅仅是匹配嵌套文档。尽管目前有计划支持只返回根文档中最佳匹配的嵌套文档，但目前还不支持。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/nested-objects.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/master/402_Nested" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>44-数据建模-父子关系</title>
    <url>/2020/03/20/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/44-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E7%88%B6-%E5%AD%90%E5%85%B3%E7%B3%BB%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h3 id="父子关系文档映射"><a href="#父子关系文档映射" class="headerlink" title="父子关系文档映射"></a>父子关系文档映射</h3><ul>
<li>父子关联会在主文档和其关联实体之间做一个完整的隔离设计。</li>
<li>父子关系文档与嵌套模型区别：<ul>
<li>相同点：都是将一个对象实体和另外一个对象实体关联起来</li>
<li>不同点：嵌套模型所有对象都是在同一个文档中；父子关系文档中，父对象和子对象都是完全独立的文档。<a id="more"></a></li>
</ul>
</li>
<li>父子关系通过 type与另一个文档关联起来</li>
<li>父子关系优势：<ul>
<li>更新父文档时，不会重新索引文档</li>
<li>创建，修改或删除子文档时，不会影响父文档或其他子文档。这一点在这种场景下尤其有用：子文档数量较多，并且子文档创建和修改的频率高时。</li>
<li>子文档可以作为搜索结果独立返回。</li>
</ul>
</li>
<li>父子关系文档关联查询非常快，Elasticsearch 维护着这个父子文档的映射关系，得益于这个映射。</li>
<li>父子关系文档限制条件：父文档与子文档必须要存储在同一分片中。</li>
<li>父子文档ID映射存储在 Doc Values 中。当映射完全在内存中时， Doc Values 提供对映射的快速处理能力，另一方面当映射非常大时，可以通过溢出到磁盘提供足够的扩展能力</li>
</ul>
<h3 id="父子关系文档映射-Indexing-Parents-and-Children"><a href="#父子关系文档映射-Indexing-Parents-and-Children" class="headerlink" title="父子关系文档映射(Indexing Parents and Children)"></a>父子关系文档映射(Indexing Parents and Children)</h3><ul>
<li>父子关系在新版本中由<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/parent-join.html" target="_blank" rel="noopener">parent-join</a>替换</li>
<li>通过type指定关联关系</li>
<li>创建关系时机：1. 创建索引时 2. 更新父文档的mapping时，前提是 子文档type没有创建</li>
</ul>
<p>例如：员工属于某个分公司</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /company</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"branch"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"employee"</span>: &#123;</span><br><span class="line">      <span class="attr">"_parent"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"branch"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构建父子文档索引-Indexing-Parents-and-Children"><a href="#构建父子文档索引-Indexing-Parents-and-Children" class="headerlink" title="构建父子文档索引(Indexing Parents and Children)"></a>构建父子文档索引(Indexing Parents and Children)</h3><ul>
<li>父文档 ID 有两个作用：创建了父文档和子文档之间的关系，并且保证了父文档和子文档都在同一个分片上。如果指定了父文档的 ID，那么就会使用父文档的 ID 进行路由，而不会使用当前文档 <code>_id</code>。</li>
<li>在执行单文档的请求时需要指定父文档的 ID,单文档请求包括：通过 GET 请求获取一个子文档；创建、更新或删除一个子文档。而执行搜索请求时是不需要指定父文档的ID，这是因为搜索请求是向一个索引中的所有分片发起请求，而单文档的操作是只会向存储该文档的分片发送请求。因此，如果操作单个子文档时不指定父文档的 ID，那么很有可能会把请求发送到错误的分片上。</li>
<li>如果你想要改变一个子文档的 parent 值，仅通过更新这个子文档是不够的，因为新的父文档有可能在另外一个分片上。因此，你必须要先把子文档删除，然后再重新索引这个子文档。</li>
</ul>
<p>添加父文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /company/branch/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">2</span>, <span class="attr">"parent"</span>: <span class="string">"london"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"Mark Thomas"</span>, <span class="attr">"dob"</span>: <span class="string">"1982-05-16"</span>, <span class="attr">"hobby"</span>: <span class="string">"diving"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">3</span>, <span class="attr">"parent"</span>: <span class="string">"liverpool"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"Barry Smith"</span>, <span class="attr">"dob"</span>: <span class="string">"1979-04-01"</span>, <span class="attr">"hobby"</span>: <span class="string">"hiking"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="number">4</span>, <span class="attr">"parent"</span>: <span class="string">"paris"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"Adrien Grand"</span>, <span class="attr">"dob"</span>: <span class="string">"1987-05-11"</span>, <span class="attr">"hobby"</span>: <span class="string">"horses"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>添加子文档</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /company/employee/1?parent=london</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:  <span class="string">"Alice Smith"</span>,</span><br><span class="line">  <span class="attr">"dob"</span>:   <span class="string">"1970-10-24"</span>,</span><br><span class="line">  <span class="attr">"hobby"</span>: <span class="string">"hiking"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通过子文档查询父文档"><a href="#通过子文档查询父文档" class="headerlink" title="通过子文档查询父文档"></a>通过子文档查询父文档</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/branch/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"has_child"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"employee"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"range"</span>: &#123;</span><br><span class="line">          <span class="attr">"dob"</span>: &#123;</span><br><span class="line">            <span class="attr">"gte"</span>: <span class="string">"1980-01-01"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多个子文档评分模式 score_mode: none,avg 、 min 、 max 和 sum. 默认为 none。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/branch/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"has_child"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:       <span class="string">"employee"</span>,</span><br><span class="line">      <span class="attr">"score_mode"</span>: <span class="string">"max"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"name"</span>: <span class="string">"Alice Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="min-child-max-child"><a href="#min-child-max-child" class="headerlink" title="min_child max_child"></a>min_child max_child</h5><p>使用min_child, max_child 这两个参数时，只有当子文档数量在指定范围内时，才会返回父文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/branch/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"has_child"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>:         <span class="string">"employee"</span>,</span><br><span class="line">      <span class="attr">"min_children"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match_all"</span>: &#123;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>至少有两个雇员的分公司才会符合查询条件。</li>
<li>带有 min_children 和 max_children 参数的 has_child 查询或过滤，和允许评分的 has_child 查询的性能非常接近。</li>
</ul>
<p>has_child Filter</p>
<blockquote>
<p>has_child 查询和过滤在运行机制上类似，区别是 has_child 过滤不支持 score_mode 参数。has_child 过滤仅用于筛选内容—​如内部的一个 filtered 查询—​和其他过滤行为类似：包含或者排除，但没有进行评分。<br>has_child 过滤的结果没有被缓存，但是 has_child 过滤内部的过滤方法适用于通常的缓存规则。</p>
</blockquote>
<h3 id="通过父文档查询子文档"><a href="#通过父文档查询子文档" class="headerlink" title="通过父文档查询子文档"></a>通过父文档查询子文档</h3><p>使用 has_child 语句可以基于子文档来查询父文档。<br>使用 has_parent 语句可以基于父文档来查询子文档。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"has_parent"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"branch"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"country"</span>: <span class="string">"UK"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>has_parent 查询也支持 score_mode 这个参数，但是该参数只支持两种值： none （默认）和 score 。</li>
<li>每个子文档都只有一个父文档，因此这里不存在将多个评分规约为一个的情况， score_mode 的取值仅为 score 和 none 。</li>
</ul>
<p>不带评分的 has_parent 查询</p>
<blockquote>
<p>当 has_parent 查询用于非评分模式（比如 filter 查询语句）时， score_mode 参数就不再起作用了。因为这种模式只是简单地包含或排除文档，没有评分，那么 score_mode 参数也就没有意义了。</p>
</blockquote>
<h3 id="子文档聚合"><a href="#子文档聚合" class="headerlink" title="子文档聚合"></a>子文档聚合</h3><p>在父-子文档中支持 子文档聚合，这一点和 嵌套聚合 类似。但是，对于父文档的聚合查询是不支持的。</p>
<p>例子来演示按照国家维度查看最受雇员欢迎的业余爱好：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/branch/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"size"</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">    <span class="attr">"country"</span>: &#123;</span><br><span class="line">      <span class="attr">"terms"</span>: &#123;</span><br><span class="line">        <span class="attr">"field"</span>: <span class="string">"country"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">        <span class="attr">"employees"</span>: &#123;</span><br><span class="line">          <span class="attr">"children"</span>: &#123;</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"employee"</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">"aggs"</span>: &#123;</span><br><span class="line">            <span class="attr">"hobby"</span>: &#123;</span><br><span class="line">              <span class="attr">"terms"</span>: &#123;</span><br><span class="line">                <span class="attr">"field"</span>: <span class="string">"hobby"</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="祖辈和孙辈关系-Grandparents-and-Grandchildren"><a href="#祖辈和孙辈关系-Grandparents-and-Grandchildren" class="headerlink" title="祖辈和孙辈关系(Grandparents and Grandchildren)"></a>祖辈和孙辈关系(Grandparents and Grandchildren)</h3><p>父子关系可以延展到更多代关系,唯一的要求是满足在同一个分片上。</p>
<p>例子中的 country 类型设定为 branch 类型的父辈。<br>employee –&gt; branch –&gt; country</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /company</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"country"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"branch"</span>: &#123;</span><br><span class="line">      <span class="attr">"_parent"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"country"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"employee"</span>: &#123;</span><br><span class="line">      <span class="attr">"_parent"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"branch"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增数据</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /company/country/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"uk"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"UK"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"france"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"France"</span> &#125;</span><br><span class="line"></span><br><span class="line">POST /company/branch/_bulk</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"london"</span>, <span class="attr">"parent"</span>: <span class="string">"uk"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"London Westmintster"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"liverpool"</span>, <span class="attr">"parent"</span>: <span class="string">"uk"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"Liverpool Central"</span> &#125;</span><br><span class="line">&#123; <span class="attr">"index"</span>: &#123; <span class="attr">"_id"</span>: <span class="string">"paris"</span>, <span class="attr">"parent"</span>: <span class="string">"france"</span> &#125;&#125;</span><br><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"Champs Élysées"</span> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PUT /company/employee/1?parent=london</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:  <span class="string">"Alice Smith"</span>,</span><br><span class="line">  <span class="attr">"dob"</span>:   <span class="string">"1970-10-24"</span>,</span><br><span class="line">  <span class="attr">"hobby"</span>: <span class="string">"hiking"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT /company/employee/1?parent=london&amp;routing=uk</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:  <span class="string">"Alice Smith"</span>,</span><br><span class="line">  <span class="attr">"dob"</span>:   <span class="string">"1970-10-24"</span>,</span><br><span class="line">  <span class="attr">"hobby"</span>: <span class="string">"hiking"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要找到哪些国家的雇员喜欢远足旅行：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /company/country/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"has_child"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"branch"</span>,</span><br><span class="line">      <span class="attr">"query"</span>: &#123;</span><br><span class="line">        <span class="attr">"has_child"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>: <span class="string">"employee"</span>,</span><br><span class="line">          <span class="attr">"query"</span>: &#123;</span><br><span class="line">            <span class="attr">"match"</span>: &#123;</span><br><span class="line">              <span class="attr">"hobby"</span>: <span class="string">"hiking"</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实际使用中的一些建议-Practical-Considerations"><a href="#实际使用中的一些建议-Practical-Considerations" class="headerlink" title="实际使用中的一些建议(Practical Considerations)"></a>实际使用中的一些建议(Practical Considerations)</h3><p>当文档索引性能远比查询性能重要的时候，父子关系是非常有用的，但是它也是有巨大代价的。<br>其查询速度会比同等的嵌套查询慢5到10倍!</p>
<h5 id="全局序号和延迟-Global-Ordinals-and-Latency"><a href="#全局序号和延迟-Global-Ordinals-and-Latency" class="headerlink" title="全局序号和延迟(Global Ordinals and Latency)"></a>全局序号和延迟(Global Ordinals and Latency)</h5><ul>
<li>父子关系使用了全局序数 来加速文档间的联合,当索引变更时，全局序数要重建.</li>
<li>一个分片中父文档越多，那么全局序数的重建就需要更多的时间。</li>
<li>父子关系更适合于父文档少、子文档多的情况。</li>
<li>全局序数默认情况下是延迟构建的,使用全局序数预加载把开销由query阶段转移到refresh阶段。</li>
<li>当父文档过多时，全局序数的构建会耗费很多时间。此时可以通过增加 refresh_interval 来减少 refresh 的次数，延长全局序数的有效时间，这也很大程度上减小了全局序数每秒重建的cpu消耗。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /company</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"branch"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"employee"</span>: &#123;</span><br><span class="line">      <span class="attr">"_parent"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"branch"</span>,</span><br><span class="line">        <span class="attr">"fielddata"</span>: &#123;</span><br><span class="line">          <span class="attr">"loading"</span>: <span class="string">"eager_global_ordinals"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多使用-和-结语-Multigenerations-and-Concluding-Thoughts"><a href="#多使用-和-结语-Multigenerations-and-Concluding-Thoughts" class="headerlink" title="多使用 和 结语(Multigenerations and Concluding Thoughts)"></a>多使用 和 结语(Multigenerations and Concluding Thoughts)</h5><p>父子多代联合查询的代价：</p>
<ul>
<li>联合越多，性能越差。</li>
<li>每一代的父文档都要将其字符串类型的 <code>_id</code> 字段存储在内存中，这会占用大量内存。</li>
</ul>
<p>计划使用父子关系时考虑下面建议：</p>
<ul>
<li>尽量少地使用父子关系，仅在子文档远多于父文档时使用。</li>
<li>避免在一个查询中使用多个父子联合语句。</li>
<li>在 has_child 查询中使用 filter 上下文，或者设置 score_mode 为 none 来避免计算文档得分。</li>
<li>保证父 IDs 尽量短，以便在 doc values 中更好地压缩，被临时载入时占用更少的内存。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/parent-child.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/master/404_Parent_Child" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>45-数据建模-扩容设计</title>
    <url>/2020/03/20/ELK%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E7%AC%94%E8%AE%B0/45-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1-%E6%89%A9%E5%AE%B9%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="扩容设计-Designing-for-Scale"><a href="#扩容设计-Designing-for-Scale" class="headerlink" title="扩容设计(Designing for Scale)"></a>扩容设计(Designing for Scale)</h3><p>Elasticsearch扩展灵活，但也有局限性，了解局限性可以使你扩容更轻松。<br>讨论两种数据流：</p>
<ul>
<li>时序数据：时间驱动相关，例如 日志或社交网络数据流</li>
<li>基于用户的数据：拥有很多的文档集但可以按用户或客户细分。</li>
</ul>
<a id="more"></a>
<h3 id="扩容单元-The-Unit-of-Scale"><a href="#扩容单元-The-Unit-of-Scale" class="headerlink" title="扩容单元(The Unit of Scale)"></a>扩容单元(The Unit of Scale)</h3><ul>
<li>一个分片就是一个Lucene索引，一个Elasticsearch索引就是一系列分片的集合。</li>
<li>一个分片就是一个扩容单元。</li>
<li>路由算法：shard = hash(routing) % number_of_primary_shards</li>
</ul>
<h3 id="分片预分配-Shard-Overallocation"><a href="#分片预分配-Shard-Overallocation" class="headerlink" title="分片预分配(Shard Overallocation)"></a>分片预分配(Shard Overallocation)</h3><ul>
<li>在建索引时初期，可以少建几个节点，但可以多建几个分片，方便后期添加节点移动分片。</li>
<li>在 Elasticsearch 中新添加的索引默认被指定了五个主分片。这意味着我们最多可以将那个索引分散到五个节点上，每个节点一个分片。</li>
<li>分片分裂(Shard Splitting): 将每个分片分裂为两个或更多部分的能力。</li>
</ul>
<p>Elasticsearch不支持分片分裂（shard-splitting）的原因：</p>
<ul>
<li>分裂一个分片几乎等于重新索引你的数据。</li>
<li>分裂是指数级的。分裂并不会刚好地把你的处理能力提升 50%。</li>
<li>分片分裂需要你拥有足够的能力支撑另一份索引的拷贝。通常来说，当你意识到你需要横向扩展时，你已经没有足够的剩余空间来做分裂了。</li>
</ul>
<h3 id="海量分片-Kagillion-Shards"><a href="#海量分片-Kagillion-Shards" class="headerlink" title="海量分片(Kagillion Shards)"></a>海量分片(Kagillion Shards)</h3><p>预分配分片太多的话，会有一下问题：</p>
<ul>
<li>一个分片的底层即为一个Lucene索引，会消耗一定文件句柄、内存以及CPU运转。</li>
<li>每个搜索请求都需要命中索引中的每一个分片，如果多个分片在同一个节点上，会竞争相同的资源。</li>
<li>用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度。</li>
</ul>
<h3 id="容量规划"><a href="#容量规划" class="headerlink" title="容量规划"></a>容量规划</h3><ul>
<li>根据自己的场景规划分片的数量</li>
<li>定好单个分片的容量，计算出整个索引的分片，再加上一部分预期增长。</li>
</ul>
<h3 id="副本分片-Replica-Shards"><a href="#副本分片-Replica-Shards" class="headerlink" title="副本分片(Replica Shards)"></a>副本分片(Replica Shards)</h3><ul>
<li>副本分片主要目的是 故障转移。主分片节点挂掉后一个副本分片就成为主分片。</li>
<li>增加副本数并不会增加索引容量，但可以服务于读请求，增加副本分片可以提升查询性能。</li>
<li>通过副本进行负载均衡</li>
</ul>
<h3 id="多索引-Multiple-Indices"><a href="#多索引-Multiple-Indices" class="headerlink" title="多索引(Multiple Indices)"></a>多索引(Multiple Indices)</h3><p>在 索引别名和零停机情况下，通过新增多个索引增加索引的容量。<br>实施步骤：</p>
<ol>
<li>创建两个别名：一个用于搜索(<code>搜索别名</code>)，一个用于索引数据(<code>索引别名</code>)。例如:tweets_search,tweets_index</li>
<li>新增第一个索引A后，把<code>搜索别名</code>和<code>索引别名</code>指向新增的索引A。</li>
<li>新增第二个索引B后，<code>搜索别名</code>指向索引B，<code>索引别名</code>移除索引A指向索引B</li>
<li>依次类推</li>
</ol>
<p>此时两个别名指向：</p>
<ol>
<li>一个搜索请求可以以多个索引为目标，这时<code>搜索别名</code>指向的是 索引A和B，</li>
<li>索引写入请求只能以单个索引为目标，这时<code>索引别名</code>指向的是 索引B</li>
</ol>
<p>注意：通过ID获取文档时，需要对多个索引发起查询ID请求。</p>
<blockquote>
<p>一个文档 GET 请求，像一个索引写入请求那样，只能以单个索引为目标。 这导致在通过ID获取文档这样的场景下有一点复杂。作为代替，你可以对 tweets_1 以及 tweets_2 运行一个 ids 查询 搜索请求， 或者 multi-get 请求。</p>
</blockquote>
<h3 id="基于时间的数据-Time-Based-Data"><a href="#基于时间的数据-Time-Based-Data" class="headerlink" title="基于时间的数据(Time-Based Data)"></a>基于时间的数据(Time-Based Data)</h3><p>Elasticsearch 的常用案例之一便是日志记录.</p>
<ul>
<li>索引中文档数量迅速增长，通常随时间加速。</li>
<li>文档几乎不会更新，基本以最近文档为搜索目标。</li>
<li>随着时间推移，文档逐渐失去价值。</li>
</ul>
<h5 id="按时间范围索引-Index-per-Time-Frame"><a href="#按时间范围索引-Index-per-Time-Frame" class="headerlink" title="按时间范围索引(Index per Time Frame)"></a>按时间范围索引(Index per Time Frame)</h5><p>使用 时间范围索引(index per time frame), 可以按年/月/日进行索引，删旧数据只需删除旧的索引。<br>优点：</p>
<ul>
<li>允许你在需要的时候进行调整扩容</li>
<li>别名可以帮我们更加透明地在索引间切换，将logs_current指向当前索引来接收新的日志事件， 当检索时，更新last_3_months来指向所有最近三个月的索引</li>
</ul>
<h3 id="索引模板"><a href="#索引模板" class="headerlink" title="索引模板"></a>索引模板</h3><p>日志记录类应用，依赖于自动创建索引比手动创建要更加方便。</p>
<p>创建模板</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /_template/my_logs</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"template"</span>: <span class="string">"logstash-*"</span>,</span><br><span class="line">  <span class="attr">"order"</span>:    <span class="number">1</span>,</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"_default_"</span>: &#123;</span><br><span class="line">      <span class="attr">"_all"</span>: &#123;</span><br><span class="line">        <span class="attr">"enabled"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"aliases"</span>: &#123;</span><br><span class="line">    <span class="attr">"last_3_months"</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将这个模板应用于所有以 logstash- 为起始的索引,不论它是手动还是自动创建的。</li>
<li>order 这个模板将会覆盖默认的 logstash 模板，因为默认模板的 order 更低。</li>
<li>number_of_shards 限制主分片数量为 1 。</li>
<li>为所有类型禁用 <code>_all</code> 域。</li>
<li>aliases 添加这个索引至 last_3_months 别名中。</li>
</ul>
<h3 id="数据过期-Retiring-Data"><a href="#数据过期-Retiring-Data" class="headerlink" title="数据过期(Retiring Data)"></a>数据过期(Retiring Data)</h3><p>随着时间推移，基于时间数据的相关度逐渐降低。</p>
<p>删除旧数据很方便:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DELETE &#x2F;logs_2013*</span><br></pre></td></tr></table></figure>

<p>删除它之前还有一些事情可以做来帮助数据更加优雅地过期。</p>
<h5 id="迁移旧索引-Migrate-Old-Indices"><a href="#迁移旧索引-Migrate-Old-Indices" class="headerlink" title="迁移旧索引(Migrate Old Indices)"></a>迁移旧索引(Migrate Old Indices)</h5><ol>
<li><p>服务器指定标签(例如 strong)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;elasticsearch --node.box_type strong</span><br></pre></td></tr></table></figure>
</li>
<li><p>今天的索引使用最好机器</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /logs_2014-10-01</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"index.routing.allocation.include.box_type"</span> : <span class="string">"strong"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>昨天的索引迁移到medium机器上</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /logs_2014-09-30/_settings</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"index.routing.allocation.include.box_type"</span> : <span class="string">"medium"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="索引优化-Optimize-Indices"><a href="#索引优化-Optimize-Indices" class="headerlink" title="索引优化(Optimize Indices)"></a>索引优化(Optimize Indices)</h5><p>今天的索引不能进行优化，优化操作将消耗节点上大量 I/O 并对索引今日日志造成冲击。</p>
<p>对昨天的索引进行有效：1. 先移除副本 2. <a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/merge-process.html#optimize-api" target="_blank" rel="noopener">optimize API</a>进行优化 3. 再添加副本,这样不用优化副本。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST /logs_2014-09-30/_settings</span><br><span class="line">&#123; <span class="attr">"number_of_replicas"</span>: <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">POST /logs_2014-09-30/_optimize?max_num_segments=1</span><br><span class="line"></span><br><span class="line">POST /logs_2014-09-30/_settings</span><br><span class="line">&#123; <span class="attr">"number_of_replicas"</span>: <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>

<h5 id="关闭旧索引"><a href="#关闭旧索引" class="headerlink" title="关闭旧索引"></a>关闭旧索引</h5><p>不访问的索引，又不想删除索引，可以进行关闭，关闭的索引还存在于集群中，重新打开一个索引比从备份中恢复快的多。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">POST /logs_2014-01-*/_flush</span><br><span class="line">POST /logs_2014-01-*/_close</span><br><span class="line">POST /logs_2014-01-*/_open</span><br></pre></td></tr></table></figure>
<ul>
<li><code>_flush</code>刷写（Flush）所有一月的索引来清空事务日志。</li>
<li><code>_close</code> 关闭所有一月的索引.</li>
<li><code>_open</code>当你需要再次访问它们时，使用 open API 来重新打开它们。</li>
</ul>
<h5 id="归档旧索引-Archiving-Old-Indices"><a href="#归档旧索引-Archiving-Old-Indices" class="headerlink" title="归档旧索引(Archiving Old Indices)"></a>归档旧索引(Archiving Old Indices)</h5><p>可以通过​<a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/modules-snapshots.html" target="_blank" rel="noopener">snapshot-restore API</a>​归档.</p>
<h3 id="基于用户的数据-User-Based-Data"><a href="#基于用户的数据-User-Based-Data" class="headerlink" title="基于用户的数据(User-Based Data)"></a>基于用户的数据(User-Based Data)</h3><p>Elasticsearch 支持多租户,所以每个用户可以在相同的集群中拥有自己的索引。<br>“一个用户一个索引”对大多数场景都可以满足了。<br>可以根据每人的索引文档多少和搜索次数多少来分配分片数量和高配服务节点。</p>
<h3 id="共享索引"><a href="#共享索引" class="headerlink" title="共享索引"></a>共享索引</h3><p>我们需要的是一种可以在用户间共享资源的方法，给每个用户他们拥有自己的索引这种印象，而不在小用户上浪费资源。<br>例如 多个论坛(forums)共用一个索引，通过forums_id来标识论坛内的帖子，索引和搜索时路由参数指定forums_id，可以保证同一个论坛存储在同一个分片上。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /forums</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"settings"</span>: &#123;</span><br><span class="line">    <span class="attr">"number_of_shards"</span>: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"mappings"</span>: &#123;</span><br><span class="line">    <span class="attr">"post"</span>: &#123;</span><br><span class="line">      <span class="attr">"properties"</span>: &#123;</span><br><span class="line">        <span class="attr">"forum_id"</span>: &#123;</span><br><span class="line">          <span class="attr">"type"</span>:  <span class="string">"string"</span>,</span><br><span class="line">          <span class="attr">"index"</span>: <span class="string">"not_analyzed"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">PUT /forums/post/1?routing=baking</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"forum_id"</span>: <span class="string">"baking"</span>,</span><br><span class="line">  <span class="attr">"title"</span>:    <span class="string">"Easy recipe for ginger nuts"</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /forums/post/_search?routing=baking</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"bool"</span>: &#123;</span><br><span class="line">      <span class="attr">"must"</span>: &#123;</span><br><span class="line">        <span class="attr">"match"</span>: &#123;</span><br><span class="line">          <span class="attr">"title"</span>: <span class="string">"ginger nuts"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"filter"</span>: &#123;</span><br><span class="line">        <span class="attr">"term"</span>: &#123;</span><br><span class="line">          <span class="attr">"forum_id"</span>: &#123;</span><br><span class="line">            <span class="attr">"baking"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指定多个论坛</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET /forums/post/_search?routing=baking,cooking,recipes</span><br></pre></td></tr></table></figure>
<p>要为每一个查询或者索引请求指定 routing 和 terms 的值看起来有一点的笨拙。 索引别名可以帮你解决这些！</p>
<h3 id="利用别名实现一个用户一个索引"><a href="#利用别名实现一个用户一个索引" class="headerlink" title="利用别名实现一个用户一个索引"></a>利用别名实现一个用户一个索引</h3><p>创建一个别名指定一个过滤器和一个路由器值，使一个别名与一个索引关联起来。<br>例如：别名中的filter和routing配置上 forum_id。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /forums/_alias/baking</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"routing"</span>: <span class="string">"baking"</span>,</span><br><span class="line">  <span class="attr">"filter"</span>: &#123;</span><br><span class="line">    <span class="attr">"term"</span>: &#123;</span><br><span class="line">      <span class="attr">"forum_id"</span>: <span class="string">"baking"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT /baking/post/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"forum_id"</span>: <span class="string">"baking"</span>,</span><br><span class="line">  <span class="attr">"title"</span>:    <span class="string">"Easy recipe for ginger nuts"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们还是需要为过滤器指定 forumn_id 字段，但自定义路由值已经是隐含的了。</li>
</ul>
<p>通过别名搜索帖子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /baking/post/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"ginger nuts"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过多别名搜索帖子</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET /baking,recipes/post/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;</span><br><span class="line">    <span class="attr">"match"</span>: &#123;</span><br><span class="line">      <span class="attr">"title"</span>: <span class="string">"ginger nuts"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/scale.html" target="_blank" rel="noopener">中文参考</a>，<a href="https://github.com/elastic/elasticsearch-definitive-guide/tree/master/410_Scaling" target="_blank" rel="noopener">英文参考</a></p>
]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ES</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>spring的事务 隔离级别和传播机制</title>
    <url>/2019/12/26/spring/spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>快速理解 spring 隔离级别和传播机制</p>
<a id="more"></a>
<h3 id="事务ACID四大特性"><a href="#事务ACID四大特性" class="headerlink" title="事务ACID四大特性"></a>事务ACID四大特性</h3><ul>
<li>Atomicity 原子性：要么成功，要么失败，不允许部分成功或失败。</li>
<li>Consistency 一致性：事务操作之后数据库状态和业务规则一致。AB转账，A减少并且B增加。</li>
<li>Isolation 隔离性：多个事务并发执行，相互之间不干扰，和独立执行事务一样。</li>
<li>Durability 持久性：事务提交后被持久化到数据库.</li>
</ul>
<h3 id="spring事务知识点"><a href="#spring事务知识点" class="headerlink" title="spring事务知识点"></a>spring事务知识点</h3><ol>
<li>spring有两种事务管理方式：编程式和声明式<ul>
<li>编程式：在代码中显示调用beginTransaction(),commit(),rollback()等事务管理方法。</li>
<li>声明式：spring声明式事务是使用AOP切面实现，通过aop管理这事务的开始，提交和回滚。<br>注意两点：  <ol>
<li>@Transactional 应该注解在public方法中，因为需要AOP代理。</li>
<li>由于aop代理的是接口和类，所以同一个类中的两个方法调用是不会涉及到事务传播的。</li>
</ol>
</li>
</ul>
</li>
<li>spring事务隔离级别<ul>
<li>隔离级别：</li>
<li>spring支持的5种隔离级别：DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE</li>
</ul>
</li>
<li>spring事务传播方式<ul>
<li>传播方式 ：</li>
<li>传播方式：REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED</li>
</ul>
</li>
<li>事务回滚规则，指定遇到指定异常时事务进行回滚。</li>
<li>事务其他属性</li>
</ol>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="数据库并发访问面临的问题"><a href="#数据库并发访问面临的问题" class="headerlink" title="数据库并发访问面临的问题"></a>数据库并发访问面临的问题</h4><table>
<thead>
<tr>
<th align="left">英文名</th>
<th align="left">中文名</th>
<th align="left">问题描述</th>
<th align="left">缺点</th>
<th align="left">mysql解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Dirty Read</td>
<td align="left">脏读</td>
<td align="left">事务A未提交的数据被其他事务B读取，如果事务A回滚，事务B的数据就是错误。</td>
<td align="left">会读到未提交的数据(脏数据)</td>
<td align="left">没加锁时会脏读产生，加锁就可以解决脏读</td>
</tr>
<tr>
<td align="left">No-Repeatable read</td>
<td align="left">不可重复读</td>
<td align="left">一次事务中两次相同数据的内容不一致，同一数据的内容有变化了，导致不能重复读取同一数据，原因是在两次查询时间段内其他事务更新(update和delete)了数据。</td>
<td align="left">一次事务不能重复读取同一数据</td>
<td align="left">使用有索引时使用行锁控制行的更新和删除，</td>
</tr>
<tr>
<td align="left">Phantom Read</td>
<td align="left">幻读</td>
<td align="left">一次事务中两次读取一定范围的数据时有新数据(‘幻影’行)产生，原因是在两次查询时间段内其他事务新增(insert)了数据。</td>
<td align="left">一次事务两次读取数据的数量不同了</td>
<td align="left">Next-Key锁(行锁和GAP间隙锁两者的合并) ,行锁锁定一定范围的行，间隙锁锁定范围两边的数据，这样就保证不会插入数据</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="spring支持的隔离级别"><a href="#spring支持的隔离级别" class="headerlink" title="spring支持的隔离级别"></a>spring支持的隔离级别</h4><p>| 名称 | 说明| 存在问题|解决的问题|mysql解决方式|<br>|:—|:—| :—|:—|<br>|DEFAULT          |默认值，spring使用数据库设置的隔离级别 |  | | |<br>|READ_UNCOMMITTED |读未提交内容 |脏读，不可重复读，幻读 | | |<br>|READ_COMMITTED   |读取提交内容 |不可重复读，幻读  | 脏读| |<br>|REPEATABLE_READ  |可重复读，mysql默认值 | 幻读  |脏读，不可重复读 | |<br>|SERIALIZABLE     |可串行化 |   |脏读，不可重复读，幻读 |使用悲观锁理论，读加共享锁，写加排他锁，读写互斥 |</p>
<h3 id="传播机制"><a href="#传播机制" class="headerlink" title="传播机制"></a>传播机制</h3><p>| 名称 | 说明|没有事务|已存在事务|事务提交|事务回滚|<br>|:—|:—| :—|:—|:—|<br>|REQUIRED     |默认，必须有事务|新建事务|加入当前事务|一起提交 |一起回滚 |<br>|SUPPORTS     |支持已有事务 |非事务方式运行 |加入当前事务 |一起提交 |一起回滚 |<br>|MANDATORY    |强制使用事务 |抛出异常，父方法必须有事务 |加入当前事务 |一起提交 |一起回滚 |<br>|REQUIRES_NEW |总是新建事务 |新建事务 |挂起父事务 |子事务单独提交，然后挂起的父事务继续提交 |父事务回滚,子事务不受不影响；子事务回滚，父事务捕获子事务异常后不回滚 |<br>|NOT_SUPPORTED|总是以非事务方式运行 |非事务方式运行 |挂起父事务，以非事务方式运行 |无 | 无|<br>|NEVER        |一点事务都没有 |非事务方式运行 |抛出异常，父方法不能有事务 | 无| 无|<br>|NESTED       |嵌套事务 |新建事务 |成为子事务 | 父事务和嵌套事务一起提交| 父事务回滚时嵌套事务也需要回滚；嵌套事务回滚时父事务可以不回滚|</p>
<h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><ul>
<li>java异常分类：异常分为 Error和Throwable， Throwable又分</li>
<li>为RuntimeException(unchecked)和checked<br>spring默认回滚规则：uncheck异常和Error会回滚事务；checked异常不回滚事务。</li>
</ul>
<h4 id="设置回滚的异常"><a href="#设置回滚的异常" class="headerlink" title="设置回滚的异常"></a>设置回滚的异常</h4><ul>
<li>遇到checked异常时回滚事务：<br> @Transactional(rollbackFor = Exception.class)<br> @Transactional(rollbackForClassName = “Exception”)</li>
<li>遇到unchecked异常时回滚事务(默认)<br>@Transactional(rollbackFor = RuntimeException.class)<br>@Transactional(rollbackForClassName = “RuntimeException”)</li>
<li>全部异常都回滚<br>@Transactional(rollbackFor = {RuntimeException.class,Exception.class})<br>@Transactional(rollbackForClassName = { “RuntimeException”, “Exception”})</li>
<li>指定的异常不回滚<br>@Transactional(noRollbackFor = {RuntimeException.class,Exception.class})<br>@Transactional(noRollbackForClassName = { “RuntimeException”, “Exception”})</li>
</ul>
<h3 id="事务其他配置"><a href="#事务其他配置" class="headerlink" title="事务其他配置"></a>事务其他配置</h3><ul>
<li>readOnly : true: 只读事务，false : 可读写(默认值)</li>
<li>timeout : 设置事务超时时间，默认值 -1，表示永不过期</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>事务是线程安全的。</li>
<li>事务继承问题。</li>
<li>声明式事务，@Transactional 应该注解到public方法上。</li>
<li>声明式事务是基于aop实现的，所以同一个类中方法调用时事务是不起作用的。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/zhangyu672090/article/details/82828542" target="_blank" rel="noopener">https://blog.csdn.net/zhangyu672090/article/details/82828542</a><br><a href="https://segmentfault.com/a/1190000020386113?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020386113?utm_source=tag-newest</a><br><a href="https://blog.csdn.net/yuanlaishini2010/article/details/45792069" target="_blank" rel="noopener">https://blog.csdn.net/yuanlaishini2010/article/details/45792069</a><br><a href="https://yq.aliyun.com/articles/313201" target="_blank" rel="noopener">https://yq.aliyun.com/articles/313201</a><br><a href="https://www.cnblogs.com/fxtx/p/11630331.html" target="_blank" rel="noopener">https://www.cnblogs.com/fxtx/p/11630331.html</a><br><a href="https://www.w3xue.com/exp/article/20197/45742.html" target="_blank" rel="noopener">https://www.w3xue.com/exp/article/20197/45742.html</a></p>
<p>隔离级别<br><a href="https://yq.aliyun.com/articles/100727?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=8k1J_IfQ" target="_blank" rel="noopener">https://yq.aliyun.com/articles/100727?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=8k1J_IfQ</a><br><a href="https://yq.aliyun.com/articles/48893?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=IyVCk5A7" target="_blank" rel="noopener">https://yq.aliyun.com/articles/48893?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=IyVCk5A7</a><br><a href="https://yq.aliyun.com/articles/555101?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=OYciFPCm" target="_blank" rel="noopener">https://yq.aliyun.com/articles/555101?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=OYciFPCm</a><br><a href="https://www.cnblogs.com/ubuntu1/p/8999403.html" target="_blank" rel="noopener">https://www.cnblogs.com/ubuntu1/p/8999403.html</a><br><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p>
<p>Spring的TransactionEventListener<br><a href="https://www.jianshu.com/p/88b76e870c63" target="_blank" rel="noopener">https://www.jianshu.com/p/88b76e870c63</a></p>
]]></content>
      <categories>
        <category>framework-tools</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>前端技术思维导图</title>
    <url>/2020/05/29/front/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<h3 id="前端技术思维导图"><a href="#前端技术思维导图" class="headerlink" title="前端技术思维导图"></a>前端技术思维导图</h3><p>整理了一下前端技术的思维导图，快速了解前端技术全貌。</p>
<a id="more"></a>
<p><img data-src="http://qax2cai8x.bkt.clouddn.com/front-tech-overview.png" alt="前端技术思维导图"></p>
]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
        <tag>node</tag>
        <tag>react native</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Class和Object关系,以及Type类型</title>
    <url>/2020/05/26/java/20200526-Class%E5%92%8CObject%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> 了解Class、Object、Type类型之间的关系。</p>
 <a id="more"></a>

<h3 id="Class-和-Object"><a href="#Class-和-Object" class="headerlink" title="Class 和 Object"></a>Class 和 Object</h3><ul>
<li>Class只是一个用于描述Java类与接口的、用于支持反射操作的类型，java.lang.Object是一个Java类。</li>
<li>所有java类都继承了Object类，Class是类，那么Class也继承自Object。</li>
<li>Object.getClass()是一个实例方法，返回的是java.lang.Class的实例，用于表示对象对应类型的类反射信息。<br>类图如下：<img data-src="http://qax2cai8x.bkt.clouddn.com/Class-Object-relationship.png" alt="Class-Object-relationship"></li>
</ul>
<h3 id="bootstrap-自举过程"><a href="#bootstrap-自举过程" class="headerlink" title="bootstrap(自举过程)"></a>bootstrap(自举过程)</h3><ol>
<li>JVM先对核心类型分配好内存空间，这时的状态是[已分配空间]但[未完成初始化]，状态不完整还不能使用。</li>
<li>串联好核心类型的引用关系</li>
<li>核心类型进入[完全初始化]状态，开始执行java字节码完成java系统的初始化。</li>
</ol>
<h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><p>Type是所有类的父接口，是所有类型的抽象。java 5 引入了Type类型，应该是为了加入泛型才引入的。Type类路径是 java.lang.reflect.Type。<br>Type类图：<br><img data-src="http://qax2cai8x.bkt.clouddn.com/java-Type.png" alt=""></p>
<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><ul>
<li><p>先有Class还是先有Object？ - RednaxelaFX的回答 - 知乎<br><a href="https://www.zhihu.com/question/30301819/answer/47539163" target="_blank" rel="noopener">https://www.zhihu.com/question/30301819/answer/47539163</a></p>
</li>
<li><p>详解Java中的Object.getClass()方法<br><a href="https://www.bbsmax.com/A/MAzADeo8d9/" target="_blank" rel="noopener">https://www.bbsmax.com/A/MAzADeo8d9/</a></p>
</li>
<li><p>秒懂Java类型（Type）系统<br><a href="https://blog.csdn.net/ShuSheng0007/article/details/89520530" target="_blank" rel="noopener">https://blog.csdn.net/ShuSheng0007/article/details/89520530</a></p>
</li>
<li><p>Java中的Type知多少？(上）<br><a href="https://mp.weixin.qq.com/s/sNodHgRgAWSgl5e2MgPRFQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/sNodHgRgAWSgl5e2MgPRFQ</a></p>
</li>
<li><p>Java中的Type知多少？(下）<br><a href="https://mp.weixin.qq.com/s/oKA9nHmxghkUaPArJ7yQzQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oKA9nHmxghkUaPArJ7yQzQ</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>类图中几种关系</title>
    <url>/2020/05/26/java/20200526-%E7%B1%BB%E5%9B%BE%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="类间关系"><a href="#类间关系" class="headerlink" title="类间关系"></a>类间关系</h3><p>表示类之间的关系有： 继承(泛化)、实现、依赖、关联、聚合、组合<br>耦合强度依次从弱到强：依赖&lt;关联&lt;聚合&lt;组合&lt;实现=继承(泛化)</p>
<p>纵向关系 ：继承(泛化)、实现<br>横向关系 ：依赖、关联、聚合、组合</p>
<a id="more"></a>
<h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>是一种’使用’关系，不在实例作用域内的一个类或对象的引用。<br>A类中使用了B类。这种使用关系是偶然性的(例如：方法不是每次都使用)，临时的(方法中的引用结束后就失效)，很弱的，但B的变化会影响A。<br>具体表现为：1. 方法的参数和返回值 2. 方法中的局部变量 3. 类的静态方法的引用</p>
<h3 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h3><p>是一种’连接’关系，是一个实例作用域的变量。关系是长期的，平等的，关联可以是单向、双向。<br>具体表现： 1. 类B是类A的成员属性 2. 类B的全局变量被类A引用</p>
<h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ul>
<li>聚合和组合都是关联的一种特例，在代码层面与关联关系是一样的，只是在语义级别的有区别，就是赋加一种逻辑关系。</li>
<li>聚合是has-a关系，提现的是整体和部分、拥有的关系。</li>
<li>整体和部分有各自的生命周期，他们是可以分离。部分可以属于多个整体，也可以被多个整体共享。<br>例子：公司和员工的关系，雁群和大雁的关系</li>
</ul>
<h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li>聚合和组合都是关联的一种特例，在代码层面与关联关系是一样的，只是在语义级别的有区别，就是赋加一种逻辑关系。</li>
<li>组合是contain-a的关系，部分的存活在整体生命周期中，整体生命周期结束部分生命周期也结束。<br>例子： 你和你的胳膊，</li>
</ul>
<p>如果通过常识无法区分聚合和组合，那么可以按照自己的需求去定义是聚合还是组合。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实例如图：<br><img data-src="http://qax2cai8x.bkt.clouddn.com/class-diagram.png" alt=""></p>
<p>源码如下：</p>
<p>公司:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String companyName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量，语义上是公司拥有打印机，has-a的关系，所以是聚合关系.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Printer&gt; printers;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>部门:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 部门名称.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String deptName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 雇员.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employees;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>普通人：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>雇员：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 岗位.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String position;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 部门编号.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> departmentId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印机:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>dao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存雇员信息.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dao实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDaoImpl</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">EmployeeDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmployeeService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Company <span class="title">getCompany</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modifyDepartment</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>service实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeServiceImpl</span> <span class="keyword">implements</span> <span class="title">EmployeeService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量，关联关系, new EmployeeDaoImpl 依赖关系.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeDao employeeDao = <span class="keyword">new</span> EmployeeDaoImpl();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数，依赖关系.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> employee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Employee employee)</span> </span>&#123;</span><br><span class="line">        employeeDao.save(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回类型, 依赖关系.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">getCompany</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法中使用Department, 依赖关系.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyDepartment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Department department = <span class="keyword">new</span> Department();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h5><p>继承、实现、依赖、关联、聚合、组合的联系与区别<br><a href="https://www.cnblogs.com/jiqing9006/p/5915023.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiqing9006/p/5915023.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>java中的泛型</title>
    <url>/2020/06/03/java/20200529-java%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h3><p>泛型就是参数化类型，类型以参数形式传递给接口、类和方法中。</p>
<h3 id="泛型的目的和作用"><a href="#泛型的目的和作用" class="headerlink" title="泛型的目的和作用"></a>泛型的目的和作用</h3><p>泛型的目的是：1.为了安全，避免类型转换异常 2. 为了是代码更泛化<br>泛型的作用是：把运行时的类型强转(cast)检查，提前到编译器的类型检查。</p>
<a id="more"></a>

<h3 id="泛型分类"><a href="#泛型分类" class="headerlink" title="泛型分类"></a>泛型分类</h3><ul>
<li>按照参数定义地方分为：泛型类(定义在类名后)，泛型接口(定义在接口后面)，泛型方法(定义在返回值前面)</li>
<li>按照参数类型分为：ParameterizedType(参数化类型),TypeVariable(类型变量),WildcardType(通配符类型),GenericArrayType（泛型数组类型)</li>
<li>按照边界(bounds)分：有界，无界；有界又分为：上界(关键字 extends)，下界(关键字 super)；无界是只指定参数没指定上下界的都属于无界，例如：<T>、&lt;?&gt;</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li><T>和<?>区别： <T>只能代表同一种类型；<?> 没有类型限制。</li>
<li>&amp;符号与关键字implements一样，表示实现接口，泛型定义中必须先定义类型再实现定义接口</li>
</ul>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="分类-参数定义地方"><a href="#分类-参数定义地方" class="headerlink" title="分类-参数定义地方"></a>分类-参数定义地方</h4><ul>
<li><p>泛型接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hasColor</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Fruit</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T tool;</span><br><span class="line"></span><br><span class="line">  Apple(T t) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tool = t;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hasColor</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>泛型方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T tool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是泛型方法：类的泛型参数T 和 方法的泛型参数E 两者共存</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">productJuice</span><span class="params">(T t, E e)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是泛型方法，参数T是方法中定义的参数T，不是类的泛型参数T。方法参数T优先级高于类的参数T。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">productJuice2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 没有定义泛型参数，不是泛型方法。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">hasColor</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分类-参数类型"><a href="#分类-参数类型" class="headerlink" title="分类-参数类型"></a>分类-参数类型</h4><ul>
<li><p>ParameterizedType(参数化类型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterizedTypeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; mapField;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map.Entry&lt;String, Integer&gt; entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TypeVariable(类型变量)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeVariableTest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>WildcardType(通配符类型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildcardTypeTest</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ? extends Number, map的key必须继承Number，即key类型上界是Number，常做为生产者。</span></span><br><span class="line"><span class="comment">     * ? super String，map的value 必须是String的父类，即value的下界类型是String，常做为消费者。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;? extends Number, ? <span class="keyword">super</span> String&gt; field;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>GenericArrayType（泛型数组类型)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericArrayTypeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt;[] field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="分类-边界-bounds"><a href="#分类-边界-bounds" class="headerlink" title="分类-边界(bounds)"></a>分类-边界(bounds)</h4><ul>
<li>无界<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnboundedTest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T field;</span><br><span class="line">    List&lt;T&gt; list1;</span><br><span class="line">    List&lt;?&gt; list2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>有界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedTest</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T field;</span><br><span class="line">    <span class="comment">// 上界，常用于生产者，进行写入操作</span></span><br><span class="line">    List&lt;? extends Number&gt; lists1;</span><br><span class="line">    <span class="comment">// 下界，常用于生产者，进行读取操作</span></span><br><span class="line">    List&lt;? <span class="keyword">super</span> String&gt; lists2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &amp;表示implements接口，顺序必须先类型再接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solid</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Coord</span> &amp; <span class="title">HasColor</span> &amp; <span class="title">Weight</span>&gt; </span>&#123;</span><br><span class="line">    T item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bounded</span> <span class="keyword">extends</span> <span class="title">Coord</span> <span class="keyword">implements</span> <span class="title">HasColor</span>, <span class="title">Weight</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicBounds</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solid&lt;Bounded&gt; boundedSolid = <span class="keyword">new</span> Solid&lt;Bounded&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上界和下界</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//--------------  上界 -----------------------------</span></span><br><span class="line">        Plate&lt;? extends Fruit&gt; p = <span class="keyword">new</span> Plate&lt;Apple&gt;(<span class="keyword">new</span> Apple());</span><br><span class="line">        <span class="comment">// 不能存入任何元素，编译器只知道是Fruit或Fruit子类，无法确定是哪个具体类型，所以不允许插入</span></span><br><span class="line">        p.set(<span class="keyword">new</span> Fruit()); <span class="comment">//Error</span></span><br><span class="line">        p.set(<span class="keyword">new</span> Apple()); <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取出来的东西只能存在Fruit或Fruit的父类里，读取值放在上界类，隐式转换为父类。</span></span><br><span class="line">        Fruit newFruit1 = p.get();</span><br><span class="line">        Object newFruit2 = p.get();</span><br><span class="line">        Apple newFruit3 = p.get();  <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//--------------- 下界  ----------------------------</span></span><br><span class="line">        Plate&lt;? <span class="keyword">super</span> Fruit&gt; p2 = <span class="keyword">new</span> Plate&lt;Fruit&gt;(<span class="keyword">new</span> Fruit());</span><br><span class="line">        <span class="comment">// 存入元素正常，存入Fruit或其子类都是可以，因为Fruit子类可以隐式转换为Fruit。</span></span><br><span class="line">        p2.set(<span class="keyword">new</span> Fruit());</span><br><span class="line">        p2.set(<span class="keyword">new</span> Apple());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取出来的东西只能存放在Object(上界)里，读取值放在上界类，隐式转换为父类。</span></span><br><span class="line">        Apple apple = p2.get(); <span class="comment">//Error</span></span><br><span class="line">        Fruit fruit = p2.get(); <span class="comment">//Error</span></span><br><span class="line">        Object object = p2.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-------------------------------------------</span></span><br><span class="line">        <span class="comment">// PECS (Producer Extends Consumer Super)</span></span><br><span class="line">        <span class="comment">// 频繁往外读取内容，适用于上界 extends</span></span><br><span class="line">        <span class="comment">// 经常往里插入的，适合用下界Super</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Leve1 - 食物</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Level2 - 水果和肉</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Meat</span> <span class="keyword">extends</span> <span class="title">Food</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Level3</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Banana</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pork</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beef</span> <span class="keyword">extends</span> <span class="title">Meat</span></span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Level 4</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RedApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123; &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GreenApple</span> <span class="keyword">extends</span> <span class="title">Apple</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T item;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Plate</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            item=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            item=t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>待续…</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h3 id="Type类型"><a href="#Type类型" class="headerlink" title="Type类型"></a>Type类型</h3><p>java 5引入了Type类型，应该是为了加入泛型才引入的。Type类路径是 java.lang.reflect.Type</p>
<hr>
<hr>
<p>参考：<br>java编程思想-泛型<br><a href="https://lingcoder.gitee.io/onjava8/#/book/20-Generics" target="_blank" rel="noopener">https://lingcoder.gitee.io/onjava8/#/book/20-Generics</a></p>
<p>秒懂Java类型（Type）系统<br><a href="https://blog.csdn.net/ShuSheng0007/article/details/89520530" target="_blank" rel="noopener">https://blog.csdn.net/ShuSheng0007/article/details/89520530</a></p>
<p>Java中的Type知多少？(上）<br><a href="https://mp.weixin.qq.com/s/sNodHgRgAWSgl5e2MgPRFQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/sNodHgRgAWSgl5e2MgPRFQ</a></p>
<p>Java中的Type知多少？(下）<br><a href="https://mp.weixin.qq.com/s/oKA9nHmxghkUaPArJ7yQzQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/oKA9nHmxghkUaPArJ7yQzQ</a></p>
<p>秒懂Java泛型<br><a href="https://blog.csdn.net/ShuSheng0007/article/details/80720406" target="_blank" rel="noopener">https://blog.csdn.net/ShuSheng0007/article/details/80720406</a></p>
<p>Java泛型与注解<br><a href="https://blog.csdn.net/AhaQianxun/article/details/92594745" target="_blank" rel="noopener">https://blog.csdn.net/AhaQianxun/article/details/92594745</a></p>
<p>秒懂Java反射<br><a href="https://blog.csdn.net/ShuSheng0007/article/details/81809999" target="_blank" rel="noopener">https://blog.csdn.net/ShuSheng0007/article/details/81809999</a></p>
<p>困扰多年的Java泛型 extends T&gt; super T&gt;，终于搞清楚了！<br><a href="https://blog.csdn.net/javaQQ561487941/article/details/90694010" target="_blank" rel="noopener">https://blog.csdn.net/javaQQ561487941/article/details/90694010</a></p>
<p>Java 泛型 &lt;? super T&gt; 中 super 怎么 理解？与 extends 有何不同？<br><a href="https://www.zhihu.com/question/20400700" target="_blank" rel="noopener">https://www.zhihu.com/question/20400700</a></p>
<p>Java泛型超详细解读 : super和extend<br><a href="https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098731?fps=1&amp;locationNum=2" target="_blank" rel="noopener">https://blog.csdn.net/c10WTiybQ1Ye3/article/details/78098731?fps=1&amp;locationNum=2</a></p>
<p>泛型超详细解读（二）：super和extend<br><a href="https://blog.csdn.net/jeffleo/article/details/52250948" target="_blank" rel="noopener">https://blog.csdn.net/jeffleo/article/details/52250948</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>试用vercel托管博客</title>
    <url>/2020/05/29/%E5%85%B6%E4%BB%96/20200529-%E8%AF%95%E7%94%A8vercel%E6%89%98%E7%AE%A1%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>vercel是一家云部署服务的公司，支持静态托管以及 Serverless 服务。<br>免费服务</p>
<blockquote>
<ol>
<li>免费额度有 20 GB，够用</li>
<li>提供 Serverless 服务</li>
<li>免费自定义域名，支持 HTTPS</li>
<li>不限站点与 Serverless API 数量</li>
<li>Serverless 支持 Node.js, Go,Python, Ruby  </li>
<li>提供 Google Cloud 与 AWS 节点，有香港与台湾节点</li>
<li>支持 now.sh CLI，GitHub，GitLab，Bitbucket 导入/部署</li>
</ol>
</blockquote>
<p>参考这篇 <a href="https://www.qtmuniao.com/2020/03/15/hexo-to-zeit-co/" target="_blank" rel="noopener">使用 zeit.co 托管 Hexo 静态博客
</a> 文章对自己的博客进行托管服务试用。</p>
<a id="more"></a>
<h3 id="关联github账户，同步代码"><a href="#关联github账户，同步代码" class="headerlink" title="关联github账户，同步代码"></a>关联github账户，同步代码</h3><p>使用github账号登录 <a href="https://vercel.com" target="_blank" rel="noopener">https://vercel.com</a> 。</p>
<p>步骤：</p>
<ol>
<li>关联github账户</li>
<li>选择同步一个项目</li>
<li>vercel同步完后就有一个可以访问的站点，同github.io。</li>
<li>如果push修改到github,vercel会自动同步</li>
</ol>
<h3 id="设置域名"><a href="#设置域名" class="headerlink" title="设置域名"></a>设置域名</h3><p>站点建完后vercel提供了3个不同的域名：<br>fandro-blog.fandro.now.sh<br>fandro-blog.now.sh<br>fandro-blog-2rqktxlpl.now.sh  </p>
<h3 id="设置域名跳转地址"><a href="#设置域名跳转地址" class="headerlink" title="设置域名跳转地址"></a>设置域名跳转地址</h3><ol>
<li><p>获取域名(fandro-blog.now.sh)的ip地址,</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ ping fandro-blog.now.sh  </span><br><span class="line">64 bytes from 104.199.217.228: icmp_seq=0 ttl=34 time=60.423 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>去域名商网站设置新跳转地址104.199.217.228,</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">名称</th>
<th align="left">值</th>
<th align="left">TTL</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="left">@</td>
<td align="left">104.199.217.228</td>
<td align="left">1小时</td>
</tr>
</tbody></table>
<h4 id="vercel也支持hexo源文件"><a href="#vercel也支持hexo源文件" class="headerlink" title="vercel也支持hexo源文件"></a>vercel也支持hexo源文件</h4><p>我同步的是hexo已经生成好的站点文件，可以直接访问。vercel 也支持hexo源文件，vercel可以自动执行hexo命令生成站点。</p>
<h3 id="vercel-优势是访问速度快"><a href="#vercel-优势是访问速度快" class="headerlink" title="vercel 优势是访问速度快"></a>vercel 优势是访问速度快</h3>]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
