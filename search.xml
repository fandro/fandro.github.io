<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql中的锁详解</title>
    <url>/2020/01/03/mysql%E4%B8%AD%E7%9A%84%E9%94%81%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h4><p>了解mysql中的各种锁</p>
<a id="more"></a>
<h4 id="事务ACID四大特性"><a href="#事务ACID四大特性" class="headerlink" title="事务ACID四大特性"></a>事务ACID四大特性</h4><ul>
<li>Atomicity 原子性：要么成功，要么失败，不允许部分成功或失败。</li>
<li>Consistency 一致性：事务操作之后数据库状态和业务规则一致。AB转账，A减少并且B增加。</li>
<li>Isolation 隔离性：多个事务并发执行，相互之间不干扰，和独立执行事务一样。</li>
<li>Durability 持久性：事务提交后被持久化到数据库.</li>
</ul>
<h4 id="并发访问面临的问题"><a href="#并发访问面临的问题" class="headerlink" title="并发访问面临的问题"></a>并发访问面临的问题</h4><table>
<thead>
<tr>
<th align="left">英文名</th>
<th align="left">中文名</th>
<th align="left">问题描述</th>
<th align="left">缺点</th>
<th align="left">mysql解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Dirty Read</td>
<td align="left">脏读</td>
<td align="left">事务A未提交的数据被其他事务B读取，如果事务A回滚，事务B的数据就是错误。</td>
<td align="left">会读到未提交的数据(脏数据)</td>
<td align="left">没加锁时会脏读产生，加锁就可以解决脏读</td>
</tr>
<tr>
<td align="left">No-Repeatable read</td>
<td align="left">不可重复读</td>
<td align="left">一次事务中两次相同数据的内容不一致，同一数据的内容有变化了，导致不能重复读取同一数据，原因是在两次查询时间段内其他事务更新(update和delete)了数据。</td>
<td align="left">一次事务不能重复读取同一数据</td>
<td align="left">检索数据时用到索引，使用索引上的行锁控制行的更新和删除，</td>
</tr>
<tr>
<td align="left">Phantom Read</td>
<td align="left">幻读</td>
<td align="left">一次事务中两次读取一定范围的数据时有新数据(‘幻影’行)产生，原因是在两次查询时间段内其他事务新增(insert)了数据。【另解释：幻读，并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。】</td>
<td align="left">一次事务两次读取数据的数量不同了，</td>
<td align="left">Next-Key锁(行锁和GAP间隙锁两者的合并) ,行锁锁定一定范围的行，间隙锁锁定范围两边的数据，这样就保证不会插入数据</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><table>
<thead>
<tr>
<th align="left">名称</th>
<th align="left">说明</th>
<th align="left">存在问题</th>
<th align="left">解决的问题</th>
<th align="left">mysql解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DEFAULT</td>
<td align="left">默认值，spring使用数据库设置的隔离级别</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">READ_UNCOMMITTED</td>
<td align="left">读未提交内容</td>
<td align="left">脏读，不可重复读，幻读</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">READ_COMMITTED</td>
<td align="left">读取提交内容</td>
<td align="left">不可重复读，幻读</td>
<td align="left">脏读</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">REPEATABLE_READ</td>
<td align="left">可重复读，mysql默认值</td>
<td align="left">幻读</td>
<td align="left">脏读，不可重复读</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">SERIALIZABLE</td>
<td align="left">可串行化</td>
<td align="left"></td>
<td align="left">脏读，不可重复读，幻读</td>
<td align="left">使用悲观锁理论，读加共享锁，写加排他锁，读写互斥</td>
</tr>
</tbody></table>
<h4 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h4><ol>
<li>按使用方式分类:<ul>
<li>悲观锁</li>
<li>乐观锁</li>
</ul>
</li>
</ol>
<ol start="2">
<li>按封锁级别分类:<ul>
<li>共享锁(S锁)</li>
<li>排他锁(X锁)</li>
<li>意向锁</li>
<li>间隙锁</li>
</ul>
</li>
</ol>
<ol start="3">
<li>按封锁类型分类：<ul>
<li>排他锁(又称写锁，X锁)：阻止其他事务对数据对象A的读和写</li>
<li>共享锁(S锁)<br>封锁数据对象可以是表和行</li>
</ul>
</li>
</ol>
<ol start="3">
<li>按封锁的数据粒度分类：<ul>
<li>表级锁定</li>
<li>行级锁定</li>
<li>页级锁定</li>
</ul>
</li>
</ol>
<ol start="4">
<li>innodb 内部意向锁：<ul>
<li>意向排他锁</li>
<li>意向共享锁<br>在表锁和行锁多粒度锁共存时，行加锁时需先获取表的意向锁，通过意向锁实现多粒度锁机制，意向锁是表级锁。</li>
</ul>
</li>
</ol>
<h4 id="锁的详解"><a href="#锁的详解" class="headerlink" title="锁的详解"></a>锁的详解</h4><h5 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h5><p>排他锁又称独占锁、写锁、X锁，目的是阻塞其他事务对数据进行读和写操作。事务T对数据对象A加上X锁，此时只有事务T可以对数据对象A进行读取和修改，其他事务无法对对象A加锁，直到事务T释放了X锁。排他锁就是</p>
<h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><p>共享锁又称读锁、S锁，目的是阻塞其他事务对数据进行写操作。事务T对数据对象A加上S锁，其他事务加上S锁可以读取数据对象A，如果其他事务想修改数据对象，加X锁会失败。</p>
<h5 id="表级锁（table-level）"><a href="#表级锁（table-level）" class="headerlink" title="表级锁（table level）"></a>表级锁（table level）</h5><p>数据对象锁定粒度是整个表，由于粒度大，逻辑简单，所以表锁开销小、加锁快、不会出现死锁。缺点：粒度大导致锁冲突概率高，并发性能很差。</p>
<ul>
<li>优点：逻辑简单，开销小，加锁快，不会出现死锁</li>
<li>缺点：锁冲突概率高，并发性能低</li>
</ul>
<p><strong>什么时候使用表锁?</strong></p>
<blockquote>
<ol>
<li>事务需要更新大部分或全部数据，表比较大，如果默认使用行锁，会导致长时间锁等待和频繁锁冲突，事务效率低，这种情况下使用表锁会提高事务的执行速度。  </li>
<li>事务涉及多表，逻辑比较复杂，可能会引起死锁，造成大量事务回滚，这种情况可以考虑一次性锁定相关表，从而避免死锁，减少事务回滚带来的开销。</li>
</ol>
</blockquote>
<h5 id="行级锁（row-level）"><a href="#行级锁（row-level）" class="headerlink" title="行级锁（row level）"></a>行级锁（row level）</h5><p>数据对象锁定粒度为数据行，由于粒度很小，每次获取和释放锁需要处理的逻辑比较多，系统开销比较大，但锁冲突的概率大大降低，并发性能比较好。  </p>
<ul>
<li>优点：锁粒度小，锁冲突概率低，并发性能好</li>
<li>缺点：锁逻辑复杂，系统开销大，容易发生死锁</li>
</ul>
<h5 id="页级锁-page-level"><a href="#页级锁-page-level" class="headerlink" title="页级锁 (page level)"></a>页级锁 (page level)</h5><p>页级锁是mysql特有的一种锁，页级锁粒度介于表级锁和行级锁之间，所以获取锁的资源开销和并发性能也介于两者之间，页级锁也会出现死锁情况。</p>
<h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>为了实现表锁和行锁共存，实现多粒度锁机制，innoDB使用了两个内部的意向锁（Intention Locks）,这两个都是表锁。<br>意向锁的主要作用是提升存储引擎性能，innoDB中的行级S锁和行级X锁，每当事务到来时，存储引擎需要遍历所有行的锁持有情况，性能较低，因此引入意向锁，检查行锁前先检查意向锁是否存在，如果存在则阻塞线程。</p>
<h5 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a>意向排他锁</h5><p>事务在给一个数据行加排他锁之前必须先获得该表的意向排他锁。</p>
<h5 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h5><p>事务在给一个数据行加共享锁之前必须先获得该表的意向共享锁。</p>
<h4 id="间隙锁-next-key锁"><a href="#间隙锁-next-key锁" class="headerlink" title="间隙锁(next-key锁)"></a>间隙锁(next-key锁)</h4><p>&nbsp;&nbsp;当我们用范围条件检索数据，并请求共享锁或排他锁时，InnoDB会给符合条件数据记录的索引加上行锁，对键值在条件范围内但并不存在的记录，称为间隙，InnoDB会给间隙加锁，称为间隙锁。  </p>
<h6 id="1-间隙锁产生的条件"><a href="#1-间隙锁产生的条件" class="headerlink" title="1. 间隙锁产生的条件"></a>1. 间隙锁产生的条件</h6><p>InnoDB间隙锁产生需要满足三个条件：</p>
<ol>
<li>隔离级别是RR（可重复读）</li>
<li>当前读</li>
<li>检索过程用的了索引</li>
</ol>
<h6 id="2-间隙锁的作用"><a href="#2-间隙锁的作用" class="headerlink" title="2. 间隙锁的作用"></a>2. 间隙锁的作用</h6><p>官方文档：间隙锁的目的是让其他事务无法在间隙中新增数据。  </p>
<p>InnoDB在RR模式中间隙锁的两个作用：</p>
<ol>
<li>保障数据的恢复和复制<blockquote>
<p>数据库数据的恢复是通过binlog实现的，binlog中记录了执行成功的DML语句，在数据恢复时需要保证数据之间的事物顺序，间隙锁避免了在一批数据中插入其他事务。</p>
</blockquote>
</li>
<li>防止幻读<blockquote>
<ol>
<li>防止在间隙中执行insert语句</li>
<li>防止将已有的数据update到间隙中</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="InnoDB表锁模式兼容性列表"><a href="#InnoDB表锁模式兼容性列表" class="headerlink" title="InnoDB表锁模式兼容性列表"></a>InnoDB表锁模式兼容性列表</h4><table>
<thead>
<tr>
<th align="left">当前锁模式/请求锁模式</th>
<th align="left">X</th>
<th align="left">IX</th>
<th align="left">S</th>
<th align="left">IS</th>
</tr>
</thead>
<tbody><tr>
<td align="left">X</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">IX</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">S</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
<tr>
<td align="left">IS</td>
<td align="left">冲突</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
<td align="left">兼容</td>
</tr>
</tbody></table>
<h4 id="锁分类表"><a href="#锁分类表" class="headerlink" title="锁分类表"></a>锁分类表</h4><table>
<thead>
<tr>
<th align="left">锁粒度/锁分类</th>
<th align="left">排他锁</th>
<th align="left">共享锁</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">表级</td>
<td align="left">表级排他锁</td>
<td align="left">表级共享锁</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">行级</td>
<td align="left">行级排他锁</td>
<td align="left">行锁共享锁</td>
<td align="left">innoDB的行锁是加在索引项，通过索引检索的数据才能使用行锁，否则使用表锁</td>
</tr>
<tr>
<td align="left">多粒度共存</td>
<td align="left">表级意向排他锁</td>
<td align="left">表级意向共享锁</td>
<td align="left">表锁和行锁同时使用时，只有获取表级意向锁成功后，才可以加行锁。意向锁是innoDB的内部锁，保证了表锁和行锁不会冲突</td>
</tr>
</tbody></table>
<h4 id="多版本并发控制协议"><a href="#多版本并发控制协议" class="headerlink" title="多版本并发控制协议"></a>多版本并发控制协议</h4><p>mysql面对并发问题，使用了两个并发控制方法：</p>
<ol>
<li>基于锁的并发控制(Based-lock Concurrency Control)</li>
<li>基于多版本的并发控制(MVCC Multi-Version Concurrency Control)</li>
</ol>
<h5 id="mvcc优点："><a href="#mvcc优点：" class="headerlink" title="mvcc优点："></a>mvcc优点：</h5><ol>
<li>读操作不加锁</li>
<li>读写不冲突<br>这两个优点，使得数据库并发性很好。  </li>
</ol>
<h5 id="mvcc缺点："><a href="#mvcc缺点：" class="headerlink" title="mvcc缺点："></a>mvcc缺点：</h5><ol>
<li>每行都额外存储的版本信息</li>
<li>需要维护行的数据版本信息</li>
<li>检索时需要进行版本比较，降低查询效率</li>
<li>定期清理不需要的行版本，回收空间，增加了开销</li>
</ol>
<h5 id="mvcc实现机制"><a href="#mvcc实现机制" class="headerlink" title="mvcc实现机制"></a>mvcc实现机制</h5><ol>
<li>每行都隐藏一个版本字段，记录着该行的最新版本</li>
<li>每次查询开始时读取行数据并分配新的版本号</li>
<li>通过比较版本号确定后续操作</li>
</ol>
<h5 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h5><p>有两种读操作：快照读，当前读</p>
<ol>
<li><p>快照读 snapshot read</p>
<blockquote>
<p>快照读：读取的是记录的可见版本，不用加锁。<br>快照读适用隔离级别: Read Committed 和 Read Repeatable。<br>select语句使用的就是快照读，除了加锁的select。</p>
</blockquote>
</li>
<li><p>当前读 current</p>
<blockquote>
<p>当前读：读取最新成功事务的数据，并加锁，以阻塞其他事务修改数据。<br>当前读通过Next-key锁(行锁+间隙锁)来实现 。<br>使用当前读的有两类语句：</p>
<ol>
<li>DML语句: insert(Unique Key的冲突检查)、update、delete</li>
<li>加锁select: select …for update; select … for share model</li>
</ol>
</blockquote>
</li>
</ol>
<h4 id="sql显示指定锁"><a href="#sql显示指定锁" class="headerlink" title="sql显示指定锁"></a>sql显示指定锁</h4><ul>
<li>表级排他锁  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock tables tableName [LOW_PRIORITY] WRITE</span><br><span class="line">...</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET AUTOCOMMIT=0;</span><br><span class="line">LOCK TABLES t1 WRITE, t2 READ, ...;</span><br><span class="line">[do something with tables t1 and t2 here];</span><br><span class="line">COMMIT;</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>表级共享锁  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock tables tableName READ [LOCAL]</span><br><span class="line">...</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>行级排他锁  </p>
<ol>
<li>insert、update、delete语句，innodb自动加排他锁(X锁)</li>
<li>查询语句指定排他锁：select * from table where ? for update;</li>
</ol>
</li>
<li><p>行级共享锁  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from table where ? lock in share mode;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>MyIsam表锁是 deadlock free的，所以不会产生死锁。<br>在InnoDB 中锁逐步获取的，所以会发送死锁情况。发生死锁后数据库有两种方式解决：</p>
<ol>
<li>innoDB自动检查到死锁，会让一个事务释放锁并回退，另一个事务获得锁，继续完成事务。</li>
<li>行锁是数据库引擎级别，表锁是Mysql Server级别，所以涉及到外部锁或表锁时，innoDB不能完全检测到死锁。这就需要通过设置锁超时参数来解决了，锁超时参数：innodb_lock_wait_timeout。这个参数主要是解决大量事务无法获取锁而挂起消耗大量资源问题的。</li>
</ol>
<h5 id="避免死锁方法"><a href="#避免死锁方法" class="headerlink" title="避免死锁方法"></a>避免死锁方法</h5><ol>
<li>应用中尽量以相同的顺序访问多个表</li>
<li>批量处理数据时，让数据每次以固定的顺序进行处理</li>
<li>在事务中申请锁时尽量一步到位，不应先申请共享锁再申请排他锁</li>
<li>前面讲过，在REPEATABLE-READ隔离级别下，如果两个线程同时对相同条件记录用SELECT…FOR UPDATE加排他锁，在没有符合该条件记录情况下，两个线程都会加锁成功。程序发现记录尚不存在，就试图插入一条新记录，如果两个线程都这么做，就会出现死锁。这种情况下，将隔离级别改成READ COMMITTED，就可避免问题。</li>
<li>当隔离级别为READ COMMITTED时，如果两个线程都先执行SELECT…FOR UPDATE，判断是否存在符合条件的记录，如果没有，就插入记录。此时，只有一个线程能插入成功，另一个线程会出现锁等待，当第1个线程提交后，第2个线程会因主键重出错，但虽然这个线程出错了，却会获得一个排他锁！这时如果有第3个线程又来申请排他锁，也会出现死锁。</li>
</ol>
<h5 id="减少锁冲突"><a href="#减少锁冲突" class="headerlink" title="减少锁冲突"></a>减少锁冲突</h5><ol>
<li>尽量使用较低的隔离级别</li>
<li>精心设计索引，尽量使用索引访问数据，可以加行锁，可以减少锁冲突的机会</li>
<li>选择合理的事物大小，事物越小发送冲突的几率越小</li>
<li>加锁时尽量一步到位</li>
<li>应用中尽量以相同的顺序访问多个表，减少死锁的机会</li>
<li>尽量用相等的条件访问数据，这样减少间隙锁对并发的影响</li>
<li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能。</li>
</ol>
<h4 id="相关语句"><a href="#相关语句" class="headerlink" title="相关语句"></a>相关语句</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 查看进程</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</span><br><span class="line">// 查看是否锁表</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">OPEN</span> <span class="keyword">TABLES</span> <span class="keyword">WHERE</span> In_use &gt; <span class="number">0</span>;</span><br><span class="line">// 查看正在锁的事务</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCKS;</span><br><span class="line">// 查看等待锁的事务</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> INFORMATION_SCHEMA.INNODB_LOCK_WAITS;</span><br><span class="line">// 确定最后一个死锁产生的原因</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">innodb</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>

<p>MySQL内部有两组专门的状态变量记录系统内部锁资源争用情况：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like 'table%';</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">| Variable_name              | Value   |</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">| Table_locks_immediate      | 100     |</span><br><span class="line">| Table_locks_waited         | 11      |</span><br><span class="line">+<span class="comment">----------------------------+---------+</span></span><br><span class="line">Table_locks_immediate：产生表级锁定的次数；</span><br><span class="line">Table_locks_waited：出现表级锁定争用而发生等待的次数；</span><br></pre></td></tr></table></figure>

<p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like 'InnoDB_row_lock%';</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| Variable_name                 | Value |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br><span class="line">| InnoDB_row_lock_current_waits | 0     |</span><br><span class="line">| InnoDB_row_lock_time          | 0     |</span><br><span class="line">| InnoDB_row_lock_time_avg      | 0     |</span><br><span class="line">| InnoDB_row_lock_time_max      | 0     |</span><br><span class="line">| InnoDB_row_lock_waits         | 0     |</span><br><span class="line">+<span class="comment">-------------------------------+-------+</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InnoDB 的行级锁定状态变量不仅记录了锁定等待次数，还记录了锁定总时长，每次平均时长，以及最大时长，此外还有一个非累积状态量显示了当前正在等待锁定的等待数量。对各个状态量的说明如下：</span><br><span class="line">InnoDB_row_lock_current_waits：当前正在等待锁定的数量；</span><br><span class="line">InnoDB_row_lock_time：从系统启动到现在锁定总时间长度；</span><br><span class="line">InnoDB_row_lock_time_avg：每次等待所花平均时间；</span><br><span class="line">InnoDB_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；</span><br><span class="line">InnoDB_row_lock_waits：系统启动后到现在总共等待的次数；</span><br><span class="line">尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统中为什么会有如此多的等待，然后根据分析结果着手指定优化计划。</span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>MySQL 锁机制——必知必会<br><a href="https://www.jianshu.com/p/0d5b7cd592f9" target="_blank" rel="noopener">https://www.jianshu.com/p/0d5b7cd592f9</a>  </p>
<p>MySQL优化笔记（八）–锁机制超详细解析（锁分类、事务并发、引擎并发控制）<br><a href="https://www.jianshu.com/p/163c96983ca9" target="_blank" rel="noopener">https://www.jianshu.com/p/163c96983ca9</a>  </p>
<p>mysql事务和锁InnoDB(转)<br><a href="https://yq.aliyun.com/articles/269775?spm=a2c4e.11153940.0.0.17e24148Ig0laX" target="_blank" rel="noopener">https://yq.aliyun.com/articles/269775?spm=a2c4e.11153940.0.0.17e24148Ig0laX</a></p>
<p>MySQL详解－－锁，事务<br><a href="https://yq.aliyun.com/articles/312765?spm=a2c4e.11153940.0.0.17e24148Ig0laX" target="_blank" rel="noopener">https://yq.aliyun.com/articles/312765?spm=a2c4e.11153940.0.0.17e24148Ig0laX</a></p>
<p>大众点评工程师：从特性说起，漫谈MySQL中的事务及其实现<br><a href="https://yq.aliyun.com/articles/79623?spm=a2c4e.11153940.0.0.279e908f4XiOak" target="_blank" rel="noopener">https://yq.aliyun.com/articles/79623?spm=a2c4e.11153940.0.0.279e908f4XiOak</a></p>
<p>MySQL—数据库从入门走向大神系列(六)-事务处理与事务隔离(锁机制)<br><a href="https://yq.aliyun.com/articles/272908?spm=a2c4e.11153940.0.0.279e908f4XiOak" target="_blank" rel="noopener">https://yq.aliyun.com/articles/272908?spm=a2c4e.11153940.0.0.279e908f4XiOak</a></p>
<p>MySQL中的锁（表锁、行锁）<br><a href="https://www.cnblogs.com/chenqionghe/p/4845693.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenqionghe/p/4845693.html</a></p>
<p>mysql数据库的锁有多少种，怎么编写加锁的sql语句<br><a href="https://www.cnblogs.com/sessionbest/articles/8689071.html" target="_blank" rel="noopener">https://www.cnblogs.com/sessionbest/articles/8689071.html</a></p>
<p>探索Mysql锁机制(一)——乐观锁&amp;悲观锁<br><a href="https://www.jianshu.com/p/ed896335b3b4" target="_blank" rel="noopener">https://www.jianshu.com/p/ed896335b3b4</a></p>
<p>探索Mysql锁机制(二)——共享锁&amp;排他锁&amp;意向锁&amp;间隙锁<br><a href="https://www.jianshu.com/p/904f52bde904" target="_blank" rel="noopener">https://www.jianshu.com/p/904f52bde904</a></p>
<p>Mysql加锁过程详解<br><a href="https://www.cnblogs.com/crazylqy/p/7611069.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7611069.html</a></p>
<p>《快照读、当前读和MVCC》<br><a href="https://www.cnblogs.com/AlmostWasteTime/p/11466520.html" target="_blank" rel="noopener">https://www.cnblogs.com/AlmostWasteTime/p/11466520.html</a></p>
<p>从MVCC协议来区分不可重复读与幻读<br><a href="https://segmentfault.com/a/1190000020680168?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020680168?utm_source=tag-newest</a></p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>spring的事务 隔离级别和传播机制</title>
    <url>/2019/12/26/spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>快速理解 spring 隔离级别和传播机制</p>
<a id="more"></a>
<h3 id="事务ACID四大特性"><a href="#事务ACID四大特性" class="headerlink" title="事务ACID四大特性"></a>事务ACID四大特性</h3><ul>
<li>Atomicity 原子性：要么成功，要么失败，不允许部分成功或失败。</li>
<li>Consistency 一致性：事务操作之后数据库状态和业务规则一致。AB转账，A减少并且B增加。</li>
<li>Isolation 隔离性：多个事务并发执行，相互之间不干扰，和独立执行事务一样。</li>
<li>Durability 持久性：事务提交后被持久化到数据库.</li>
</ul>
<h3 id="spring事务知识点"><a href="#spring事务知识点" class="headerlink" title="spring事务知识点"></a>spring事务知识点</h3><ol>
<li>spring有两种事务管理方式：编程式和声明式<ul>
<li>编程式：在代码中显示调用beginTransaction(),commit(),rollback()等事务管理方法。</li>
<li>声明式：spring声明式事务是使用AOP切面实现，通过aop管理这事务的开始，提交和回滚。<br>注意两点：  <ol>
<li>@Transactional 应该注解在public方法中，因为需要AOP代理。</li>
<li>由于aop代理的是接口和类，所以同一个类中的两个方法调用是不会涉及到事务传播的。</li>
</ol>
</li>
</ul>
</li>
<li>spring事务隔离级别<ul>
<li>隔离级别：</li>
<li>spring支持的5种隔离级别：DEFAULT，READ_UNCOMMITTED，READ_COMMITTED，REPEATABLE_READ，SERIALIZABLE</li>
</ul>
</li>
<li>spring事务传播方式<ul>
<li>传播方式 ：</li>
<li>传播方式：REQUIRED，SUPPORTS，MANDATORY，REQUIRES_NEW，NOT_SUPPORTED，NEVER，NESTED</li>
</ul>
</li>
<li>事务回滚规则，指定遇到指定异常时事务进行回滚。</li>
<li>事务其他属性</li>
</ol>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="数据库并发访问面临的问题"><a href="#数据库并发访问面临的问题" class="headerlink" title="数据库并发访问面临的问题"></a>数据库并发访问面临的问题</h4><table>
<thead>
<tr>
<th align="left">英文名</th>
<th align="left">中文名</th>
<th align="left">问题描述</th>
<th align="left">缺点</th>
<th align="left">mysql解决方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Dirty Read</td>
<td align="left">脏读</td>
<td align="left">事务A未提交的数据被其他事务B读取，如果事务A回滚，事务B的数据就是错误。</td>
<td align="left">会读到未提交的数据(脏数据)</td>
<td align="left">没加锁时会脏读产生，加锁就可以解决脏读</td>
</tr>
<tr>
<td align="left">No-Repeatable read</td>
<td align="left">不可重复读</td>
<td align="left">一次事务中两次相同数据的内容不一致，同一数据的内容有变化了，导致不能重复读取同一数据，原因是在两次查询时间段内其他事务更新(update和delete)了数据。</td>
<td align="left">一次事务不能重复读取同一数据</td>
<td align="left">使用有索引时使用行锁控制行的更新和删除，</td>
</tr>
<tr>
<td align="left">Phantom Read</td>
<td align="left">幻读</td>
<td align="left">一次事务中两次读取一定范围的数据时有新数据(‘幻影’行)产生，原因是在两次查询时间段内其他事务新增(insert)了数据。</td>
<td align="left">一次事务两次读取数据的数量不同了</td>
<td align="left">Next-Key锁(行锁和GAP间隙锁两者的合并) ,行锁锁定一定范围的行，间隙锁锁定范围两边的数据，这样就保证不会插入数据</td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h4 id="spring支持的隔离级别"><a href="#spring支持的隔离级别" class="headerlink" title="spring支持的隔离级别"></a>spring支持的隔离级别</h4><p>| 名称 | 说明| 存在问题|解决的问题|mysql解决方式|<br>|:—|:—| :—|:—|<br>|DEFAULT          |默认值，spring使用数据库设置的隔离级别 |  | | |<br>|READ_UNCOMMITTED |读未提交内容 |脏读，不可重复读，幻读 | | |<br>|READ_COMMITTED   |读取提交内容 |不可重复读，幻读  | 脏读| |<br>|REPEATABLE_READ  |可重复读，mysql默认值 | 幻读  |脏读，不可重复读 | |<br>|SERIALIZABLE     |可串行化 |   |脏读，不可重复读，幻读 |使用悲观锁理论，读加共享锁，写加排他锁，读写互斥 |</p>
<h3 id="传播机制"><a href="#传播机制" class="headerlink" title="传播机制"></a>传播机制</h3><p>| 名称 | 说明|没有事务|已存在事务|事务提交|事务回滚|<br>|:—|:—| :—|:—|:—|<br>|REQUIRED     |默认，必须有事务|新建事务|加入当前事务|一起提交 |一起回滚 |<br>|SUPPORTS     |支持已有事务 |非事务方式运行 |加入当前事务 |一起提交 |一起回滚 |<br>|MANDATORY    |强制使用事务 |抛出异常，父方法必须有事务 |加入当前事务 |一起提交 |一起回滚 |<br>|REQUIRES_NEW |总是新建事务 |新建事务 |挂起父事务 |子事务单独提交，然后挂起的父事务继续提交 |父事务回滚,子事务不受不影响；子事务回滚，父事务捕获子事务异常后不回滚 |<br>|NOT_SUPPORTED|总是以非事务方式运行 |非事务方式运行 |挂起父事务，以非事务方式运行 |无 | 无|<br>|NEVER        |一点事务都没有 |非事务方式运行 |抛出异常，父方法不能有事务 | 无| 无|<br>|NESTED       |嵌套事务 |新建事务 |成为子事务 | 父事务和嵌套事务一起提交| 父事务回滚时嵌套事务也需要回滚；嵌套事务回滚时父事务可以不回滚|</p>
<h3 id="事务回滚规则"><a href="#事务回滚规则" class="headerlink" title="事务回滚规则"></a>事务回滚规则</h3><ul>
<li>java异常分类：异常分为 Error和Throwable， Throwable又分</li>
<li>为RuntimeException(unchecked)和checked<br>spring默认回滚规则：uncheck异常和Error会回滚事务；checked异常不回滚事务。</li>
</ul>
<h4 id="设置回滚的异常"><a href="#设置回滚的异常" class="headerlink" title="设置回滚的异常"></a>设置回滚的异常</h4><ul>
<li>遇到checked异常时回滚事务：<br>@Transactional(rollbackFor = Exception.class)<br>@Transactional(rollbackForClassName = “Exception”)</li>
<li>遇到unchecked异常时回滚事务(默认)<br>@Transactional(rollbackFor = RuntimeException.class)<br>@Transactional(rollbackForClassName = “RuntimeException”)</li>
<li>全部异常都回滚<br>@Transactional(rollbackFor = {RuntimeException.class,Exception.class})<br>@Transactional(rollbackForClassName = { “RuntimeException”, “Exception”})</li>
<li>指定的异常不回滚<br>@Transactional(noRollbackFor = {RuntimeException.class,Exception.class})<br>@Transactional(noRollbackForClassName = { “RuntimeException”, “Exception”})</li>
</ul>
<h3 id="事务其他配置"><a href="#事务其他配置" class="headerlink" title="事务其他配置"></a>事务其他配置</h3><ul>
<li>readOnly : true: 只读事务，false : 可读写(默认值)</li>
<li>timeout : 设置事务超时时间，默认值 -1，表示永不过期</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>事务是线程安全的。</li>
<li>事务继续问题。</li>
<li>声明式事务，@Transactional 应该注解到public方法上。</li>
<li>声明式事务是基于aop实现的，所以同一个类中方法调用时事务是不起作用的。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/zhangyu672090/article/details/82828542" target="_blank" rel="noopener">https://blog.csdn.net/zhangyu672090/article/details/82828542</a><br><a href="https://segmentfault.com/a/1190000020386113?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020386113?utm_source=tag-newest</a><br><a href="https://blog.csdn.net/yuanlaishini2010/article/details/45792069" target="_blank" rel="noopener">https://blog.csdn.net/yuanlaishini2010/article/details/45792069</a><br><a href="https://yq.aliyun.com/articles/313201" target="_blank" rel="noopener">https://yq.aliyun.com/articles/313201</a><br><a href="https://www.cnblogs.com/fxtx/p/11630331.html" target="_blank" rel="noopener">https://www.cnblogs.com/fxtx/p/11630331.html</a><br><a href="https://www.w3xue.com/exp/article/20197/45742.html" target="_blank" rel="noopener">https://www.w3xue.com/exp/article/20197/45742.html</a></p>
<p>隔离级别<br><a href="https://yq.aliyun.com/articles/100727?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=8k1J_IfQ" target="_blank" rel="noopener">https://yq.aliyun.com/articles/100727?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=8k1J_IfQ</a><br><a href="https://yq.aliyun.com/articles/48893?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=IyVCk5A7" target="_blank" rel="noopener">https://yq.aliyun.com/articles/48893?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=IyVCk5A7</a><br><a href="https://yq.aliyun.com/articles/555101?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=OYciFPCm" target="_blank" rel="noopener">https://yq.aliyun.com/articles/555101?spm=5176.10695662.1996646101.searchclickresult.2f0a3da7rNcGEN&amp;aly_as=OYciFPCm</a><br><a href="https://www.cnblogs.com/ubuntu1/p/8999403.html" target="_blank" rel="noopener">https://www.cnblogs.com/ubuntu1/p/8999403.html</a><br><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/08/20/innodb-lock.html</a></p>
<p>Spring的TransactionEventListener<br><a href="https://www.jianshu.com/p/88b76e870c63" target="_blank" rel="noopener">https://www.jianshu.com/p/88b76e870c63</a></p>
]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2019/08/19/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>git clone <a href="https://github.com/libgit2/libgit2" target="_blank" rel="noopener">https://github.com/libgit2/libgit2</a> mylibgit # 克隆仓库并重新命名目录</p>
<h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>git init</p>
<a id="more"></a>

<h4 id="跟踪文件和修改"><a href="#跟踪文件和修改" class="headerlink" title="跟踪文件和修改"></a>跟踪文件和修改</h4><p>git add .  # 添加当前目录中文件<br>git add 文件名 # 添加指定文件<br>git add *.txt # 使用通配符</p>
<h4 id="查看修改文件"><a href="#查看修改文件" class="headerlink" title="查看修改文件"></a>查看修改文件</h4><p>查看详情的信息<br>git status<br>查看简短信息<br>git status –short 或 git status -s</p>
<h4 id="查看文件的修改内容"><a href="#查看文件的修改内容" class="headerlink" title="查看文件的修改内容"></a>查看文件的修改内容</h4><p>git diff fileName</p>
<h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><p>git commit -m “提交注释”</p>
<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><ol>
<li>git push &lt;1-远程主机名&gt; &lt;2-本地分支名&gt; : &lt;3-远程分支名&gt;<br>最全的命令</li>
<li>git push &lt;1-远程主机名&gt; &lt;2-本地分支名&gt;<br>省略(3-远程分支名),根据2-本地分支的追踪关系判断出(3-远程分支名).</li>
<li>git push &lt;1-远程主机名&gt;<br>省略 2和3选项, &lt;2-本地分支名&gt;：就是当前分支；&lt;3-远程分支名&gt;:和本地分支有追踪关系的远程分支</li>
<li>git push<br>省略 1、2、3选项，&lt;1-远程主机名&gt;: 只有一个(1-远程主机名), &lt;2-本地分支名&gt;：就是当前分支；&lt;3-远程分支名&gt;: 和本地分支有追踪关系的远程分支</li>
<li>git push –all origin<br>推送所有本地分支到origin主机</li>
<li>git push origin :master<br>删除master分支，等同于 git push origin –delete master</li>
<li>git push -u origin master 或 git push –set-upstream origin master<br>设置当前分支的追踪关系</li>
</ol>
<h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>git branch 分支名    # 创建分支<br>git branch -a       # 查看所有分支(本地和远程分支)<br>git branch -r       # 查看远程分支<br>git checkout 分支名  # 切换本地分支<br>git checkout -b newBranch origin/newBranch # checkout远程分支到本地<br>git branch -d 分支名 # 删除本地分支<br>git push origin –delete 分支名 # 删除远程分支<br>git branch -m <oldbranch> <newbranch> # 重命名本地分支  </newbranch></oldbranch></p>
<p>参数：<br>-d 或 –delete：删除<br>-D 或 –delete –force的快捷键<br>-f 或 –force：强制<br>-m 或 –move：移动或重命名<br>-M 或 –move –force的快捷键<br>-r 或 –remote：远程分支<br>-a 或 –all：所有分支  </p>
<h4 id="拉取数据"><a href="#拉取数据" class="headerlink" title="拉取数据"></a>拉取数据</h4><p>git fetch &lt;远程主机名&gt; &lt;分支名&gt; # 拉取指定分支的数据<br>git fetch &lt;远程主机名&gt;         # 拉取所有分支的数据<br>fetch从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。</p>
<h4 id="merge分支"><a href="#merge分支" class="headerlink" title="merge分支"></a>merge分支</h4><p>git checkout master # 切换到master分支<br>git merge dev       # 合并dev分支到当前分支  </p>
<h4 id="拉取并合并-pull"><a href="#拉取并合并-pull" class="headerlink" title="拉取并合并 pull"></a>拉取并合并 pull</h4><p>git pull &lt;远程主机&gt; &lt;远程分支&gt; : &lt;本地分支&gt;<br>git pull &lt;远程主机&gt; &lt;分支名(远程和本地同名)&gt;<br>git pull origin master # 等同于：git fetch master + git merge FETCH_HEAD</p>
<h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><p>git log<br>git log –name-status # 每次修改的文件列表, 显示状态<br>git log –name-only # 每次修改的文件列表<br>git log –stat # 每次修改的文件列表, 及文件修改的统计<br>git whatchanged # 每次修改的文件列表<br>git whatchanged –stat # 每次修改的文件列表, 及文件修改的统计<br>git show # 显示最后一次的文件改变的具体内容<br>git show -5 # 显示最后 5 次的文件改变的具体内容<br>git show commitid # 显示某个 commitid 改变的具体内容<br>$ git log -p FETCH_HEAD # 查看当前分支在服务器上的最新状态  </p>
<h4 id="查看历史命令"><a href="#查看历史命令" class="headerlink" title="查看历史命令"></a>查看历史命令</h4><p>git reflog  </p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>git rm 文件名 # 彻底删除文件<br>git rm –cached 文件名 #只消除跟踪，不删除文件  </p>
<h4 id="回退版本"><a href="#回退版本" class="headerlink" title="回退版本"></a>回退版本</h4><p>git reset –hard HEAD^ ##回退上一个版本<br>git reset –hard HEAD~5 ##回退上5个版本，通过reflog查看  </p>
<h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>git checkout – file/git reset HEAD</p>
<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h4><p>git tag</p>
<h4 id="git参考"><a href="#git参考" class="headerlink" title="git参考"></a>git参考</h4><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2</a></p>
]]></content>
      <tags>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/2019/07/31/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>markdown常用的语法</p>
<a id="more"></a>

<h3 id="gt-标题"><a href="#gt-标题" class="headerlink" title="&gt; 标题"></a>&gt; 标题</h3><p>第一种方法：#</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># h1</span><br><span class="line">## h2</span><br><span class="line">### h3</span><br><span class="line">#### h4</span><br><span class="line">##### h5</span><br><span class="line">###### h6</span><br></pre></td></tr></table></figure>

<p>一般#作为文章大标题，只有一个，### 作为段落标题。  </p>
<p>第二种方式：上下文标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">===</span><br><span class="line">二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<h3 id="gt-段落"><a href="#gt-段落" class="headerlink" title="&gt; 段落"></a>&gt; 段落</h3><p> 换行方式：<br>    1. 行尾加两个空格<br>    2. 段落后加一个空行，表示新起一行<br>    3. 行尾使用&lt;br&gt; 换行  </p>
<h3 id="gt-区块引用"><a href="#gt-区块引用" class="headerlink" title="&gt; 区块引用"></a>&gt; 区块引用</h3><p>  段落开头使用 &gt; 并紧跟一个空格<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块  </span><br><span class="line">&gt; 区块2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区块<br>区块2</p>
</blockquote>
<p>  区块嵌套<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块</span><br><span class="line">&gt; &gt;区块嵌套</span><br><span class="line">&gt; &gt; &gt;区块嵌套</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区块</p>
<blockquote>
<p>区块嵌套</p>
<blockquote>
<p>区块嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<p>  区块和列表结合使用<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 列表1</span><br><span class="line">&gt; 2. 列表2</span><br><span class="line">&gt; 3. 列表3</span><br><span class="line">&gt; * 无序列表1</span><br><span class="line">&gt; * 无序列表2</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>区块中使用列表</p>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
</ul>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 列表中使用区块</span><br><span class="line">    &gt; 区块1  </span><br><span class="line">    &gt; 区块2  </span><br><span class="line">* 列表中使用区块2</span><br><span class="line">    &gt; 区块3  </span><br><span class="line">    &gt; 区块4</span><br></pre></td></tr></table></figure>

<ul>
<li>列表中使用区块<blockquote>
<p>区块1<br>区块2  </p>
</blockquote>
</li>
<li>列表中使用区块2<blockquote>
<p>区块3<br>区块4</p>
</blockquote>
</li>
</ul>
<h3 id="gt-代码区块"><a href="#gt-代码区块" class="headerlink" title="&gt; 代码区块"></a>&gt; 代码区块</h3><ol>
<li>单行代码使用 `` 包围<br>`RiskVo vo = riskService.getRiskInfo();`<br><code>RiskVo vo = riskService.getRiskInfo();</code></li>
</ol>
<ol start="2">
<li><p>多行代码块使用```包围，可以指定语言  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">``` javascript</span><br><span class="line">$(document).ready(function () &#123;</span><br><span class="line">  alert(&apos;code block&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'code block'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="gt-强调"><a href="#gt-强调" class="headerlink" title="&gt; 强调"></a>&gt; 强调</h3><ol>
<li><p>使用 * 或 _ 表示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*  </span><br><span class="line">**粗体文本**  </span><br><span class="line">***粗斜体文本***  </span><br><span class="line">_斜体文本_  </span><br><span class="line">__粗体文本__  </span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure>

<p><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong></p>
</li>
<li><p>删除线用波浪线表示  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~删除我~~</span><br></pre></td></tr></table></figure>

<p><del>删除我</del></p>
</li>
<li><p>下划线 &lt;u&gt;  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;下划线&lt;\u&gt;</span><br></pre></td></tr></table></figure>

<p><u>下划线</u></p>
</li>
</ol>
<h3 id="gt-列表"><a href="#gt-列表" class="headerlink" title="&gt; 列表"></a>&gt; 列表</h3><ol>
<li><p>无序列表(*,+,- 表示)  </p>
<ul>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ul>
</li>
<li><p>有序列表(数字 + . + 空格)</p>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<p>嵌套时使用4个空格或一个制表符</p>
</li>
</ol>
<h3 id="gt-分割线"><a href="#gt-分割线" class="headerlink" title="&gt; 分割线"></a>&gt; 分割线</h3><p>  一行用三个以上的星号、减号、底线来建立一个分隔线<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure></p>
<h3 id="gt-链接"><a href="#gt-链接" class="headerlink" title="&gt; 链接"></a>&gt; 链接</h3><ol>
<li><p>行内式链接<br>格式：[链接名称](链接地址 “标题”)  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索 \[百度\](https://www.baidu.com &quot;这是百度&quot;)</span><br><span class="line">自动生成链接 &lt;https://www.toutiao.com/&gt;</span><br></pre></td></tr></table></figure>

<p>搜索 <a href="http://www.baidu.com" title="这是百度" target="_blank" rel="noopener">百度</a><br>自动生成链接 <a href="https://www.toutiao.com/" target="_blank" rel="noopener">https://www.toutiao.com/</a></p>
</li>
<li><p>参考式链接<br>格式：<br>[链接名称][链接标记]<br>[链接标记]: 链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">搜索 [百度][1]  </span><br><span class="line">搜索 [头条][toutiao]  </span><br><span class="line">搜索 [google][]  </span><br><span class="line"></span><br><span class="line">[1]: https://www.baidu.com</span><br><span class="line">[toutiao]: https://www.toutiao.com</span><br><span class="line">[google]: https://www.google.com</span><br></pre></td></tr></table></figure>

<p>搜索 <a href="https://www.baidu.com" target="_blank" rel="noopener">百度</a><br>搜索 <a href="https://www.toutiao.com" target="_blank" rel="noopener">头条</a><br>搜索 <a href="https://www.google.com" target="_blank" rel="noopener">google</a>  </p>
</li>
</ol>
<h3 id="gt-图片"><a href="#gt-图片" class="headerlink" title="&gt; 图片"></a>&gt; 图片</h3><p>格式与链接相似，也含有行内式和参考式</p>
<ol>
<li><p>行内式链接<br>格式：![图片名称](图片地址 “标题”)  </p>
<p>图片： ![百度](path/logo.png “百度logo”)  </p>
</li>
<li><p>参考式链接<br>格式：<br>[图片名称][链接标记]<br>[链接标记]: 图片地址</p>
<p>图片： [百度][1]<br>图片： [头条][toutiao]<br>图片： [google][]  </p>
<p> [1]: path/logo.png<br> [toutiao]: path/logo.png<br> [google]: path/logo.png  </p>
</li>
</ol>
<h3 id="gt-表格"><a href="#gt-表格" class="headerlink" title="&gt; 表格"></a>&gt; 表格</h3><pre><code>语法格式：
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 表头 | 表头| 表头|</span><br><span class="line">| ---: | :--- | :---:|</span><br><span class="line">|右对齐|左对齐| 居中对齐 |</span><br><span class="line">|右对齐|左对齐| 居中对齐 |</span><br></pre></td></tr></table></figure></code></pre><h3 id="gt-反斜杠"><a href="#gt-反斜杠" class="headerlink" title="&gt; 反斜杠"></a>&gt; 反斜杠</h3><p>在一些符号前加反斜杠进行转义，这些符号在markdown中有语法含义，可以加反斜杠的符号如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">`   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   底线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  括弧</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   惊叹号</span><br></pre></td></tr></table></figure>

<h3 id="gt-流程图"><a href="#gt-流程图" class="headerlink" title="&gt; 流程图"></a>&gt; 流程图</h3><p>TODO</p>
<h3 id="gt-常用html元素"><a href="#gt-常用html元素" class="headerlink" title="&gt; 常用html元素"></a>&gt; 常用html元素</h3><ol>
<li><p>字体属性font<br><code>&lt;font color=red face=“黑体” size=3&gt;红色&lt;/font&gt;</code><br><font color="red" face="“黑体”" size="3">红色</font></p>
</li>
<li><p>文字排版<br><code>&lt;center&gt;这一行需要居中&lt;/center&gt;</code></p>
<center>这一行需要居中</center>

<p><code>&lt;p align=&quot;right&quot;&gt;右对齐&lt;/p&gt;</code></p>
<p align="right">右对齐</p>
`<p align="left">左对齐</p>`
<p align="left">左对齐</p>
</li>
<li><p>首行缩进<br>HTML提供了5种空格实体:   </p>
<ul>
<li><p><code>&amp;nbsp;</code> 非断行空格,常规的宽度，常用</p>
</li>
<li><p><code>&amp;ensp;</code> 半角空格(En Space)  </p>
</li>
<li><p><code>&amp;emsp;</code> 全角空格(Em Space)  </p>
<p>参考 : <a href="https://www.jianshu.com/p/160e5cb0209c" target="_blank" rel="noopener">https://www.jianshu.com/p/160e5cb0209c</a></p>
</li>
</ul>
</li>
<li><p>span 元素<br><code>&lt;span style=&quot;font-size:15px;background:red;&quot;&gt;**Bigger**&lt;/span&gt;</code></p>
<p><span style="font-size:15px;background:red;"><strong>Bigger</strong></span></p>
</li>
<li><p>details 折叠语法标签</p>
<details>
<summary>点击时的区域标题：点击查看详细内容</summary>
<p> - 测试 测试测试</p>
<pre><code>title，value，callBack可以缺省</code></pre>
</details>
</li>
<li><p>kbd 按键标识<br><code>&lt;kbd&gt;ctr&lt;/kbd&gt; &lt;kbd&gt;+&lt;/kbd&gt; &lt;kbd&gt;D&lt;/kbd&gt;</code><br><kbd>ctr</kbd> <kbd>+</kbd> <kbd>D</kbd>  </p>
</li>
</ol>
]]></content>
      <tags>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>node常用命令</title>
    <url>/2019/07/31/node%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>node常用到的一些命令</p>
<a id="more"></a>
<h3 id="node简介"><a href="#node简介" class="headerlink" title="node简介"></a>node简介</h3><p>官方地址： <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a><br>nodejs中文：<a href="http://nodejs.cn/" target="_blank" rel="noopener">http://nodejs.cn/</a><br>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。</p>
<h3 id="node-常用命令"><a href="#node-常用命令" class="headerlink" title="node 常用命令"></a>node 常用命令</h3><ol>
<li>node ##进入 REPL 环境</li>
<li>node -e ‘console.log(“Hello World”)’  ##执行脚本字符串</li>
<li>运行脚本文件<br>$ node index.js<br>$ node path/index.js<br>$ node path/index（可以不用加js后缀，默认就是js后缀）</li>
<li>node –help  ##查看帮忙文档</li>
</ol>
<h3 id="nvm-常用命令"><a href="#nvm-常用命令" class="headerlink" title="nvm 常用命令"></a>nvm 常用命令</h3><ol>
<li>nvm list  ##是查找本电脑上所有的node版本<ul>
<li>nvm list  ##查看已经安装的版本</li>
<li>nvm list installed  ##查看已经安装的版本</li>
<li>nvm list available  ##查看网络可以安装的版本</li>
</ul>
</li>
<li>nvm install  ##安装最新版本nvm</li>
<li>nvm use <version>  ## 切换使用指定的版本node</version></li>
<li>nvm ls  ##列出所有版本</li>
<li>nvm current  ##显示当前版本</li>
<li>nvm alias <name> <version>  ## 给不同的版本号添加别名</version></name></li>
<li>nvm unalias <name>  ## 删除已定义的别名</name></li>
<li>nvm reinstall-packages <version>  ## 在当前版本node环境下，重新全局安装指定版本号的npm包</version></li>
<li>nvm on  ##打开nodejs控制</li>
<li>nvm off  ##关闭nodejs控制</li>
<li>nvm proxy  ##查看设置与代理</li>
<li>nvm node_mirror [url]<br>设置或者查看setting.txt中的node_mirror，如果不设置的默认是 <a href="https://nodejs.org/dist/" target="_blank" rel="noopener">https://nodejs.org/dist/</a></li>
<li>nvm uninstall <version>  ##卸载制定的版本</version></li>
<li>nvm use [version] [arch]  ##切换制定的node版本和位数</li>
<li>nvm root [path]  ##设置和查看root路径</li>
<li>nvm version  ##查看当前的版本</li>
</ol>
<h3 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h3><ol>
<li>npm install <name> -g   ##将包安装到全局环境中    <ul>
<li>npm install –python=python2.7  </li>
<li>npm config set python python2.7   </li>
<li>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a>   ##安装cnpm (国内淘宝镜像源),主要用于某些包或命令程序下载不下来的情况</li>
<li>npm install -g express 全局安装express模块</li>
</ul>
</name></li>
<li>npm list ## 查看当前目录下已安装的node包<ul>
<li>Node模块搜索是从代码执行的当前目录开始的，搜索结果取决于当前使用的目录中的node_modules下的内容。</li>
<li>$ npm list parseable=true可以目录的形式来展现当前安装的所有node包</li>
</ul>
</li>
<li>npm help  ## 查看帮助命令</li>
<li>npm view moudleName dependencies  ##查看包的依赖关系</li>
<li>npm view moduleName repository.url  ##查看包的源文件地址</li>
<li>npm view moduleName engines  ##查看包所依赖的Node的版本</li>
<li>npm help folders  ##查看npm使用的所有文件夹</li>
<li>npm rebuild moduleName  ##用于更改包内容后进行重建</li>
<li>npm outdated   ##检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新</li>
<li>npm update moduleName  ##升级更新node模块   </li>
<li>npm uninstall moudleName  ##卸载node模块</li>
<li>npm search packageName  ##需要检验某个包名是否已存在</li>
<li>npm init  ##会引导你创建一个package.json文件，包括名称、版本、作者这些信息等</li>
<li>npm root  ##查看当前包的安装路径</li>
<li>npm root -g   ##查看全局的包的安装路径</li>
<li>npm -v    ##查看npm安装的版本</li>
<li>npm show <name>  ##显示模块详情<br>npm show express</name></li>
<li>npm i n -g -f   ##安装 n 模块</li>
<li>n –version   ##查看n版本</li>
</ol>
]]></content>
      <tags>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo常用命令</title>
    <url>/2019/07/31/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>博客框架hexo 常用到的一些命令</p>
<a id="more"></a>

<h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><p>主页： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h3><h4 id="hexo-version"><a href="#hexo-version" class="headerlink" title="hexo version"></a>hexo version</h4><p>显示 Hexo 版本</p>
<h4 id="hexo-new-layout"><a href="#hexo-new-layout" class="headerlink" title="hexo new [layout] "></a>hexo new [layout] <title></title></h4><p>hexo new “我的第一篇文章”<br>hexo new post “我的第一篇文章”<br>hexo new draft “我的草稿”<br>hexo new page “tags”<br>hexo new page “tags”   </p>
<h4 id="hexo-generate"><a href="#hexo-generate" class="headerlink" title="hexo generate"></a>hexo generate</h4><p>生成静态文件,简化命令 hexo g<br>  -d, –deploy    文件生成后立即部署网站<br>  -w, –watch    监视文件变动  </p>
<h4 id="hexo-publish-layout"><a href="#hexo-publish-layout" class="headerlink" title="hexo publish [layout] "></a>hexo publish [layout] <filename></filename></h4><p>发布草稿</p>
<h4 id="hexo-server"><a href="#hexo-server" class="headerlink" title="hexo server"></a>hexo server</h4><p>启动hexo服务</p>
<h4 id="hexo-deploy"><a href="#hexo-deploy" class="headerlink" title="hexo deploy"></a>hexo deploy</h4><p>部署站点到git服务器上，命令简写： hexo d<br>-g, –generate    部署之前预先生成静态文件</p>
<h4 id="hexo-clean"><a href="#hexo-clean" class="headerlink" title="hexo clean"></a>hexo clean</h4><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p>
<h4 id="hexo-–debug"><a href="#hexo-–debug" class="headerlink" title="hexo –debug"></a>hexo –debug</h4><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p>
<h4 id="hexo-–draft"><a href="#hexo-–draft" class="headerlink" title="hexo –draft"></a>hexo –draft</h4><p>显示’source/_drafts’ 文件夹中的草稿文章。</p>
<h4 id="hexo-server-–drafts"><a href="#hexo-server-–drafts" class="headerlink" title="hexo server –drafts"></a>hexo server –drafts</h4><p>希望强行预览草稿，或者更改配置文件：<br>render_drafts: true</p>
<h4 id="hexo-publish-layout-1"><a href="#hexo-publish-layout-1" class="headerlink" title="hexo publish [layout] "></a>hexo publish [layout] <filename></filename></h4><p> 发布草稿，filename中不含’.md’</p>
<h3 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h3><p>$hexo clean &amp;&amp; hexo g &amp;&amp; hexo s<br>重新生成静态文件并启动服务</p>
<h3 id="模版（Scaffold）"><a href="#模版（Scaffold）" class="headerlink" title="模版（Scaffold）"></a>模版（Scaffold）</h3><p>在scaffolds目录下新建模板photo.md,编辑photo.md，然后就可以根据模板新建文章了，生成的文件存放在 source/_posts中。<br>hexo new photo “My Gallery”</p>
<h4 id="创建分类"><a href="#创建分类" class="headerlink" title="创建分类"></a>创建分类</h4><p>$ hexo new page categories<br>修改配置文件：<br>$hexo_home/source/categories/index.md<br>添加：<br>type: “categories”</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>$ hexo new page tags<br>修改配置文件：<br>$hexo_home/source/tags/index.md<br>添加一行：<br>type: “tags”</p>
<h4 id="安装其他插件"><a href="#安装其他插件" class="headerlink" title="安装其他插件"></a>安装其他插件</h4><p>npm install hexo-deployer-git –save<br>npm install hexo-generator-index –save<br>npm install hexo-generator-archive –save<br>npm install hexo-generator-tag –save<br>npm install hexo-generator-sitemap –save<br>npm install hexo-baidu-url-submit –save</p>
]]></content>
      <tags>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上搭建hexo</title>
    <url>/2019/07/24/mac%E4%B8%8A%E6%90%AD%E5%BB%BAhexo/</url>
    <content><![CDATA[<h3 id="本文简介"><a href="#本文简介" class="headerlink" title="本文简介"></a>本文简介</h3><p>&ensp;&ensp;在mac osx系统上安装配置博客框架hexo，并配置发布到github page上。</p>
<a id="more"></a>

<h3 id="hexo简介"><a href="#hexo简介" class="headerlink" title="hexo简介"></a>hexo简介</h3><p>主页： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>&emsp;&emsp;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><h4 id="安装homebrew"><a href="#安装homebrew" class="headerlink" title="安装homebrew"></a>安装homebrew</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)</span>"</span></span><br></pre></td></tr></table></figure>

<h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><p>$git –version<br>$brew install git<br>$git –version</p>
<h4 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$node</span> -v</span><br><span class="line"><span class="variable">$brew</span> install node</span><br><span class="line"><span class="variable">$node</span> -v</span><br><span class="line"><span class="variable">$npm</span> --version</span><br><span class="line"><span class="comment"># 如果npm命令不识别，需要加入环境配置中</span></span><br><span class="line"><span class="comment"># 如果使用bash</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>:<span class="variable">$(brew --prefix node)</span>/libexec/bin"</span> &gt;&gt; .bash_profile</span><br><span class="line"><span class="comment"># 如果使用zsh</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"export PATH=<span class="variable">$(brew --prefix node)</span>/libexec/bin"</span> &gt;&gt; .zshrc</span><br></pre></td></tr></table></figure>

<h4 id="安装nvm"><a href="#安装nvm" class="headerlink" title="安装nvm"></a>安装nvm</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nvm</span> --version</span><br><span class="line"><span class="variable">$brew</span> install nvm</span><br><span class="line"><span class="comment"># 加入环境配置文件中</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"source <span class="variable">$(brew --prefix nvm)</span>/nvm.sh"</span> &gt;&gt; ~/.bash_profile</span><br><span class="line"><span class="comment"># 如果用的是zsh，使用下面命令</span></span><br><span class="line"><span class="variable">$echo</span> <span class="string">"source <span class="variable">$(brew --prefix nvm)</span>/nvm.sh"</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="comment"># 检查是否识别</span></span><br><span class="line"><span class="variable">$nvm</span> --version</span><br></pre></td></tr></table></figure>

<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>官网地址：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a><br>github：<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">https://github.com/hexojs/hexo</a></p>
<h4 id="安装hexo-cli模块"><a href="#安装hexo-cli模块" class="headerlink" title="安装hexo-cli模块"></a>安装hexo-cli模块</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>查看hexo版本信息</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> version</span><br></pre></td></tr></table></figure>

<h4 id="下载hexo文件到blog目录"><a href="#下载hexo文件到blog目录" class="headerlink" title="下载hexo文件到blog目录"></a>下载hexo文件到blog目录</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$mkdir</span> ~/blog</span><br><span class="line"><span class="variable">$cd</span> ~/blog</span><br><span class="line"><span class="variable">$hexo</span> init</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> init ~/blog</span><br><span class="line"><span class="variable">$cd</span> ~/blog</span><br></pre></td></tr></table></figure>

<p>实际执行的命令是：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/hexojs/hexo-starter.git</span><br></pre></td></tr></table></figure>

<h4 id="安装hexo的依赖包"><a href="#安装hexo的依赖包" class="headerlink" title="安装hexo的依赖包"></a>安装hexo的依赖包</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> install</span><br></pre></td></tr></table></figure>

<h4 id="生成hexo自带的实例文章"><a href="#生成hexo自带的实例文章" class="headerlink" title="生成hexo自带的实例文章"></a>生成hexo自带的实例文章</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> generate</span><br></pre></td></tr></table></figure>

<h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> server</span><br></pre></td></tr></table></figure>

<p>查看启动后效果 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>命令格式：<br>hexo new [layout] title<br>layout默认是post，_config.yml中有配置<br>$hexo new “我的第一篇文章”<br>$hexo new draft “我的草稿”<br>发布草稿<br>$hexo publish “我的草稿”  </p>
<h3 id="生成静态站点文件"><a href="#生成静态站点文件" class="headerlink" title="生成静态站点文件"></a>生成静态站点文件</h3><p>$hexo generate<br>或者<br>$hexo g  </p>
<h3 id="配置部署deploy"><a href="#配置部署deploy" class="headerlink" title="配置部署deploy"></a>配置部署deploy</h3><ol>
<li><p>安装部署插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$npm</span> install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置<br>修改配置文件 _config.yml 如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="attr">https://github.com/yourName/yourName.github.io.git</span></span><br><span class="line"><span class="attr">  branch:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">  message:</span> <span class="string">更新文章</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分支规划<br>master做为发布分支，产生的站点静态文件发布到master分支；新建一个分支做写作分支，例如writer分支。</p>
</li>
<li><p>文章部署<br>先生产静态文件再部署<br>$hexo d -g<br>或<br>$hexo g -d  </p>
</li>
<li><p>访问站点查看效果<br>访问你的站点 <a href="https://yourName.github.io" target="_blank" rel="noopener">https://yourName.github.io</a></p>
</li>
<li><p>添加ssh key<br>如果部署github失败，添加ssh key试试<br>参考：<br><a href="https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank" rel="noopener">https://help.github.com/en/articles/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent</a> <br><br><a href="https://help.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account" target="_blank" rel="noopener">https://help.github.com/en/articles/adding-a-new-ssh-key-to-your-github-account</a></p>
</li>
</ol>
<h3 id="创建标签和分类"><a href="#创建标签和分类" class="headerlink" title="创建标签和分类"></a>创建标签和分类</h3><ol>
<li><p>创建标签<br>hexo new page tags</p>
</li>
<li><p>修改配置<br>修改配置文件：<br>$hexo_home/source/tags/index.md<br>添加一行：<br>type: “tags”  </p>
</li>
<li><p>创建分类<br>hexo new page categories  </p>
</li>
<li><p>修改配置文件：<br>$hexo_home/source/categories/index.md<br>添加一行：<br>type: “categories”  </p>
</li>
<li><p>新建文章配置标签和分类  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章名称</span><br><span class="line">date: 2019-08-01 12:12:57</span><br><span class="line">categories:</span><br><span class="line">- 我的分类</span><br><span class="line">- 我的子分类</span><br><span class="line">tags:</span><br><span class="line">- 生活</span><br><span class="line">- 娱乐</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="更换主题-next"><a href="#更换主题-next" class="headerlink" title="更换主题 next"></a>更换主题 next</h3><ol>
<li><p>下载主题<br>以next主题为例，next主题的官网地址：<a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">http://theme-next.iissnan.com</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/blog</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改配置 _config.yml  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br><span class="line">language: zh-Hans</span><br><span class="line">timezone: Asia/Shanghai</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新生产静态文件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="variable">$hexo</span> clean</span><br><span class="line"><span class="variable">$hexo</span> g</span><br><span class="line"><span class="variable">$hexo</span> server</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>查看效果：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
